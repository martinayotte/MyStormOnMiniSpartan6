
main.elf:     file format elf32-bigarm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000a9c  00000000  00000000  00008000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .text.startup 0000083c  00000a9c  00000a9c  00008a9c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000000c  000012d8  000012d8  000092d8  2**2
                  ALLOC
  3 .stack        00004000  00001300  00001300  000092d8  2**0
                  ALLOC
  4 .comment      00000070  00000000  00000000  000092d8  2**0
                  CONTENTS, READONLY
  5 .ARM.attributes 0000002c  00000000  00000000  00009348  2**0
                  CONTENTS, READONLY
  6 .debug_aranges 00000048  00000000  00000000  00009378  2**3
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00001779  00000000  00000000  000093c0  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 0000034a  00000000  00000000  0000ab39  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   000007c1  00000000  00000000  0000ae83  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000248  00000000  00000000  0000b644  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    00000366  00000000  00000000  0000b88c  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    000019cc  00000000  00000000  0000bbf2  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000300  00000000  00000000  0000d5be  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <_boot>:
_boot:

// Runtime Interrupt Vectors
// -------------------------
Vectors:
        b     _start                    // reset - _start
   0:	ea000012 	b	50 <_mainCRTStartup>
        b     und_handler               // undefined - _undf
   4:	ea000062 	b	194 <und_handler>
        b     swi_handler               // SWI - _swi
   8:	ea000055 	b	164 <swi_handler>
        b     iab_handler               // program abort - _pabt
   c:	ea000048 	b	134 <iab_handler>
        b     iab_handler               // data abort - _dabt
  10:	ea000047 	b	134 <iab_handler>
        nop                             // reserved
  14:	e1a00000 	nop			; (mov r0, r0)
        ldr   pc,[pc,#-0xFF0]           // IRQ - read the VIC
  18:	e51ffff0 	ldr	pc, [pc, #-4080]	; fffff030 <_end+0xffff9d30>
        ldr   pc,[pc,#-0xFF0]           // FIQ - read the VIC
  1c:	e51ffff0 	ldr	pc, [pc, #-4080]	; fffff034 <_end+0xffff9d34>

00000020 <_undf>:
  20:	00000038 	.word	0x00000038

00000024 <_swi>:
  24:	0000003c 	.word	0x0000003c

00000028 <_pabt>:
  28:	00000040 	.word	0x00000040

0000002c <_dabt>:
  2c:	00000044 	.word	0x00000044

00000030 <_irq>:
  30:	00000048 	.word	0x00000048

00000034 <_fiq>:
  34:	0000004c 	.word	0x0000004c

00000038 <__undf>:
_pabt:  .word __pabt                    // program abort
_dabt:  .word __dabt                    // data abort
_irq:   .word __irq                     // IRQ
_fiq:   .word __fiq                     // FIQ

__undf: b     .                         // undefined
  38:	eafffffe 	b	38 <__undf>

0000003c <__swi>:
__swi:  b     .                         // SWI
  3c:	eafffffe 	b	3c <__swi>

00000040 <__pabt>:
__pabt: b     .                         // program abort
  40:	eafffffe 	b	40 <__pabt>

00000044 <__dabt>:
__dabt: b     .                         // data abort
  44:	eafffffe 	b	44 <__dabt>

00000048 <__irq>:
__irq:  b     .                         // IRQ
  48:	eafffffe 	b	48 <__irq>

0000004c <__fiq>:
__fiq:  b     .                         // FIQ
  4c:	eafffffe 	b	4c <__fiq>

00000050 <_mainCRTStartup>:

// Initialize Interrupt System
// - Set stack location for each mode
// - Leave in System Mode with Interrupts Disabled
// -----------------------------------------------
        ldr   r0,=_stack                    // Calc stack base
  50:	e59f0228 	ldr	r0, [pc, #552]	; 280 <uart0_send_byte+0x20>
		mrs   r1,CPSR
  54:	e10f1000 	mrs	r1, CPSR
		bic   r1,r1,#0x7F
  58:	e3c1107f 	bic	r1, r1, #127	; 0x7f
		orr   r1,r1,#MODE_UND|IRQ_BIT|FIQ_BIT  // Change to Undefined Instruction mode
  5c:	e38110db 	orr	r1, r1, #219	; 0xdb
        msr   CPSR,r1
  60:	e129f001 	msr	CPSR_fc, r1
        mov   sp,r0                         // Store stack base
  64:	e1a0d000 	mov	sp, r0

        sub   r0,r0,#UND_STACK_SIZE         // Calc stack base
  68:	e2400004 	sub	r0, r0, #4
		mrs   r1,CPSR
  6c:	e10f1000 	mrs	r1, CPSR
		bic   r1,r1,#0x7F
  70:	e3c1107f 	bic	r1, r1, #127	; 0x7f
        orr   r1,r1,#MODE_ABT|IRQ_BIT|FIQ_BIT  // Change to Abort Mode
  74:	e38110d7 	orr	r1, r1, #215	; 0xd7
        msr   CPSR,r1
  78:	e129f001 	msr	CPSR_fc, r1
        mov   sp,r0                         // Store stack base
  7c:	e1a0d000 	mov	sp, r0

        sub   r0,r0,#ABT_STACK_SIZE         // Calc stack base
  80:	e2400004 	sub	r0, r0, #4
		mrs   r1,CPSR
  84:	e10f1000 	mrs	r1, CPSR
		bic   r1,r1,#0x7F
  88:	e3c1107f 	bic	r1, r1, #127	; 0x7f
        orr   r1,r1,#MODE_FIQ|IRQ_BIT|FIQ_BIT  // Change to FIQ Mode
  8c:	e38110d1 	orr	r1, r1, #209	; 0xd1
        msr   CPSR,r1
  90:	e129f001 	msr	CPSR_fc, r1
        mov   sp,r0                         // Store stack base
  94:	e1a0d000 	mov	sp, r0

        sub   r0,r0,#FIQ_STACK_SIZE         // Calc stack base
  98:	e2400004 	sub	r0, r0, #4
		mrs   r1,CPSR
  9c:	e10f1000 	mrs	r1, CPSR
		bic   r1,r1,#0x7F
  a0:	e3c1107f 	bic	r1, r1, #127	; 0x7f
        orr   r1,r1,#MODE_IRQ|IRQ_BIT|FIQ_BIT  // Change to IRQ Mode
  a4:	e38110d2 	orr	r1, r1, #210	; 0xd2
        msr   CPSR,r1
  a8:	e129f001 	msr	CPSR_fc, r1
        mov   sp,r0                         // Store stack base
  ac:	e1a0d000 	mov	sp, r0

        sub   r0,r0,#IRQ_STACK_SIZE         // Calc stack base
  b0:	e2400080 	sub	r0, r0, #128	; 0x80
		mrs   r1,CPSR
  b4:	e10f1000 	mrs	r1, CPSR
		bic   r1,r1,#0x7F
  b8:	e3c1107f 	bic	r1, r1, #127	; 0x7f
        orr   r1,r1,#MODE_SVC|IRQ_BIT|FIQ_BIT  // Change to Supervisor Mode
  bc:	e38110d3 	orr	r1, r1, #211	; 0xd3
        msr   CPSR,r1
  c0:	e129f001 	msr	CPSR_fc, r1
        mov   sp,r0                         // Store stack base
  c4:	e1a0d000 	mov	sp, r0

        sub   r0,r0,#SVC_STACK_SIZE         // Calc stack base
  c8:	e2400004 	sub	r0, r0, #4
		mrs   r1,CPSR
  cc:	e10f1000 	mrs	r1, CPSR
		bic   r1,r1,#0x7F
  d0:	e3c1107f 	bic	r1, r1, #127	; 0x7f
        orr   r1,r1,#MODE_SYS|IRQ_BIT|FIQ_BIT  // Change to System Mode
  d4:	e38110df 	orr	r1, r1, #223	; 0xdf
        msr   CPSR,r1
  d8:	e129f001 	msr	CPSR_fc, r1
        mov   sp,r0                         // Store stack base
  dc:	e1a0d000 	mov	sp, r0
//        strlo r0,[r1],#4                // clear 4 bytes
//        blo   2b                        // loop until done

// Call main program: main(0)
// --------------------------
        mov   r0,#0                     // no arguments (argc = 0)
  e0:	e3a00000 	mov	r0, #0
        mov   r1,r0
  e4:	e1a01000 	mov	r1, r0
        mov   r2,r0
  e8:	e1a02000 	mov	r2, r0
        mov   fp,r0                     // null frame pointer
  ec:	e1a0b000 	mov	fp, r0
        mov   r7,r0                     // null frame pointer for thumb
  f0:	e1a07000 	mov	r7, r0
        ldr   r10,=main
  f4:	e59fa188 	ldr	sl, [pc, #392]	; 284 <uart0_send_byte+0x24>
        mov   lr,pc
  f8:	e1a0e00f 	mov	lr, pc
        bx    r10                       // enter main()
  fc:	e12fff1a 	bx	sl

00000100 <_reset>:
_reset:
reset:
exit:
abort:

        b     .                         // loop until reset
 100:	eafffffe 	b	100 <_reset>

00000104 <dab_handler>:

// Data Fetch Abort Interrupt Handler
// -------------------------------------------------------------------
dab_handler:
		mov   r13, lr
 104:	e1a0d00e 	mov	sp, lr
		mov   r4, #16
 108:	e3a04010 	mov	r4, #16
		mcr   p15, 0, r4, c13, c13, 0
 10c:	ee0d4f1d 	mcr	15, 0, r4, cr13, cr13, {0}
		mov   r4, #'<'
 110:	e3a0403c 	mov	r4, #60	; 0x3c
		bl    uart0_send_byte
 114:	eb000051 	bl	260 <uart0_send_byte>
		mov   r4, #'D'
 118:	e3a04044 	mov	r4, #68	; 0x44
		bl    uart0_send_byte
 11c:	eb00004f 	bl	260 <uart0_send_byte>
		mov   r4, #'A'
 120:	e3a04041 	mov	r4, #65	; 0x41
		bl    uart0_send_byte
 124:	eb00004d 	bl	260 <uart0_send_byte>
		mov   r4, #'B'
 128:	e3a04042 	mov	r4, #66	; 0x42
		bl    uart0_send_byte
 12c:	eb00004b 	bl	260 <uart0_send_byte>
		b     isr_handler
 130:	ea000022 	b	1c0 <isr_handler>

00000134 <iab_handler>:

// Instruction Fetch Abort Interrupt Handler
// -------------------------------------------------------------------
iab_handler:
		mov   r13, lr
 134:	e1a0d00e 	mov	sp, lr
		mov   r4, #32
 138:	e3a04020 	mov	r4, #32
		mcr   p15, 0, r4, c13, c13, 0
 13c:	ee0d4f1d 	mcr	15, 0, r4, cr13, cr13, {0}
		mov   r4, #'<'
 140:	e3a0403c 	mov	r4, #60	; 0x3c
		bl    uart0_send_byte
 144:	eb000045 	bl	260 <uart0_send_byte>
		mov   r4, #'I'
 148:	e3a04049 	mov	r4, #73	; 0x49
		bl    uart0_send_byte
 14c:	eb000043 	bl	260 <uart0_send_byte>
		mov   r4, #'A'
 150:	e3a04041 	mov	r4, #65	; 0x41
		bl    uart0_send_byte
 154:	eb000041 	bl	260 <uart0_send_byte>
		mov   r4, #'B'
 158:	e3a04042 	mov	r4, #66	; 0x42
		bl    uart0_send_byte
 15c:	eb00003f 	bl	260 <uart0_send_byte>
		b     isr_handler
 160:	ea000016 	b	1c0 <isr_handler>

00000164 <swi_handler>:

// Software Interrupt Handler
// -------------------------------------------------------------------
swi_handler:
		mov   r13, lr
 164:	e1a0d00e 	mov	sp, lr
		mov   r4, #64
 168:	e3a04040 	mov	r4, #64	; 0x40
		mcr   p15, 0, r4, c13, c13, 0
 16c:	ee0d4f1d 	mcr	15, 0, r4, cr13, cr13, {0}
		mov   r4, #'<'
 170:	e3a0403c 	mov	r4, #60	; 0x3c
		bl    uart0_send_byte
 174:	eb000039 	bl	260 <uart0_send_byte>
		mov   r4, #'S'
 178:	e3a04053 	mov	r4, #83	; 0x53
		bl    uart0_send_byte
 17c:	eb000037 	bl	260 <uart0_send_byte>
		mov   r4, #'W'
 180:	e3a04057 	mov	r4, #87	; 0x57
		bl    uart0_send_byte
 184:	eb000035 	bl	260 <uart0_send_byte>
		mov   r4, #'I'
 188:	e3a04049 	mov	r4, #73	; 0x49
		bl    uart0_send_byte
 18c:	eb000033 	bl	260 <uart0_send_byte>
		b     isr_handler
 190:	ea00000a 	b	1c0 <isr_handler>

00000194 <und_handler>:

// Undefined Instruction Interrupt Handler
// -------------------------------------------------------------------
und_handler:
		mov   r13, lr
 194:	e1a0d00e 	mov	sp, lr
		mov   r4, #128
 198:	e3a04080 	mov	r4, #128	; 0x80
		mcr   p15, 0, r4, c13, c13, 0
 19c:	ee0d4f1d 	mcr	15, 0, r4, cr13, cr13, {0}
		mov   r4, #'<'
 1a0:	e3a0403c 	mov	r4, #60	; 0x3c
		bl    uart0_send_byte
 1a4:	eb00002d 	bl	260 <uart0_send_byte>
		mov   r4, #'U'
 1a8:	e3a04055 	mov	r4, #85	; 0x55
		bl    uart0_send_byte
 1ac:	eb00002b 	bl	260 <uart0_send_byte>
		mov   r4, #'N'
 1b0:	e3a0404e 	mov	r4, #78	; 0x4e
		bl    uart0_send_byte
 1b4:	eb000029 	bl	260 <uart0_send_byte>
		mov   r4, #'D'
 1b8:	e3a04044 	mov	r4, #68	; 0x44
		bl    uart0_send_byte
 1bc:	eb000027 	bl	260 <uart0_send_byte>

000001c0 <isr_handler>:

// Interrupt Handler
// -------------------------------------------------------------------
isr_handler:
		mov   r4, #'-'
 1c0:	e3a0402d 	mov	r4, #45	; 0x2d
		bl    uart0_send_byte
 1c4:	eb000025 	bl	260 <uart0_send_byte>
		mov   r4, #'I'
 1c8:	e3a04049 	mov	r4, #73	; 0x49
		bl    uart0_send_byte
 1cc:	eb000023 	bl	260 <uart0_send_byte>
		mov   r4, #'N'
 1d0:	e3a0404e 	mov	r4, #78	; 0x4e
		bl    uart0_send_byte
 1d4:	eb000021 	bl	260 <uart0_send_byte>
		mov   r4, #'T'
 1d8:	e3a04054 	mov	r4, #84	; 0x54
		bl    uart0_send_byte
 1dc:	eb00001f 	bl	260 <uart0_send_byte>
		mov   r4, #' '
 1e0:	e3a04020 	mov	r4, #32
		bl    uart0_send_byte
 1e4:	eb00001d 	bl	260 <uart0_send_byte>
		mov   r4, #'@'
 1e8:	e3a04040 	mov	r4, #64	; 0x40
		bl    uart0_send_byte
 1ec:	eb00001b 	bl	260 <uart0_send_byte>

		sub   r7, r13, #4
 1f0:	e24d7004 	sub	r7, sp, #4
		bl    uart0_print_hex
 1f4:	eb00000a 	bl	224 <uart0_print_hex>

		mov   r4, #' '
 1f8:	e3a04020 	mov	r4, #32
		bl    uart0_send_byte
 1fc:	eb000017 	bl	260 <uart0_send_byte>
		mov   r4, #'['		
 200:	e3a0405b 	mov	r4, #91	; 0x5b
		bl    uart0_send_byte
 204:	eb000015 	bl	260 <uart0_send_byte>

		mrc   p15,0,r7, c9, c9
 208:	ee197f19 	mrc	15, 0, r7, cr9, cr9, {0}
		bl    uart0_print_hex
 20c:	eb000004 	bl	224 <uart0_print_hex>

		mov   r4, #']'
 210:	e3a0405d 	mov	r4, #93	; 0x5d
		bl    uart0_send_byte
 214:	eb000011 	bl	260 <uart0_send_byte>
		mov   r4, #'>'
 218:	e3a0403e 	mov	r4, #62	; 0x3e
		bl    uart0_send_byte
 21c:	eb00000f 	bl	260 <uart0_send_byte>
		b .
 220:	eafffffe 	b	220 <isr_handler+0x60>

00000224 <uart0_print_hex>:


// Send 32-bit HEX value via UART0
// -------------------------------------------------------------------
uart0_print_hex:
		mov   r9, lr // save link register
 224:	e1a0900e 	mov	r9, lr
		mov   r8, #32
 228:	e3a08020 	mov	r8, #32

0000022c <uart0_print_hex_loop>:

uart0_print_hex_loop:
		cmp   r8, #0
 22c:	e3580000 	cmp	r8, #0
		moveq pc, r9
 230:	01a0f009 	moveq	pc, r9

		sub   r8, r8, #4
 234:	e2488004 	sub	r8, r8, #4
		mov   r6, r7, lsr r8 // isolate 4-bit value
 238:	e1a06837 	lsr	r6, r7, r8
		and   r6, r6, #0x0F
 23c:	e206600f 	and	r6, r6, #15

		cmp   r6, #9
 240:	e3560009 	cmp	r6, #9
		bgt   adapt_char
 244:	ca000001 	bgt	250 <adapt_char>
		add   r4, r6, #'0'
 248:	e2864030 	add	r4, r6, #48	; 0x30

		b     uart0_print_hex_char
 24c:	ea000001 	b	258 <uart0_print_hex_char>

00000250 <adapt_char>:
adapt_char:
		sub   r6, r6, #10
 250:	e246600a 	sub	r6, r6, #10
		add   r4, r6, #'A'
 254:	e2864041 	add	r4, r6, #65	; 0x41

00000258 <uart0_print_hex_char>:

uart0_print_hex_char:
		bl    uart0_send_byte
 258:	eb000000 	bl	260 <uart0_send_byte>
		b     uart0_print_hex_loop
 25c:	eafffff2 	b	22c <uart0_print_hex_loop>

00000260 <uart0_send_byte>:


// Send one char via UART0
// -------------------------------------------------------------------
uart0_send_byte:
		ldr   r0, =(0xFFFF001C)
 260:	e59f0020 	ldr	r0, [pc, #32]	; 288 <uart0_send_byte+0x28>
		ldr   r0, [r0]
 264:	e5900000 	ldr	r0, [r0]
		and   r0, r0, #0x01
 268:	e2000001 	and	r0, r0, #1
		cmp   r0, #0
 26c:	e3500000 	cmp	r0, #0
		beq   uart0_send_byte
 270:	0afffffa 	beq	260 <uart0_send_byte>
		ldr   r0, =(0xFFFF0018)
 274:	e59f0010 	ldr	r0, [pc, #16]	; 28c <uart0_send_byte+0x2c>
		str   r4, [r0]
 278:	e5804000 	str	r4, [r0]
		mov   pc, lr
 27c:	e1a0f00e 	mov	pc, lr

// Initialize Interrupt System
// - Set stack location for each mode
// - Leave in System Mode with Interrupts Disabled
// -----------------------------------------------
        ldr   r0,=_stack                    // Calc stack base
 280:	00005300 	.word	0x00005300
        mov   r0,#0                     // no arguments (argc = 0)
        mov   r1,r0
        mov   r2,r0
        mov   fp,r0                     // null frame pointer
        mov   r7,r0                     // null frame pointer for thumb
        ldr   r10,=main
 284:	00000a9c 	.word	0x00000a9c


// Send one char via UART0
// -------------------------------------------------------------------
uart0_send_byte:
		ldr   r0, =(0xFFFF001C)
 288:	ffff001c 	.word	0xffff001c
		ldr   r0, [r0]
		and   r0, r0, #0x01
		cmp   r0, #0
		beq   uart0_send_byte
		ldr   r0, =(0xFFFF0018)
 28c:	ffff0018 	.word	0xffff0018

00000290 <timer0_isr>:
// Received UART transmission are echoed.


/* ---- IRQ: Timer ISR ---- */
void __attribute__ ((interrupt("IRQ"))) timer0_isr(void)
{
 290:	e92d100f 	push	{r0, r1, r2, r3, ip}
	static unsigned long gpio = 0;
	static unsigned int count = 0;
	static unsigned int count2 = 0;

	if (count++ > 8) {
 294:	e59f3088 	ldr	r3, [pc, #136]	; 324 <timer0_isr+0x94>
 298:	e5932000 	ldr	r2, [r3]
 29c:	e3520008 	cmp	r2, #8
 2a0:	8a000017 	bhi	304 <timer0_isr+0x74>
 2a4:	e2822001 	add	r2, r2, #1
 2a8:	e3a01001 	mov	r1, #1
 2ac:	e5832000 	str	r2, [r3]
 2b0:	e1a02211 	lsl	r2, r1, r2
		gpio = gpio ^ 0x0001;	
		io_set_gpio0_port(gpio);
		//io_uart0_send_byte('*');
	}
//	if (count == 4 || count == 0) {
	if (count2++ > 4) {
 2b4:	e5931008 	ldr	r1, [r3, #8]
 2b8:	e59f3064 	ldr	r3, [pc, #100]	; 324 <timer0_isr+0x94>
 2bc:	e3510004 	cmp	r1, #4
		count2 = 0;
		// toggle status red led
		gpio = gpio ^ 0x0004;	
 2c0:	85931004 	ldrhi	r1, [r3, #4]
		gpio = gpio ^ 0x0001;	
		io_set_gpio0_port(gpio);
		//io_uart0_send_byte('*');
	}
//	if (count == 4 || count == 0) {
	if (count2++ > 4) {
 2c4:	92811001 	addls	r1, r1, #1
		count2 = 0;
		// toggle status red led
		gpio = gpio ^ 0x0004;	
 2c8:	82211004 	eorhi	r1, r1, #4
// ******************************************************************************
{
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));

		GPIO0_OUT = value;
 2cc:	83e0ca0f 	mvnhi	ip, #61440	; 0xf000
		io_set_gpio0_port(gpio);
		//io_uart0_send_byte('*');
	}
//	if (count == 4 || count == 0) {
	if (count2++ > 4) {
		count2 = 0;
 2d0:	83a00000 	movhi	r0, #0
		// toggle status red led
		gpio = gpio ^ 0x0004;	
 2d4:	85831004 	strhi	r1, [r3, #4]
		gpio = gpio ^ 0x0001;	
		io_set_gpio0_port(gpio);
		//io_uart0_send_byte('*');
	}
//	if (count == 4 || count == 0) {
	if (count2++ > 4) {
 2d8:	95831008 	strls	r1, [r3, #8]
 2dc:	850c1fff 	strhi	r1, [ip, #-4095]	; 0xfff
		count2 = 0;
 2e0:	85830008 	strhi	r0, [r3, #8]
		case CSTAT:      asm volatile ("mrc p15,0,%0, c8, c8" : "=r" (_cp_val) : /* no inputs */  ); break;
		case ADR_FB:     asm volatile ("mrc p15,0,%0, c9, c9" : "=r" (_cp_val) : /* no inputs */  ); break;
		case 10:         asm volatile ("mrc p15,0,%0,c10,c10" : "=r" (_cp_val) : /* no inputs */  ); break;
		case LFSR_POLY:  asm volatile ("mrc p15,0,%0,c11,c11" : "=r" (_cp_val) : /* no inputs */  ); break;
		case LFSR_DATA:  asm volatile ("mrc p15,0,%0,c12,c12" : "=r" (_cp_val) : /* no inputs */  ); break;
		case SYS_IO:     asm volatile ("mrc p15,0,%0,c13,c13" : "=r" (_cp_val) : /* no inputs */  ); break;
 2e4:	ee1d3f1d 	mrc	15, 0, r3, cr13, cr13, {0}
		// toggle status red led
		gpio = gpio ^ 0x0004;	
		io_set_gpio0_port(gpio);
	}
	int shift = 1 << count;
	set_syscpreg((get_syscpreg(SYS_IO) ^ shift), SYS_IO);
 2e8:	e0232002 	eor	r2, r3, r2
//		case CSTAT:      asm volatile ("mcr p15,0,%0, c8, c8,0" : /* no outputs */ : "r" (_cp_val)); break;
//		case ADR_FB:     asm volatile ("mcr p15,0,%0, c9, c9,0" : /* no outputs */ : "r" (_cp_val)); break;
//		case 10:         asm volatile ("mcr p15,0,%0,c10,c10,0" : /* no outputs */ : "r" (_cp_val)); break;
		case LFSR_POLY:  asm volatile ("mcr p15,0,%0,c11,c11,0" : /* no outputs */ : "r" (_cp_val)); break;
		case LFSR_DATA:  asm volatile ("mcr p15,0,%0,c12,c12,0" : /* no outputs */ : "r" (_cp_val)); break;
		case SYS_IO:     asm volatile ("mcr p15,0,%0,c13,c13,0" : /* no outputs */ : "r" (_cp_val)); break;
 2ec:	ee0d2f1d 	mcr	15, 0, r2, cr13, cr13, {0}

	// acknowledge interrupt
	VICVectAddr = 0;
 2f0:	e3e03000 	mvn	r3, #0
 2f4:	e3a02000 	mov	r2, #0
 2f8:	e5032fcf 	str	r2, [r3, #-4047]	; 0xfcf
}
 2fc:	e8bd100f 	pop	{r0, r1, r2, r3, ip}
 300:	e25ef004 	subs	pc, lr, #4
	static unsigned int count2 = 0;

	if (count++ > 8) {
		count = 0;
		// toggle status blue led
		gpio = gpio ^ 0x0001;	
 304:	e5932004 	ldr	r2, [r3, #4]
	static unsigned long gpio = 0;
	static unsigned int count = 0;
	static unsigned int count2 = 0;

	if (count++ > 8) {
		count = 0;
 308:	e3a00000 	mov	r0, #0
		// toggle status blue led
		gpio = gpio ^ 0x0001;	
 30c:	e2222001 	eor	r2, r2, #1
// ******************************************************************************
{
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));

		GPIO0_OUT = value;
 310:	e3e01a0f 	mvn	r1, #61440	; 0xf000
	static unsigned long gpio = 0;
	static unsigned int count = 0;
	static unsigned int count2 = 0;

	if (count++ > 8) {
		count = 0;
 314:	e8830005 	stm	r3, {r0, r2}
 318:	e5012fff 	str	r2, [r1, #-4095]	; 0xfff
 31c:	e3a02001 	mov	r2, #1
 320:	eaffffe3 	b	2b4 <timer0_isr+0x24>
 324:	000012d8 	.word	0x000012d8

00000328 <io_read_gpio0_pin>:
// ******************************************************************************
{
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));

		unsigned long temp = GPIO0_IN & (1<<pin);
 328:	e3e03a0f 	mvn	r3, #61440	; 0xf000
 32c:	e5133ffb 	ldr	r3, [r3, #-4091]	; 0xffb
 330:	e3a02001 	mov	r2, #1
	
//	set_cmsr(_cmsr);
	return temp;
}
 334:	e0030012 	and	r0, r3, r2, lsl r0
 338:	e12fff1e 	bx	lr

0000033c <io_read_gpio0_port>:
// ******************************************************************************
{
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));

		unsigned long temp = GPIO0_IN;
 33c:	e3e03a0f 	mvn	r3, #61440	; 0xf000
 340:	e5130ffb 	ldr	r0, [r3, #-4091]	; 0xffb

//	set_cmsr(_cmsr);
	return temp;
}
 344:	e12fff1e 	bx	lr

00000348 <io_set_gpio0_pin>:
// ******************************************************************************
{
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));

		GPIO0_OUT = GPIO0_OUT | (1<<pin);
 348:	e3e03a0f 	mvn	r3, #61440	; 0xf000
 34c:	e5132fff 	ldr	r2, [r3, #-4095]	; 0xfff
 350:	e3a01001 	mov	r1, #1
 354:	e1820011 	orr	r0, r2, r1, lsl r0
 358:	e5030fff 	str	r0, [r3, #-4095]	; 0xfff
 35c:	e12fff1e 	bx	lr

00000360 <io_clr_gpio0_pin>:
// ******************************************************************************
{
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));

		GPIO0_OUT = GPIO0_OUT & ~(1<<pin);
 360:	e3e03a0f 	mvn	r3, #61440	; 0xf000
 364:	e5132fff 	ldr	r2, [r3, #-4095]	; 0xfff
 368:	e3a01001 	mov	r1, #1
 36c:	e1c20011 	bic	r0, r2, r1, lsl r0
 370:	e5030fff 	str	r0, [r3, #-4095]	; 0xfff
 374:	e12fff1e 	bx	lr

00000378 <io_toggle_gpio0_pin>:
// ******************************************************************************
{
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));

		GPIO0_OUT = GPIO0_OUT ^ (1<<pin);
 378:	e3e03a0f 	mvn	r3, #61440	; 0xf000
 37c:	e5132fff 	ldr	r2, [r3, #-4095]	; 0xfff
 380:	e3a01001 	mov	r1, #1
 384:	e0220011 	eor	r0, r2, r1, lsl r0
 388:	e5030fff 	str	r0, [r3, #-4095]	; 0xfff
 38c:	e12fff1e 	bx	lr

00000390 <io_set_gpio0_port>:
// ******************************************************************************
{
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));

		GPIO0_OUT = value;
 390:	e3e03a0f 	mvn	r3, #61440	; 0xf000
 394:	e5030fff 	str	r0, [r3, #-4095]	; 0xfff
 398:	e12fff1e 	bx	lr

0000039c <io_set_pwm>:
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));

	unsigned long temp = 0;

	// value adjustment
	if(port > 7)
 39c:	e3500007 	cmp	r0, #7
 3a0:	8a00000b 	bhi	3d4 <io_set_pwm+0x38>
		port = 0;

	if(port < 4){
 3a4:	e3500003 	cmp	r0, #3
 3a8:	9a000011 	bls	3f4 <io_set_pwm+0x58>
		temp = temp | (unsigned long)(data << (port*8)); // insert new value
		PWM0_CONF0 = temp;
	}
	else{
		port = port-4;
		temp = PWM0_CONF1; // get working copy
 3ac:	e3e03a0f 	mvn	r3, #61440	; 0xf000
		temp = temp & ~(0xFF << (port*8)); // clear old value
		temp = temp | (unsigned long)(data << (port*8)); // insert new value
		PWM0_CONF0 = temp;
	}
	else{
		port = port-4;
 3b0:	e2400004 	sub	r0, r0, #4
		temp = PWM0_CONF1; // get working copy
 3b4:	e5132f8b 	ldr	r2, [r3, #-3979]	; 0xf8b
		temp = temp & ~(0xFF << (port*8)); // clear old value
 3b8:	e20000ff 	and	r0, r0, #255	; 0xff
 3bc:	e1a00180 	lsl	r0, r0, #3
 3c0:	e3a0c0ff 	mov	ip, #255	; 0xff
 3c4:	e1c2201c 	bic	r2, r2, ip, lsl r0
		temp = temp | (unsigned long)(data << (port*8)); // insert new value
 3c8:	e1821011 	orr	r1, r2, r1, lsl r0
		PWM0_CONF1 = temp;
 3cc:	e5031f8b 	str	r1, [r3, #-3979]	; 0xf8b
 3d0:	e12fff1e 	bx	lr
 3d4:	e3e000ff 	mvn	r0, #255	; 0xff
 3d8:	e3a02000 	mov	r2, #0
	// value adjustment
	if(port > 7)
		port = 0;

	if(port < 4){
		temp = PWM0_CONF0; // get working copy
 3dc:	e3e03a0f 	mvn	r3, #61440	; 0xf000
 3e0:	e513cf8f 	ldr	ip, [r3, #-3983]	; 0xf8f
		temp = temp & ~(0xFF << (port*8)); // clear old value
 3e4:	e000000c 	and	r0, r0, ip
		temp = temp | (unsigned long)(data << (port*8)); // insert new value
 3e8:	e1801211 	orr	r1, r0, r1, lsl r2
		PWM0_CONF0 = temp;
 3ec:	e5031f8f 	str	r1, [r3, #-3983]	; 0xf8f
 3f0:	e12fff1e 	bx	lr
 3f4:	e1a02180 	lsl	r2, r0, #3
 3f8:	e3a000ff 	mov	r0, #255	; 0xff
 3fc:	e1e00210 	mvn	r0, r0, lsl r2
 400:	eafffff5 	b	3dc <io_set_pwm+0x40>

00000404 <io_get_pwm>:
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));

	unsigned long temp = 0;

	// value adjustment
	if(port > 7)
 404:	e3500007 	cmp	r0, #7
 408:	8a00000a 	bhi	438 <io_get_pwm+0x34>
		port = 0;

	if(port < 4)
 40c:	e3500003 	cmp	r0, #3
 410:	91a00180 	lslls	r0, r0, #3
 414:	9a000008 	bls	43c <io_get_pwm+0x38>
		temp = PWM0_CONF0; // get config register
	else{
		port = port-4;
 418:	e2400004 	sub	r0, r0, #4
		temp = PWM0_CONF1; // get config register
 41c:	e3e03a0f 	mvn	r3, #61440	; 0xf000
 420:	e20000ff 	and	r0, r0, #255	; 0xff
 424:	e5133f8b 	ldr	r3, [r3, #-3979]	; 0xf8b
 428:	e1a00180 	lsl	r0, r0, #3
	}

	temp = temp >> (port*8); // only keep designated byte
 42c:	e1a00033 	lsr	r0, r3, r0

//	set_cmsr(_cmsr);
	return (unsigned char)temp;
 430:	e20000ff 	and	r0, r0, #255	; 0xff
}
 434:	e12fff1e 	bx	lr
 438:	e3a00000 	mov	r0, #0
	// value adjustment
	if(port > 7)
		port = 0;

	if(port < 4)
		temp = PWM0_CONF0; // get config register
 43c:	e3e03a0f 	mvn	r3, #61440	; 0xf000
 440:	e5133f8f 	ldr	r3, [r3, #-3983]	; 0xf8f
 444:	eafffff8 	b	42c <io_get_pwm+0x28>

00000448 <io_uart0_read_byte>:
{
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));

	int temp;
	if ((UART0_SREG & (1<<CUART_RXD)) != 0) // byte available?
 448:	e3e03a0f 	mvn	r3, #61440	; 0xf000
 44c:	e5132fe3 	ldr	r2, [r3, #-4067]	; 0xfe3
 450:	e3120002 	tst	r2, #2
		temp = UART0_DATA;
 454:	15130fe7 	ldrne	r0, [r3, #-4071]	; 0xfe7
	else
		temp = -1;
 458:	03e00000 	mvneq	r0, #0

//	set_cmsr(_cmsr);
	return temp;
}
 45c:	e12fff1e 	bx	lr

00000460 <io_uart0_send_byte>:
// ******************************************************************************
{
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));

	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 460:	e3e02a0f 	mvn	r2, #61440	; 0xf000
 464:	e5123fe3 	ldr	r3, [r2, #-4067]	; 0xfe3
 468:	e3130001 	tst	r3, #1
 46c:	e3e03a0f 	mvn	r3, #61440	; 0xf000
 470:	0afffffb 	beq	464 <io_uart0_send_byte+0x4>
	UART0_DATA = (ch & 0x000000FF);
 474:	e20020ff 	and	r2, r0, #255	; 0xff
 478:	e5032fe7 	str	r2, [r3, #-4071]	; 0xfe7

//	set_cmsr(_cmsr);
	return ch;
}
 47c:	e12fff1e 	bx	lr

00000480 <io_spi0_config>:
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));
	// devices update their serial input on a rising edge of sclk,
	// so we need to update the mosi output of the core before
	// -> at the falling edge of sclk = set SPI_TX_NEG
	if(auto_cs == 1)
 480:	e3500001 	cmp	r0, #1
		SPI0_CONF = (1<<SPI_ACS) | (1<<SPI_TX_NEG) | data_size; // auto assert cs
 484:	03811b09 	orreq	r1, r1, #9216	; 0x2400
	else
		SPI0_CONF = (0<<SPI_ACS) | (1<<SPI_TX_NEG) | data_size; // manual assert cs
 488:	13811b01 	orrne	r1, r1, #1024	; 0x400
 48c:	e3e03a0f 	mvn	r3, #61440	; 0xf000
 490:	e5031fcf 	str	r1, [r3, #-4047]	; 0xfcf
 494:	e12fff1e 	bx	lr

00000498 <io_spi0_speed>:
// ******************************************************************************
{
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));

		SPI0_PRSC = clk_divider; // (sys_clk/(spi_clk*2))-1;
 498:	e3e03a0f 	mvn	r3, #61440	; 0xf000
 49c:	e5030fcb 	str	r0, [r3, #-4043]	; 0xfcb
 4a0:	e12fff1e 	bx	lr

000004a4 <io_spi0_trans>:
{
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));

	// spi transmission
	while((SPI0_CONF & (1<<SPI_BUSY)) != 0); // wait for prev tx to finish
 4a4:	e3e02a0f 	mvn	r2, #61440	; 0xf000
 4a8:	e5123fcf 	ldr	r3, [r2, #-4047]	; 0xfcf
 4ac:	e3130c01 	tst	r3, #256	; 0x100
 4b0:	e3e03a0f 	mvn	r3, #61440	; 0xf000
 4b4:	1afffffb 	bne	4a8 <io_spi0_trans+0x4>
	SPI0_DAT0 = data;
 4b8:	e5030fbf 	str	r0, [r3, #-4031]	; 0xfbf
	SPI0_CONF = SPI0_CONF | (1<<SPI_BUSY); // start transmitter
 4bc:	e5132fcf 	ldr	r2, [r3, #-4047]	; 0xfcf
 4c0:	e3822c01 	orr	r2, r2, #256	; 0x100
 4c4:	e5032fcf 	str	r2, [r3, #-4047]	; 0xfcf
	while((SPI0_CONF & (1<<SPI_BUSY)) != 0); // wait for rx to finish
 4c8:	e1a01003 	mov	r1, r3
 4cc:	e5113fcf 	ldr	r3, [r1, #-4047]	; 0xfcf
 4d0:	e3130c01 	tst	r3, #256	; 0x100
 4d4:	e3e02a0f 	mvn	r2, #61440	; 0xf000
 4d8:	1afffffb 	bne	4cc <io_spi0_trans+0x28>
	unsigned long temp = SPI0_DAT0;
 4dc:	e5120fbf 	ldr	r0, [r2, #-4031]	; 0xfbf

//	set_cmsr(_cmsr);
	return temp;
}
 4e0:	e12fff1e 	bx	lr

000004e4 <io_spi0_enable>:
// ******************************************************************************
{
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));

		SPI0_SCSR = SPI0_SCSR | (1<<device);
 4e4:	e3e03a0f 	mvn	r3, #61440	; 0xf000
 4e8:	e5132fc7 	ldr	r2, [r3, #-4039]	; 0xfc7
 4ec:	e3a01001 	mov	r1, #1
 4f0:	e1820011 	orr	r0, r2, r1, lsl r0
 4f4:	e5030fc7 	str	r0, [r3, #-4039]	; 0xfc7
 4f8:	e12fff1e 	bx	lr

000004fc <io_spi0_disable>:
// ******************************************************************************
{
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));

		SPI0_SCSR = SPI0_SCSR & ~(1<<device);
 4fc:	e3e03a0f 	mvn	r3, #61440	; 0xf000
 500:	e5132fc7 	ldr	r2, [r3, #-4039]	; 0xfc7
 504:	e3a01001 	mov	r1, #1
 508:	e1c20011 	bic	r0, r2, r1, lsl r0
 50c:	e5030fc7 	str	r0, [r3, #-4039]	; 0xfc7
 510:	e12fff1e 	bx	lr

00000514 <io_i2c0_speed>:
   void io_i2c0_speed(unsigned long clk_divider)
// ******************************************************************************
{
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));
		I2C0_CTRL = I2C0_CTRL & ~(1<<I2C_EN); // disable i2c core
 514:	e3e03a0f 	mvn	r3, #61440	; 0xf000
 518:	e5132f97 	ldr	r2, [r3, #-3991]	; 0xf97
		I2C0_PRLO = clk_divider;
		I2C0_PRHI = clk_divider >> 8;
 51c:	e1a01420 	lsr	r1, r0, #8
   void io_i2c0_speed(unsigned long clk_divider)
// ******************************************************************************
{
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));
		I2C0_CTRL = I2C0_CTRL & ~(1<<I2C_EN); // disable i2c core
 520:	e3c22080 	bic	r2, r2, #128	; 0x80
 524:	e5032f97 	str	r2, [r3, #-3991]	; 0xf97
		I2C0_PRLO = clk_divider;
 528:	e5030f9f 	str	r0, [r3, #-3999]	; 0xf9f
		I2C0_PRHI = clk_divider >> 8;
 52c:	e5031f9b 	str	r1, [r3, #-3995]	; 0xf9b
		I2C0_CTRL = I2C0_CTRL | (1<<I2C_EN); // enable i2c core
 530:	e5132f97 	ldr	r2, [r3, #-3991]	; 0xf97
 534:	e3822080 	orr	r2, r2, #128	; 0x80
 538:	e5032f97 	str	r2, [r3, #-3991]	; 0xf97
 53c:	e12fff1e 	bx	lr

00000540 <io_i2c0_byte_transfer>:
                             unsigned char id,        // device ID
							 unsigned long data_adr,  // data address
							 unsigned char adr_bytes, // number of adr bytes
							 unsigned char data)      // data byte
// ******************************************************************************
{
 540:	e92d00f0 	push	{r4, r5, r6, r7}
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));

	// transfer slave identification address
	I2C0_DATA = id & 0xFE;                  // device id and write
	I2C0_CMD = (1<<I2C_STA) | (1<<I2C_WR);  // start condition and write cycle
 544:	e3a0c090 	mov	ip, #144	; 0x90
{
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));

	// transfer slave identification address
	I2C0_DATA = id & 0xFE;                  // device id and write
 548:	e3e06a0f 	mvn	r6, #61440	; 0xf000
 54c:	e20140fe 	and	r4, r1, #254	; 0xfe
                             unsigned char id,        // device ID
							 unsigned long data_adr,  // data address
							 unsigned char adr_bytes, // number of adr bytes
							 unsigned char data)      // data byte
// ******************************************************************************
{
 550:	e5dd5013 	ldrb	r5, [sp, #19]
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));

	// transfer slave identification address
	I2C0_DATA = id & 0xFE;                  // device id and write
 554:	e5064f93 	str	r4, [r6, #-3987]	; 0xf93
	I2C0_CMD = (1<<I2C_STA) | (1<<I2C_WR);  // start condition and write cycle
 558:	e506cfaf 	str	ip, [r6, #-4015]	; 0xfaf
	while((I2C0_STAT & (1<<I2C_TIP)) != 0); // wait for transfer to finish
 55c:	e516cfaf 	ldr	ip, [r6, #-4015]	; 0xfaf
 560:	e31c0002 	tst	ip, #2
 564:	e3e04a0f 	mvn	r4, #61440	; 0xf000
 568:	1afffffb 	bne	55c <io_i2c0_byte_transfer+0x1c>
	if((I2C0_STAT & (1<<I2C_RXACK)) != 0){  // ack received?
 56c:	e514cfaf 	ldr	ip, [r4, #-4015]	; 0xfaf
 570:	e31c0080 	tst	ip, #128	; 0x80
 574:	1a00003f 	bne	678 <io_i2c0_byte_transfer+0x138>
//		set_cmsr(_cmsr);
		return -1;
	}

	// transfer data address
	while(adr_bytes != 0){
 578:	e3530000 	cmp	r3, #0
		adr_bytes--;
		if(adr_bytes == 1)
			I2C0_DATA = data_adr >> 8;          // high byte
 57c:	11a07422 	lsrne	r7, r2, #8
		else
			I2C0_DATA = data_adr;               // low byte
		I2C0_CMD = (1<<I2C_WR);                 // write cycle
 580:	13a06010 	movne	r6, #16
//		set_cmsr(_cmsr);
		return -1;
	}

	// transfer data address
	while(adr_bytes != 0){
 584:	0a00000e 	beq	5c4 <io_i2c0_byte_transfer+0x84>
		adr_bytes--;
 588:	e2433001 	sub	r3, r3, #1
 58c:	e20330ff 	and	r3, r3, #255	; 0xff
		if(adr_bytes == 1)
 590:	e3530001 	cmp	r3, #1
			I2C0_DATA = data_adr >> 8;          // high byte
 594:	05047f93 	streq	r7, [r4, #-3987]	; 0xf93
		else
			I2C0_DATA = data_adr;               // low byte
 598:	15042f93 	strne	r2, [r4, #-3987]	; 0xf93
		I2C0_CMD = (1<<I2C_WR);                 // write cycle
 59c:	e5046faf 	str	r6, [r4, #-4015]	; 0xfaf
		while((I2C0_STAT & (1<<I2C_TIP)) != 0); // wait for transfer to finish
 5a0:	e514cfaf 	ldr	ip, [r4, #-4015]	; 0xfaf
 5a4:	e31c0002 	tst	ip, #2
 5a8:	e3e0ca0f 	mvn	ip, #61440	; 0xf000
 5ac:	1afffffb 	bne	5a0 <io_i2c0_byte_transfer+0x60>
		if((I2C0_STAT & (1<<I2C_RXACK)) != 0){  // ack received?
 5b0:	e51ccfaf 	ldr	ip, [ip, #-4015]	; 0xfaf
 5b4:	e31c0080 	tst	ip, #128	; 0x80
 5b8:	1a00001b 	bne	62c <io_i2c0_byte_transfer+0xec>
//		set_cmsr(_cmsr);
		return -1;
	}

	// transfer data address
	while(adr_bytes != 0){
 5bc:	e3530000 	cmp	r3, #0
 5c0:	1afffff0 	bne	588 <io_i2c0_byte_transfer+0x48>
//			set_cmsr(_cmsr);
			return -2;
		}
	}

	if(rw == 'w'){
 5c4:	e3500077 	cmp	r0, #119	; 0x77
 5c8:	0a00001a 	beq	638 <io_i2c0_byte_transfer+0xf8>
//			set_cmsr(_cmsr);
			return 0;
		}
	}

	if(rw == 'r'){
 5cc:	e3500072 	cmp	r0, #114	; 0x72
 5d0:	1a000026 	bne	670 <io_i2c0_byte_transfer+0x130>
		// re-send control byte - this time with read-bit
		I2C0_DATA = id | 0x01;                  // device id and READ
 5d4:	e3e02a0f 	mvn	r2, #61440	; 0xf000
 5d8:	e3811001 	orr	r1, r1, #1
		I2C0_CMD = (1<<I2C_STA) | (1<<I2C_WR);  // start condition and write cycle
 5dc:	e3a03090 	mov	r3, #144	; 0x90
		}
	}

	if(rw == 'r'){
		// re-send control byte - this time with read-bit
		I2C0_DATA = id | 0x01;                  // device id and READ
 5e0:	e5021f93 	str	r1, [r2, #-3987]	; 0xf93
		I2C0_CMD = (1<<I2C_STA) | (1<<I2C_WR);  // start condition and write cycle
 5e4:	e5023faf 	str	r3, [r2, #-4015]	; 0xfaf
		while((I2C0_STAT & (1<<I2C_TIP)) != 0); // wait for transfer to finish
 5e8:	e5123faf 	ldr	r3, [r2, #-4015]	; 0xfaf
 5ec:	e3130002 	tst	r3, #2
 5f0:	e3e03a0f 	mvn	r3, #61440	; 0xf000
 5f4:	1afffffb 	bne	5e8 <io_i2c0_byte_transfer+0xa8>
		if((I2C0_STAT & (1<<I2C_RXACK)) != 0){  // ack received?
 5f8:	e5132faf 	ldr	r2, [r3, #-4015]	; 0xfaf
 5fc:	e3120080 	tst	r2, #128	; 0x80
 600:	1a000018 	bne	668 <io_i2c0_byte_transfer+0x128>
//			set_cmsr(_cmsr);
			return -3;
		}
		// read adressed byte
		I2C0_CMD = (1<<I2C_STO) | (1<<I2C_RD) | (1<<I2C_ACK);
 604:	e3a02068 	mov	r2, #104	; 0x68
 608:	e5032faf 	str	r2, [r3, #-4015]	; 0xfaf
		while((I2C0_STAT & (1<<I2C_TIP)) != 0); // wait for transfer to finish
 60c:	e1a01003 	mov	r1, r3
 610:	e5113faf 	ldr	r3, [r1, #-4015]	; 0xfaf
 614:	e3130002 	tst	r3, #2
 618:	e3e02a0f 	mvn	r2, #61440	; 0xf000
 61c:	1afffffb 	bne	610 <io_i2c0_byte_transfer+0xd0>
		return I2C0_DATA;
 620:	e5120f93 	ldr	r0, [r2, #-3987]	; 0xf93
	}

//	set_cmsr(_cmsr);
	return -4;
}
 624:	e8bd00f0 	pop	{r4, r5, r6, r7}
 628:	e12fff1e 	bx	lr
			I2C0_DATA = data_adr;               // low byte
		I2C0_CMD = (1<<I2C_WR);                 // write cycle
		while((I2C0_STAT & (1<<I2C_TIP)) != 0); // wait for transfer to finish
		if((I2C0_STAT & (1<<I2C_RXACK)) != 0){  // ack received?
//			set_cmsr(_cmsr);
			return -2;
 62c:	e3e00001 	mvn	r0, #1
		return I2C0_DATA;
	}

//	set_cmsr(_cmsr);
	return -4;
}
 630:	e8bd00f0 	pop	{r4, r5, r6, r7}
 634:	e12fff1e 	bx	lr
		}
	}

	if(rw == 'w'){
		// write adressed byte
		I2C0_DATA = data;                       // send data
 638:	e3e02a0f 	mvn	r2, #61440	; 0xf000
		I2C0_CMD = (1<<I2C_STO) | (1<<I2C_WR);  // stop condition and write cycle
 63c:	e3a03050 	mov	r3, #80	; 0x50
		}
	}

	if(rw == 'w'){
		// write adressed byte
		I2C0_DATA = data;                       // send data
 640:	e5025f93 	str	r5, [r2, #-3987]	; 0xf93
		I2C0_CMD = (1<<I2C_STO) | (1<<I2C_WR);  // stop condition and write cycle
 644:	e5023faf 	str	r3, [r2, #-4015]	; 0xfaf
		while((I2C0_STAT & (1<<I2C_TIP)) != 0); // wait for transfer to finish
 648:	e5123faf 	ldr	r3, [r2, #-4015]	; 0xfaf
 64c:	e3130002 	tst	r3, #2
 650:	e3e03a0f 	mvn	r3, #61440	; 0xf000
 654:	1afffffb 	bne	648 <io_i2c0_byte_transfer+0x108>
		if((I2C0_STAT & (1<<I2C_RXACK)) != 0){  // ack received?
 658:	e5133faf 	ldr	r3, [r3, #-4015]	; 0xfaf
 65c:	e2133080 	ands	r3, r3, #128	; 0x80
//			set_cmsr(_cmsr);
			return -3;
		}
		else{
//			set_cmsr(_cmsr);
			return 0;
 660:	01a00003 	moveq	r0, r3
	if(rw == 'w'){
		// write adressed byte
		I2C0_DATA = data;                       // send data
		I2C0_CMD = (1<<I2C_STO) | (1<<I2C_WR);  // stop condition and write cycle
		while((I2C0_STAT & (1<<I2C_TIP)) != 0); // wait for transfer to finish
		if((I2C0_STAT & (1<<I2C_RXACK)) != 0){  // ack received?
 664:	0affffee 	beq	624 <io_i2c0_byte_transfer+0xe4>
//			set_cmsr(_cmsr);
			return -3;
 668:	e3e00002 	mvn	r0, #2
 66c:	eaffffec 	b	624 <io_i2c0_byte_transfer+0xe4>
		while((I2C0_STAT & (1<<I2C_TIP)) != 0); // wait for transfer to finish
		return I2C0_DATA;
	}

//	set_cmsr(_cmsr);
	return -4;
 670:	e3e00003 	mvn	r0, #3
 674:	eaffffea 	b	624 <io_i2c0_byte_transfer+0xe4>
	I2C0_DATA = id & 0xFE;                  // device id and write
	I2C0_CMD = (1<<I2C_STA) | (1<<I2C_WR);  // start condition and write cycle
	while((I2C0_STAT & (1<<I2C_TIP)) != 0); // wait for transfer to finish
	if((I2C0_STAT & (1<<I2C_RXACK)) != 0){  // ack received?
//		set_cmsr(_cmsr);
		return -1;
 678:	e3e00000 	mvn	r0, #0
 67c:	eaffffe8 	b	624 <io_i2c0_byte_transfer+0xe4>

00000680 <get_syscpreg>:
// read system coprocessor register x
   unsigned long get_syscpreg(unsigned char index)
// ******************************************************************************
{
	unsigned long _cp_val;
	switch(index){
 680:	e350000f 	cmp	r0, #15
 684:	979ff100 	ldrls	pc, [pc, r0, lsl #2]
 688:	ea00002f 	b	74c <get_syscpreg+0xcc>
 68c:	000006d4 	.word	0x000006d4
 690:	000006dc 	.word	0x000006dc
 694:	000006e4 	.word	0x000006e4
 698:	000006ec 	.word	0x000006ec
 69c:	000006f4 	.word	0x000006f4
 6a0:	000006fc 	.word	0x000006fc
 6a4:	00000704 	.word	0x00000704
 6a8:	0000070c 	.word	0x0000070c
 6ac:	00000714 	.word	0x00000714
 6b0:	0000071c 	.word	0x0000071c
 6b4:	00000724 	.word	0x00000724
 6b8:	0000072c 	.word	0x0000072c
 6bc:	00000734 	.word	0x00000734
 6c0:	0000073c 	.word	0x0000073c
 6c4:	00000744 	.word	0x00000744
 6c8:	000006cc 	.word	0x000006cc
		case 10:         asm volatile ("mrc p15,0,%0,c10,c10" : "=r" (_cp_val) : /* no inputs */  ); break;
		case LFSR_POLY:  asm volatile ("mrc p15,0,%0,c11,c11" : "=r" (_cp_val) : /* no inputs */  ); break;
		case LFSR_DATA:  asm volatile ("mrc p15,0,%0,c12,c12" : "=r" (_cp_val) : /* no inputs */  ); break;
		case SYS_IO:     asm volatile ("mrc p15,0,%0,c13,c13" : "=r" (_cp_val) : /* no inputs */  ); break;
		case 14:         asm volatile ("mrc p15,0,%0,c14,c14" : "=r" (_cp_val) : /* no inputs */  ); break;
		case 15:         asm volatile ("mrc p15,0,%0,c15,c15" : "=r" (_cp_val) : /* no inputs */  ); break;
 6cc:	ee1f0f1f 	mrc	15, 0, r0, cr15, cr15, {0}
 6d0:	e12fff1e 	bx	lr
   unsigned long get_syscpreg(unsigned char index)
// ******************************************************************************
{
	unsigned long _cp_val;
	switch(index){
		case ID_REG_0:   asm volatile ("mrc p15,0,%0, c0, c0" : "=r" (_cp_val) : /* no inputs */  ); break;
 6d4:	ee100f10 	mrc	15, 0, r0, cr0, cr0, {0}
 6d8:	e12fff1e 	bx	lr
		case ID_REG_1:   asm volatile ("mrc p15,0,%0, c1, c1" : "=r" (_cp_val) : /* no inputs */  ); break;
 6dc:	ee110f11 	mrc	15, 0, r0, cr1, cr1, {0}
 6e0:	e12fff1e 	bx	lr
		case ID_REG_2:   asm volatile ("mrc p15,0,%0, c2, c2" : "=r" (_cp_val) : /* no inputs */  ); break;
 6e4:	ee120f12 	mrc	15, 0, r0, cr2, cr2, {0}
 6e8:	e12fff1e 	bx	lr
		case 3:          asm volatile ("mrc p15,0,%0, c3, c3" : "=r" (_cp_val) : /* no inputs */  ); break;
 6ec:	ee130f13 	mrc	15, 0, r0, cr3, cr3, {0}
 6f0:	e12fff1e 	bx	lr
		case 4:          asm volatile ("mrc p15,0,%0, c4, c4" : "=r" (_cp_val) : /* no inputs */  ); break;
 6f4:	ee140f14 	mrc	15, 0, r0, cr4, cr4, {0}
 6f8:	e12fff1e 	bx	lr
		case 5:          asm volatile ("mrc p15,0,%0, c5, c5" : "=r" (_cp_val) : /* no inputs */  ); break;
 6fc:	ee150f15 	mrc	15, 0, r0, cr5, cr5, {0}
 700:	e12fff1e 	bx	lr
		case SYS_CTRL_0: asm volatile ("mrc p15,0,%0, c6, c6" : "=r" (_cp_val) : /* no inputs */  ); break;
 704:	ee160f16 	mrc	15, 0, r0, cr6, cr6, {0}
 708:	e12fff1e 	bx	lr
		case 7:          asm volatile ("mrc p15,0,%0, c7, c7" : "=r" (_cp_val) : /* no inputs */  ); break;
 70c:	ee170f17 	mrc	15, 0, r0, cr7, cr7, {0}
 710:	e12fff1e 	bx	lr
		case CSTAT:      asm volatile ("mrc p15,0,%0, c8, c8" : "=r" (_cp_val) : /* no inputs */  ); break;
 714:	ee180f18 	mrc	15, 0, r0, cr8, cr8, {0}
 718:	e12fff1e 	bx	lr
		case ADR_FB:     asm volatile ("mrc p15,0,%0, c9, c9" : "=r" (_cp_val) : /* no inputs */  ); break;
 71c:	ee190f19 	mrc	15, 0, r0, cr9, cr9, {0}
 720:	e12fff1e 	bx	lr
		case 10:         asm volatile ("mrc p15,0,%0,c10,c10" : "=r" (_cp_val) : /* no inputs */  ); break;
 724:	ee1a0f1a 	mrc	15, 0, r0, cr10, cr10, {0}
 728:	e12fff1e 	bx	lr
		case LFSR_POLY:  asm volatile ("mrc p15,0,%0,c11,c11" : "=r" (_cp_val) : /* no inputs */  ); break;
 72c:	ee1b0f1b 	mrc	15, 0, r0, cr11, cr11, {0}
 730:	e12fff1e 	bx	lr
		case LFSR_DATA:  asm volatile ("mrc p15,0,%0,c12,c12" : "=r" (_cp_val) : /* no inputs */  ); break;
 734:	ee1c0f1c 	mrc	15, 0, r0, cr12, cr12, {0}
 738:	e12fff1e 	bx	lr
		case SYS_IO:     asm volatile ("mrc p15,0,%0,c13,c13" : "=r" (_cp_val) : /* no inputs */  ); break;
 73c:	ee1d0f1d 	mrc	15, 0, r0, cr13, cr13, {0}
 740:	e12fff1e 	bx	lr
		case 14:         asm volatile ("mrc p15,0,%0,c14,c14" : "=r" (_cp_val) : /* no inputs */  ); break;
 744:	ee1e0f1e 	mrc	15, 0, r0, cr14, cr14, {0}
 748:	e12fff1e 	bx	lr
		case 15:         asm volatile ("mrc p15,0,%0,c15,c15" : "=r" (_cp_val) : /* no inputs */  ); break;
		default:         _cp_val = 0; break;
 74c:	e3a00000 	mov	r0, #0
	}
	return _cp_val;
}
 750:	e12fff1e 	bx	lr

00000754 <set_syscpreg>:
// ******************************************************************************
// write system coprocessor register x
   void set_syscpreg(unsigned long _cp_val, unsigned char index)
// ******************************************************************************
{
	switch(index){
 754:	e2411006 	sub	r1, r1, #6
 758:	e3510007 	cmp	r1, #7
 75c:	979ff101 	ldrls	pc, [pc, r1, lsl #2]
 760:	ea000008 	b	788 <set_syscpreg+0x34>
 764:	0000079c 	.word	0x0000079c
 768:	00000788 	.word	0x00000788
 76c:	00000788 	.word	0x00000788
 770:	00000788 	.word	0x00000788
 774:	00000788 	.word	0x00000788
 778:	00000794 	.word	0x00000794
 77c:	0000078c 	.word	0x0000078c
 780:	00000784 	.word	0x00000784
//		case CSTAT:      asm volatile ("mcr p15,0,%0, c8, c8,0" : /* no outputs */ : "r" (_cp_val)); break;
//		case ADR_FB:     asm volatile ("mcr p15,0,%0, c9, c9,0" : /* no outputs */ : "r" (_cp_val)); break;
//		case 10:         asm volatile ("mcr p15,0,%0,c10,c10,0" : /* no outputs */ : "r" (_cp_val)); break;
		case LFSR_POLY:  asm volatile ("mcr p15,0,%0,c11,c11,0" : /* no outputs */ : "r" (_cp_val)); break;
		case LFSR_DATA:  asm volatile ("mcr p15,0,%0,c12,c12,0" : /* no outputs */ : "r" (_cp_val)); break;
		case SYS_IO:     asm volatile ("mcr p15,0,%0,c13,c13,0" : /* no outputs */ : "r" (_cp_val)); break;
 784:	ee0d0f1d 	mcr	15, 0, r0, cr13, cr13, {0}
 788:	e12fff1e 	bx	lr
//		case 7:          asm volatile ("mcr p15,0,%0, c7, c7,0" : /* no outputs */ : "r" (_cp_val)); break;
//		case CSTAT:      asm volatile ("mcr p15,0,%0, c8, c8,0" : /* no outputs */ : "r" (_cp_val)); break;
//		case ADR_FB:     asm volatile ("mcr p15,0,%0, c9, c9,0" : /* no outputs */ : "r" (_cp_val)); break;
//		case 10:         asm volatile ("mcr p15,0,%0,c10,c10,0" : /* no outputs */ : "r" (_cp_val)); break;
		case LFSR_POLY:  asm volatile ("mcr p15,0,%0,c11,c11,0" : /* no outputs */ : "r" (_cp_val)); break;
		case LFSR_DATA:  asm volatile ("mcr p15,0,%0,c12,c12,0" : /* no outputs */ : "r" (_cp_val)); break;
 78c:	ee0c0f1c 	mcr	15, 0, r0, cr12, cr12, {0}
 790:	e12fff1e 	bx	lr
		case SYS_CTRL_0: asm volatile ("mcr p15,0,%0, c6, c6,0" : /* no outputs */ : "r" (_cp_val)); break;
//		case 7:          asm volatile ("mcr p15,0,%0, c7, c7,0" : /* no outputs */ : "r" (_cp_val)); break;
//		case CSTAT:      asm volatile ("mcr p15,0,%0, c8, c8,0" : /* no outputs */ : "r" (_cp_val)); break;
//		case ADR_FB:     asm volatile ("mcr p15,0,%0, c9, c9,0" : /* no outputs */ : "r" (_cp_val)); break;
//		case 10:         asm volatile ("mcr p15,0,%0,c10,c10,0" : /* no outputs */ : "r" (_cp_val)); break;
		case LFSR_POLY:  asm volatile ("mcr p15,0,%0,c11,c11,0" : /* no outputs */ : "r" (_cp_val)); break;
 794:	ee0b0f1b 	mcr	15, 0, r0, cr11, cr11, {0}
 798:	e12fff1e 	bx	lr
//		case ID_REG_1:   asm volatile ("mcr p15,0,%0, c1, c1,0" : /* no outputs */ : "r" (_cp_val)); break;
//		case ID_REG_2:   asm volatile ("mcr p15,0,%0, c2, c2,0" : /* no outputs */ : "r" (_cp_val)); break;
//		case 3:          asm volatile ("mcr p15,0,%0, c3, c3,0" : /* no outputs */ : "r" (_cp_val)); break;
//		case 4:          asm volatile ("mcr p15,0,%0, c4, c4,0" : /* no outputs */ : "r" (_cp_val)); break;
//		case 5:          asm volatile ("mcr p15,0,%0, c5, c5,0" : /* no outputs */ : "r" (_cp_val)); break;
		case SYS_CTRL_0: asm volatile ("mcr p15,0,%0, c6, c6,0" : /* no outputs */ : "r" (_cp_val)); break;
 79c:	ee060f16 	mcr	15, 0, r0, cr6, cr6, {0}
 7a0:	e12fff1e 	bx	lr

000007a4 <io_enable_xint>:
// read CMSR value
   static inline unsigned long get_cmsr(void)
// ******************************************************************************
{
	unsigned long _cmsr;
	asm volatile (" mrs %0, cpsr" : "=r" (_cmsr) : /* no inputs */  );
 7a4:	e10f3000 	mrs	r3, CPSR
// Enable all external INTs
   void io_enable_xint(void)
// ******************************************************************************
{
	unsigned long _cmsr = get_cmsr();
	_cmsr = _cmsr & ~(1<<CMSR_FIQ) &~(1<<CMSR_IRQ);
 7a8:	e3c330c0 	bic	r3, r3, #192	; 0xc0
// ******************************************************************************
// write CMSR value
   static inline void set_cmsr(unsigned long _cmsr)
// ******************************************************************************
{
	asm volatile (" msr cpsr, %0" : /* no outputs */ : "r" (_cmsr)  );
 7ac:	e129f003 	msr	CPSR_fc, r3
 7b0:	e12fff1e 	bx	lr

000007b4 <io_disable_xint>:
// read CMSR value
   static inline unsigned long get_cmsr(void)
// ******************************************************************************
{
	unsigned long _cmsr;
	asm volatile (" mrs %0, cpsr" : "=r" (_cmsr) : /* no inputs */  );
 7b4:	e10f3000 	mrs	r3, CPSR
// Disable all global IBTs
   void io_disable_xint(void)
// ******************************************************************************
{
	unsigned long _cmsr = get_cmsr();
	_cmsr = _cmsr | (1<<CMSR_FIQ) | (1<<CMSR_IRQ);
 7b8:	e38330c0 	orr	r3, r3, #192	; 0xc0
// ******************************************************************************
// write CMSR value
   static inline void set_cmsr(unsigned long _cmsr)
// ******************************************************************************
{
	asm volatile (" msr cpsr, %0" : /* no outputs */ : "r" (_cmsr)  );
 7bc:	e129f003 	msr	CPSR_fc, r3
 7c0:	e12fff1e 	bx	lr

000007c4 <long_to_hex_string>:
{
	unsigned char temp_char = 0;
	unsigned long temp_data = 0;

	// fit into range
	if(numbers > 8)
 7c4:	e3520008 	cmp	r2, #8
// Convert 4/8/12/16/20/24/28/32 bit hexadecimal value to ASCII string
   void long_to_hex_string(unsigned long data,    // max 32 bit data word
                           unsigned char *buffer, // buffer to store the string
						   unsigned char numbers) // number of places, max 8
// ############################################################################################
{
 7c8:	e52d4004 	push	{r4}		; (str r4, [sp, #-4]!)
	unsigned char temp_char = 0;
	unsigned long temp_data = 0;

	// fit into range
	if(numbers > 8)
		numbers = 8;
 7cc:	83a02008 	movhi	r2, #8
{
	unsigned char temp_char = 0;
	unsigned long temp_data = 0;

	// fit into range
	if(numbers > 8)
 7d0:	8a000001 	bhi	7dc <long_to_hex_string+0x18>
		numbers = 8;
	if(numbers < 1)
		numbers = 1;
 7d4:	e3520000 	cmp	r2, #0
 7d8:	03a02001 	moveq	r2, #1
 7dc:	e1a03002 	mov	r3, r2
 7e0:	e1a04001 	mov	r4, r1

	while(numbers > 0){
		// isolate one 4-bit value
		if(numbers > 1)
 7e4:	e3530001 	cmp	r3, #1
			temp_data = data >> ((numbers-1)*4);
 7e8:	12433001 	subne	r3, r3, #1
 7ec:	11a0c103 	lslne	ip, r3, #2
 7f0:	11a0cc30 	lsrne	ip, r0, ip
		else
			temp_data = data;
 7f4:	01a0c000 	moveq	ip, r0
		temp_data = temp_data & 0x0000000F;
 7f8:	e20cc00f 	and	ip, ip, #15
 7fc:	03a03000 	moveq	r3, #0
		numbers--;
 800:	e20330ff 	and	r3, r3, #255	; 0xff

		// convert 4-bit value temp_data to char temp_char
		if(temp_data < 10)
 804:	e35c0009 	cmp	ip, #9
			temp_char = '0' + temp_data;
 808:	928cc030 	addls	ip, ip, #48	; 0x30
		else
			temp_char = 'A' + temp_data - 10;
 80c:	828cc037 	addhi	ip, ip, #55	; 0x37
	if(numbers > 8)
		numbers = 8;
	if(numbers < 1)
		numbers = 1;

	while(numbers > 0){
 810:	e3530000 	cmp	r3, #0
			temp_char = '0' + temp_data;
		else
			temp_char = 'A' + temp_data - 10;

		// save character
		*buffer++ = temp_char;
 814:	e4c4c001 	strb	ip, [r4], #1
	if(numbers > 8)
		numbers = 8;
	if(numbers < 1)
		numbers = 1;

	while(numbers > 0){
 818:	1afffff1 	bne	7e4 <long_to_hex_string+0x20>
 81c:	e2422001 	sub	r2, r2, #1
 820:	e20220ff 	and	r2, r2, #255	; 0xff

		// save character
		*buffer++ = temp_char;
	}

	*buffer++ = 0; // terminate string
 824:	e0811002 	add	r1, r1, r2
 828:	e5c13001 	strb	r3, [r1, #1]
}
 82c:	e49d4004 	pop	{r4}		; (ldr r4, [sp], #4)
 830:	e12fff1e 	bx	lr

00000834 <get_adc>:
   unsigned int get_adc(int adc_index) // adc 0..7
// ############################################################################################
{
	unsigned long temp;

	if ((adc_index < 0) || (adc_index > 7))
 834:	e3500007 	cmp	r0, #7
 838:	8a000023 	bhi	8cc <get_adc+0x98>
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));
	// devices update their serial input on a rising edge of sclk,
	// so we need to update the mosi output of the core before
	// -> at the falling edge of sclk = set SPI_TX_NEG
	if(auto_cs == 1)
		SPI0_CONF = (1<<SPI_ACS) | (1<<SPI_TX_NEG) | data_size; // auto assert cs
 83c:	e59f3090 	ldr	r3, [pc, #144]	; 8d4 <get_adc+0xa0>
 840:	e3e01a0f 	mvn	r1, #61440	; 0xf000
 844:	e5013fcf 	str	r3, [r1, #-4047]	; 0xfcf
// ******************************************************************************
{
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));

		SPI0_SCSR = SPI0_SCSR | (1<<device);
 848:	e5113fc7 	ldr	r3, [r1, #-4039]	; 0xfc7
 84c:	e3833040 	orr	r3, r3, #64	; 0x40
 850:	e5013fc7 	str	r3, [r1, #-4039]	; 0xfc7

	// config spi
	io_spi0_config(1,16); // auto assert cs, 16 bit transfer
	io_spi0_enable(adc_cs);

	temp = adc_index * 2048;
 854:	e1a00580 	lsl	r0, r0, #11
{
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));

	// spi transmission
	while((SPI0_CONF & (1<<SPI_BUSY)) != 0); // wait for prev tx to finish
 858:	e5113fcf 	ldr	r3, [r1, #-4047]	; 0xfcf
 85c:	e2133c01 	ands	r3, r3, #256	; 0x100
 860:	e3e02a0f 	mvn	r2, #61440	; 0xf000
 864:	1afffffb 	bne	858 <get_adc+0x24>
	SPI0_DAT0 = data;
 868:	e5023fbf 	str	r3, [r2, #-4031]	; 0xfbf
	SPI0_CONF = SPI0_CONF | (1<<SPI_BUSY); // start transmitter
 86c:	e5123fcf 	ldr	r3, [r2, #-4047]	; 0xfcf
 870:	e3833c01 	orr	r3, r3, #256	; 0x100
 874:	e5023fcf 	str	r3, [r2, #-4047]	; 0xfcf
	while((SPI0_CONF & (1<<SPI_BUSY)) != 0); // wait for rx to finish
 878:	e5123fcf 	ldr	r3, [r2, #-4047]	; 0xfcf
 87c:	e3130c01 	tst	r3, #256	; 0x100
 880:	e3e03a0f 	mvn	r3, #61440	; 0xf000
 884:	1afffffb 	bne	878 <get_adc+0x44>
	unsigned long temp = SPI0_DAT0;
 888:	e5132fbf 	ldr	r2, [r3, #-4031]	; 0xfbf
{
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));

	// spi transmission
	while((SPI0_CONF & (1<<SPI_BUSY)) != 0); // wait for prev tx to finish
 88c:	e1a02003 	mov	r2, r3
 890:	e5123fcf 	ldr	r3, [r2, #-4047]	; 0xfcf
 894:	e3130c01 	tst	r3, #256	; 0x100
 898:	e3e03a0f 	mvn	r3, #61440	; 0xf000
 89c:	1afffffb 	bne	890 <get_adc+0x5c>
	SPI0_DAT0 = data;
 8a0:	e5030fbf 	str	r0, [r3, #-4031]	; 0xfbf
	SPI0_CONF = SPI0_CONF | (1<<SPI_BUSY); // start transmitter
 8a4:	e5132fcf 	ldr	r2, [r3, #-4047]	; 0xfcf
 8a8:	e3822c01 	orr	r2, r2, #256	; 0x100
 8ac:	e5032fcf 	str	r2, [r3, #-4047]	; 0xfcf
	while((SPI0_CONF & (1<<SPI_BUSY)) != 0); // wait for rx to finish
 8b0:	e1a01003 	mov	r1, r3
 8b4:	e5113fcf 	ldr	r3, [r1, #-4047]	; 0xfcf
 8b8:	e3130c01 	tst	r3, #256	; 0x100
 8bc:	e3e02a0f 	mvn	r2, #61440	; 0xf000
 8c0:	1afffffb 	bne	8b4 <get_adc+0x80>
	unsigned long temp = SPI0_DAT0;
 8c4:	e5120fbf 	ldr	r0, [r2, #-4031]	; 0xfbf
	io_spi0_trans(0); // dummy read
	return (unsigned int)io_spi0_trans(temp);
 8c8:	e12fff1e 	bx	lr
// ############################################################################################
{
	unsigned long temp;

	if ((adc_index < 0) || (adc_index > 7))
		return 0;
 8cc:	e3a00000 	mov	r0, #0
	io_spi0_enable(adc_cs);

	temp = adc_index * 2048;
	io_spi0_trans(0); // dummy read
	return (unsigned int)io_spi0_trans(temp);
}
 8d0:	e12fff1e 	bx	lr
 8d4:	00002410 	.word	0x00002410

000008d8 <delay>:
// ############################################################################################
// simple delay routine
   void delay(int time) // waits time*10000 clock ticks
// ############################################################################################
{
	time = time*2500*4;
 8d8:	e0603280 	rsb	r3, r0, r0, lsl #5
 8dc:	e0800103 	add	r0, r0, r3, lsl #2
 8e0:	e0800100 	add	r0, r0, r0, lsl #2
 8e4:	e1a03200 	lsl	r3, r0, #4
	while(time > 0){
 8e8:	e3530000 	cmp	r3, #0
 8ec:	d12fff1e 	bxle	lr
		asm volatile ("NOP");
 8f0:	e1a00000 	nop			; (mov r0, r0)
// simple delay routine
   void delay(int time) // waits time*10000 clock ticks
// ############################################################################################
{
	time = time*2500*4;
	while(time > 0){
 8f4:	e2533001 	subs	r3, r3, #1
 8f8:	1afffffc 	bne	8f0 <delay+0x18>
 8fc:	e12fff1e 	bx	lr

00000900 <string_cmpc>:
// ############################################################################################
// String compare, buffered string with immediate const char string
   unsigned char string_cmpc(unsigned char *string1, const char *string2, unsigned char length)
// ############################################################################################
{
	while(length != 0){
 900:	e2523000 	subs	r3, r2, #0
 904:	0a00000b 	beq	938 <string_cmpc+0x38>
		if(*string1++ != (unsigned char)*string2++)
 908:	e5d0c000 	ldrb	ip, [r0]
 90c:	e5d12000 	ldrb	r2, [r1]
 910:	e15c0002 	cmp	ip, r2
 914:	0a000004 	beq	92c <string_cmpc+0x2c>
 918:	ea000008 	b	940 <string_cmpc+0x40>
 91c:	e5f0c001 	ldrb	ip, [r0, #1]!
 920:	e5f12001 	ldrb	r2, [r1, #1]!
 924:	e15c0002 	cmp	ip, r2
 928:	1a000004 	bne	940 <string_cmpc+0x40>
			return(0); // missmatch
		length--;
 92c:	e2433001 	sub	r3, r3, #1
// ############################################################################################
// String compare, buffered string with immediate const char string
   unsigned char string_cmpc(unsigned char *string1, const char *string2, unsigned char length)
// ############################################################################################
{
	while(length != 0){
 930:	e21330ff 	ands	r3, r3, #255	; 0xff
 934:	1afffff8 	bne	91c <string_cmpc+0x1c>
		if(*string1++ != (unsigned char)*string2++)
			return(0); // missmatch
		length--;
	}
	return(1); // match
 938:	e3a00001 	mov	r0, #1
 93c:	e12fff1e 	bx	lr
   unsigned char string_cmpc(unsigned char *string1, const char *string2, unsigned char length)
// ############################################################################################
{
	while(length != 0){
		if(*string1++ != (unsigned char)*string2++)
			return(0); // missmatch
 940:	e3a00000 	mov	r0, #0
		length--;
	}
	return(1); // match
}
 944:	e12fff1e 	bx	lr

00000948 <uart0_printf>:
   const char *uart0_printf(const char *string)
// ############################################################################################
{
	char ch;

	while ((ch = *string)){
 948:	e5d01000 	ldrb	r1, [r0]
 94c:	e3510000 	cmp	r1, #0
 950:	012fff1e 	bxeq	lr
 954:	e280c001 	add	ip, r0, #1
// ******************************************************************************
{
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));

	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 958:	e3e02a0f 	mvn	r2, #61440	; 0xf000
 95c:	e5123fe3 	ldr	r3, [r2, #-4067]	; 0xfe3
 960:	e3130001 	tst	r3, #1
 964:	e3e03a0f 	mvn	r3, #61440	; 0xf000
 968:	0afffffb 	beq	95c <uart0_printf+0x14>
	UART0_DATA = (ch & 0x000000FF);
 96c:	e5031fe7 	str	r1, [r3, #-4071]	; 0xfe7
		if (io_uart0_send_byte(ch)<=0)
			break;
		string++;
 970:	e1a0000c 	mov	r0, ip
   const char *uart0_printf(const char *string)
// ############################################################################################
{
	char ch;

	while ((ch = *string)){
 974:	e4dc1001 	ldrb	r1, [ip], #1
 978:	e3510000 	cmp	r1, #0
 97c:	1afffff6 	bne	95c <uart0_printf+0x14>
		if (io_uart0_send_byte(ch)<=0)
			break;
		string++;
	}
	return string;
}
 980:	e12fff1e 	bx	lr

00000984 <uart0_scanf>:
   void uart0_scanf(unsigned char *buffer, int length, unsigned char en_echo)
// ############################################################################################
{
	int temp = 0;

	while(length > 0){
 984:	e3510000 	cmp	r1, #0

// ############################################################################################
// Read text string via UART 0
   void uart0_scanf(unsigned char *buffer, int length, unsigned char en_echo)
// ############################################################################################
{
 988:	e52d4004 	push	{r4}		; (str r4, [sp, #-4]!)
{
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));

	int temp;
	if ((UART0_SREG & (1<<CUART_RXD)) != 0) // byte available?
 98c:	e3e03a0f 	mvn	r3, #61440	; 0xf000
	int temp = 0;

	while(length > 0){
 990:	da00000d 	ble	9cc <uart0_scanf+0x48>
 994:	e513cfe3 	ldr	ip, [r3, #-4067]	; 0xfe3
 998:	e31c0002 	tst	ip, #2
 99c:	0afffffc 	beq	994 <uart0_scanf+0x10>
		temp = UART0_DATA;
 9a0:	e513cfe7 	ldr	ip, [r3, #-4071]	; 0xfe7
		temp = io_uart0_read_byte();
		if(temp != -1){
 9a4:	e37c0001 	cmn	ip, #1
 9a8:	0afffff9 	beq	994 <uart0_scanf+0x10>
			temp = (unsigned char)(temp & 0x000000FF);
 9ac:	e20cc0ff 	and	ip, ip, #255	; 0xff
			*buffer++ = temp;
			if(en_echo == 1)
 9b0:	e3520001 	cmp	r2, #1

	while(length > 0){
		temp = io_uart0_read_byte();
		if(temp != -1){
			temp = (unsigned char)(temp & 0x000000FF);
			*buffer++ = temp;
 9b4:	e5c0c000 	strb	ip, [r0]
 9b8:	e2800001 	add	r0, r0, #1
			if(en_echo == 1)
 9bc:	0a000004 	beq	9d4 <uart0_scanf+0x50>
 9c0:	e2411001 	sub	r1, r1, #1
   void uart0_scanf(unsigned char *buffer, int length, unsigned char en_echo)
// ############################################################################################
{
	int temp = 0;

	while(length > 0){
 9c4:	e3510000 	cmp	r1, #0
 9c8:	cafffff1 	bgt	994 <uart0_scanf+0x10>
			if(en_echo == 1)
				io_uart0_send_byte(temp); // echo
			length--;
		}
	}
}
 9cc:	e49d4004 	pop	{r4}		; (ldr r4, [sp], #4)
 9d0:	e12fff1e 	bx	lr
// ******************************************************************************
{
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));

	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 9d4:	e5134fe3 	ldr	r4, [r3, #-4067]	; 0xfe3
 9d8:	e3140001 	tst	r4, #1
 9dc:	e3e04a0f 	mvn	r4, #61440	; 0xf000
 9e0:	0afffffb 	beq	9d4 <uart0_scanf+0x50>
	UART0_DATA = (ch & 0x000000FF);
 9e4:	e504cfe7 	str	ip, [r4, #-4071]	; 0xfe7
 9e8:	eafffff4 	b	9c0 <uart0_scanf+0x3c>

000009ec <uart0_print_buffer>:
// Print character buffer via UART 0
   void uart0_print_buffer(unsigned char *buffer, int size)
// ############################################################################################
{
	unsigned char char_buffer = 0;
	while(size > 0){
 9ec:	e3510000 	cmp	r1, #0
 9f0:	d12fff1e 	bxle	lr
 9f4:	e080c001 	add	ip, r0, r1
// ******************************************************************************
{
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));

	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 9f8:	e3e02a0f 	mvn	r2, #61440	; 0xf000
		char_buffer = *buffer++;
 9fc:	e4d01001 	ldrb	r1, [r0], #1
 a00:	e5123fe3 	ldr	r3, [r2, #-4067]	; 0xfe3
 a04:	e3130001 	tst	r3, #1
 a08:	e3e03a0f 	mvn	r3, #61440	; 0xf000
 a0c:	0afffffb 	beq	a00 <uart0_print_buffer+0x14>
// Print character buffer via UART 0
   void uart0_print_buffer(unsigned char *buffer, int size)
// ############################################################################################
{
	unsigned char char_buffer = 0;
	while(size > 0){
 a10:	e150000c 	cmp	r0, ip
	UART0_DATA = (ch & 0x000000FF);
 a14:	e5031fe7 	str	r1, [r3, #-4071]	; 0xfe7
 a18:	1afffff7 	bne	9fc <uart0_print_buffer+0x10>
 a1c:	e12fff1e 	bx	lr
 a20:	6864756d 	.word	0x6864756d
 a24:	70000000 	.word	0x70000000
 a28:	64756d70 	.word	0x64756d70
 a2c:	00000000 	.word	0x00000000
 a30:	0d0a0d0a 	.word	0x0d0a0d0a
 a34:	53544f52 	.word	0x53544f52
 a38:	4d20536f 	.word	0x4d20536f
 a3c:	43204261 	.word	0x43204261
 a40:	73696320 	.word	0x73696320
 a44:	436f6e66 	.word	0x436f6e66
 a48:	69677572 	.word	0x69677572
 a4c:	6174696f 	.word	0x6174696f
 a50:	6e0d0a00 	.word	0x6e0d0a00
 a54:	3e3e3e20 	.word	0x3e3e3e20
 a58:	546f7572 	.word	0x546f7572
 a5c:	6c6f7520 	.word	0x6c6f7520
 a60:	44656d6f 	.word	0x44656d6f
 a64:	2070726f 	.word	0x2070726f
 a68:	6772616d 	.word	0x6772616d
 a6c:	203c3c3c 	.word	0x203c3c3c
 a70:	0d0a0d0a 	.word	0x0d0a0d0a
 a74:	00000000 	.word	0x00000000
 a78:	456e7465 	.word	0x456e7465
 a7c:	7220636f 	.word	0x7220636f
 a80:	6d6d616e 	.word	0x6d6d616e
 a84:	6473203a 	.word	0x6473203a
 a88:	0d0a0000 	.word	0x0d0a0000
 a8c:	20200000 	.word	0x20200000
 a90:	4572726f 	.word	0x4572726f
 a94:	7220210d 	.word	0x7220210d
 a98:	0a000000 	.word	0x0a000000

Disassembly of section .text.startup:

00000a9c <main>:
}


/* ---- Main function ---- */
int main(void)
{
     a9c:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
     aa0:	e59f17e0 	ldr	r1, [pc, #2016]	; 1288 <main+0x7ec>
     aa4:	e24ddf4f 	sub	sp, sp, #316	; 0x13c
   const char *uart0_printf(const char *string)
// ############################################################################################
{
	char ch;

	while ((ch = *string)){
     aa8:	e3a0300d 	mov	r3, #13
// ******************************************************************************
{
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));

	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
     aac:	e3e00a0f 	mvn	r0, #61440	; 0xf000
     ab0:	e5102fe3 	ldr	r2, [r0, #-4067]	; 0xfe3
     ab4:	e3120001 	tst	r2, #1
     ab8:	e3e02a0f 	mvn	r2, #61440	; 0xf000
     abc:	0afffffb 	beq	ab0 <main+0x14>
	UART0_DATA = (ch & 0x000000FF);
     ac0:	e5023fe7 	str	r3, [r2, #-4071]	; 0xfe7
     ac4:	e5f13001 	ldrb	r3, [r1, #1]!
     ac8:	e3530000 	cmp	r3, #0
     acc:	1afffff7 	bne	ab0 <main+0x14>
     ad0:	e59f17b4 	ldr	r1, [pc, #1972]	; 128c <main+0x7f0>
// ******************************************************************************
{
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));

	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
     ad4:	e1a00002 	mov	r0, r2
     ad8:	e3a0303e 	mov	r3, #62	; 0x3e
     adc:	e5102fe3 	ldr	r2, [r0, #-4067]	; 0xfe3
     ae0:	e3120001 	tst	r2, #1
     ae4:	e3e02a0f 	mvn	r2, #61440	; 0xf000
     ae8:	0afffffb 	beq	adc <main+0x40>
	UART0_DATA = (ch & 0x000000FF);
     aec:	e5023fe7 	str	r3, [r2, #-4071]	; 0xfe7
     af0:	e5f13001 	ldrb	r3, [r1, #1]!
     af4:	e3530000 	cmp	r3, #0
     af8:	1afffff7 	bne	adc <main+0x40>
     afc:	e59f378c 	ldr	r3, [pc, #1932]	; 1290 <main+0x7f4>
     b00:	e3a05045 	mov	r5, #69	; 0x45
// ******************************************************************************
{
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));

	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
     b04:	e5121fe3 	ldr	r1, [r2, #-4067]	; 0xfe3
     b08:	e3110001 	tst	r1, #1
     b0c:	e3e01a0f 	mvn	r1, #61440	; 0xf000
     b10:	0afffffb 	beq	b04 <main+0x68>
	UART0_DATA = (ch & 0x000000FF);
     b14:	e5015fe7 	str	r5, [r1, #-4071]	; 0xfe7
     b18:	e5f35001 	ldrb	r5, [r3, #1]!
     b1c:	e3550000 	cmp	r5, #0
     b20:	1afffff7 	bne	b04 <main+0x68>
     b24:	e28d303b 	add	r3, sp, #59	; 0x3b
     b28:	e58d3004 	str	r3, [sp, #4]
{
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));

	int temp;
	if ((UART0_SREG & (1<<CUART_RXD)) != 0) // byte available?
     b2c:	e3e03a0f 	mvn	r3, #61440	; 0xf000
     b30:	e5132fe3 	ldr	r2, [r3, #-4067]	; 0xfe3
     b34:	e3120002 	tst	r2, #2
     b38:	0afffffc 	beq	b30 <main+0x94>
		temp = UART0_DATA;
     b3c:	e5134fe7 	ldr	r4, [r3, #-4071]	; 0xfe7
	uart0_printf("Enter commands :\r\n");

	// echo received char
	while(1){
		ch = io_uart0_read_byte();
		if (ch != -1) {
     b40:	e3740001 	cmn	r4, #1
     b44:	0afffff9 	beq	b30 <main+0x94>
			line[cur++] = ch;
     b48:	e28def4e 	add	lr, sp, #312	; 0x138
     b4c:	e08e3005 	add	r3, lr, r5
     b50:	e5434100 	strb	r4, [r3, #-256]	; 0x100
     b54:	e2855001 	add	r5, r5, #1
// ******************************************************************************
{
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));

	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
     b58:	e3e01a0f 	mvn	r1, #61440	; 0xf000
     b5c:	e5113fe3 	ldr	r3, [r1, #-4067]	; 0xfe3
     b60:	e3130001 	tst	r3, #1
     b64:	e3e02a0f 	mvn	r2, #61440	; 0xf000
     b68:	0afffffb 	beq	b5c <main+0xc0>
	UART0_DATA = (ch & 0x000000FF);
     b6c:	e20430ff 	and	r3, r4, #255	; 0xff
			io_uart0_send_byte(ch);
			if (ch == '\r') {
     b70:	e354000d 	cmp	r4, #13
     b74:	e5023fe7 	str	r3, [r2, #-4071]	; 0xfe7
     b78:	0a000014 	beq	bd0 <main+0x134>
				}
				else
					uart0_printf("Error !\r\n");
			}
			
			if (ch == '2')
     b7c:	e3540032 	cmp	r4, #50	; 0x32
     b80:	0a0000fb 	beq	f74 <main+0x4d8>
				set_syscpreg((get_syscpreg(SYS_IO) ^ 0x02), SYS_IO);
			if (ch == '3')
     b84:	e3540033 	cmp	r4, #51	; 0x33
     b88:	0a0000f5 	beq	f64 <main+0x4c8>
				set_syscpreg((get_syscpreg(SYS_IO) ^ 0x04), SYS_IO);
			if (ch == '4')
     b8c:	e3540034 	cmp	r4, #52	; 0x34
     b90:	0a0000ef 	beq	f54 <main+0x4b8>
				set_syscpreg((get_syscpreg(SYS_IO) ^ 0x08), SYS_IO);
			if (ch == '5')
     b94:	e3540035 	cmp	r4, #53	; 0x35
     b98:	0a0000e9 	beq	f44 <main+0x4a8>
				set_syscpreg((get_syscpreg(SYS_IO) ^ 0x10), SYS_IO);
			if (ch == '6')
     b9c:	e3540036 	cmp	r4, #54	; 0x36
     ba0:	0a0000fb 	beq	f94 <main+0x4f8>
				set_syscpreg((get_syscpreg(SYS_IO) ^ 0x20), SYS_IO);
			if (ch == '7')
     ba4:	e3540037 	cmp	r4, #55	; 0x37
     ba8:	0a0000f5 	beq	f84 <main+0x4e8>
				set_syscpreg((get_syscpreg(SYS_IO) ^ 0x40), SYS_IO);
			if (ch == '8')
     bac:	e3540038 	cmp	r4, #56	; 0x38
     bb0:	0a0000d3 	beq	f04 <main+0x468>
				set_syscpreg((get_syscpreg(SYS_IO) ^ 0x80), SYS_IO);
			if (ch == 'c')
     bb4:	e3540063 	cmp	r4, #99	; 0x63
     bb8:	0a0000ce 	beq	ef8 <main+0x45c>
				set_syscpreg(0x00, SYS_IO);
			if (ch == 'f')
     bbc:	e3540066 	cmp	r4, #102	; 0x66
     bc0:	1a0000c6 	bne	ee0 <main+0x444>
//		case CSTAT:      asm volatile ("mcr p15,0,%0, c8, c8,0" : /* no outputs */ : "r" (_cp_val)); break;
//		case ADR_FB:     asm volatile ("mcr p15,0,%0, c9, c9,0" : /* no outputs */ : "r" (_cp_val)); break;
//		case 10:         asm volatile ("mcr p15,0,%0,c10,c10,0" : /* no outputs */ : "r" (_cp_val)); break;
		case LFSR_POLY:  asm volatile ("mcr p15,0,%0,c11,c11,0" : /* no outputs */ : "r" (_cp_val)); break;
		case LFSR_DATA:  asm volatile ("mcr p15,0,%0,c12,c12,0" : /* no outputs */ : "r" (_cp_val)); break;
		case SYS_IO:     asm volatile ("mcr p15,0,%0,c13,c13,0" : /* no outputs */ : "r" (_cp_val)); break;
     bc4:	e3a030ff 	mov	r3, #255	; 0xff
     bc8:	ee0d3f1d 	mcr	15, 0, r3, cr13, cr13, {0}
     bcc:	eaffffd6 	b	b2c <main+0x90>
		ch = io_uart0_read_byte();
		if (ch != -1) {
			line[cur++] = ch;
			io_uart0_send_byte(ch);
			if (ch == '\r') {
				line[cur] = 0;
     bd0:	e28d0f4e 	add	r0, sp, #312	; 0x138
     bd4:	e0805005 	add	r5, r0, r5
     bd8:	e3a03000 	mov	r3, #0
     bdc:	e5453100 	strb	r3, [r5, #-256]	; 0x100
     be0:	e5dd1038 	ldrb	r1, [sp, #56]	; 0x38
     be4:	e1510003 	cmp	r1, r3
     be8:	128d0038 	addne	r0, sp, #56	; 0x38
     bec:	0a000007 	beq	c10 <main+0x174>
// ******************************************************************************
{
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));

	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
     bf0:	e5123fe3 	ldr	r3, [r2, #-4067]	; 0xfe3
     bf4:	e3130001 	tst	r3, #1
     bf8:	e3e03a0f 	mvn	r3, #61440	; 0xf000
     bfc:	0afffffb 	beq	bf0 <main+0x154>
	UART0_DATA = (ch & 0x000000FF);
     c00:	e5031fe7 	str	r1, [r3, #-4071]	; 0xfe7
     c04:	e5f01001 	ldrb	r1, [r0, #1]!
     c08:	e3510000 	cmp	r1, #0
     c0c:	1afffff7 	bne	bf0 <main+0x154>
     c10:	e59f067c 	ldr	r0, [pc, #1660]	; 1294 <main+0x7f8>
     c14:	e3a0100d 	mov	r1, #13
// ******************************************************************************
{
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));

	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
     c18:	e3e02a0f 	mvn	r2, #61440	; 0xf000
     c1c:	e5123fe3 	ldr	r3, [r2, #-4067]	; 0xfe3
     c20:	e3130001 	tst	r3, #1
     c24:	e3e03a0f 	mvn	r3, #61440	; 0xf000
     c28:	0afffffb 	beq	c1c <main+0x180>
	UART0_DATA = (ch & 0x000000FF);
     c2c:	e5031fe7 	str	r1, [r3, #-4071]	; 0xfe7
     c30:	e5f01001 	ldrb	r1, [r0, #1]!
     c34:	e3510000 	cmp	r1, #0
     c38:	1afffff7 	bne	c1c <main+0x180>
     c3c:	e28d3037 	add	r3, sp, #55	; 0x37
     c40:	e58d3008 	str	r3, [sp, #8]
     c44:	e59f264c 	ldr	r2, [pc, #1612]	; 1298 <main+0x7fc>
// String compare, buffered string with immediate const char string
   unsigned char string_cmpc(unsigned char *string1, const char *string2, unsigned char length)
// ############################################################################################
{
	while(length != 0){
		if(*string1++ != (unsigned char)*string2++)
     c48:	e5f30001 	ldrb	r0, [r3, #1]!
     c4c:	e5f21001 	ldrb	r1, [r2, #1]!
     c50:	e1500001 	cmp	r0, r1
     c54:	1a00005b 	bne	dc8 <main+0x32c>
// ############################################################################################
// String compare, buffered string with immediate const char string
   unsigned char string_cmpc(unsigned char *string1, const char *string2, unsigned char length)
// ############################################################################################
{
	while(length != 0){
     c58:	e59de004 	ldr	lr, [sp, #4]
     c5c:	e153000e 	cmp	r3, lr
     c60:	1afffff8 	bne	c48 <main+0x1ac>
     c64:	e3a08000 	mov	r8, #0
// ******************************************************************************
{
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));

	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
     c68:	e58d400c 	str	r4, [sp, #12]
				if (string_cmpc(line, "dump", 4) != 0) {
					char buf[16];
					unsigned char *ptr = 0x00000000;
					for (int j = 0; j < 16; j++) {
						char str[20];
						str[16] = 0;
     c6c:	e1a06008 	mov	r6, r8
     c70:	e28d5024 	add	r5, sp, #36	; 0x24
     c74:	e3e0ba0f 	mvn	fp, #61440	; 0xf000
						long_to_hex_string(ptr + j * 16, buf, 8);
     c78:	e1a00088 	lsl	r0, r8, #1
     c7c:	e3a02008 	mov	r2, #8
     c80:	e28d1014 	add	r1, sp, #20
				if (string_cmpc(line, "dump", 4) != 0) {
					char buf[16];
					unsigned char *ptr = 0x00000000;
					for (int j = 0; j < 16; j++) {
						char str[20];
						str[16] = 0;
     c84:	e5cd6034 	strb	r6, [sp, #52]	; 0x34
						long_to_hex_string(ptr + j * 16, buf, 8);
     c88:	ebfffecd 	bl	7c4 <long_to_hex_string>
     c8c:	e5dd2014 	ldrb	r2, [sp, #20]
						buf[8] = ':';
     c90:	e3a0003a 	mov	r0, #58	; 0x3a
     c94:	e3520000 	cmp	r2, #0
     c98:	e5cd001c 	strb	r0, [sp, #28]
						buf[9] = 0;
     c9c:	e5cd601d 	strb	r6, [sp, #29]
     ca0:	0a000008 	beq	cc8 <main+0x22c>
     ca4:	e28d1014 	add	r1, sp, #20
     ca8:	e51b3fe3 	ldr	r3, [fp, #-4067]	; 0xfe3
     cac:	e3130001 	tst	r3, #1
     cb0:	e3e03a0f 	mvn	r3, #61440	; 0xf000
     cb4:	0afffffb 	beq	ca8 <main+0x20c>
	UART0_DATA = (ch & 0x000000FF);
     cb8:	e5032fe7 	str	r2, [r3, #-4071]	; 0xfe7
     cbc:	e5f12001 	ldrb	r2, [r1, #1]!
     cc0:	e3520000 	cmp	r2, #0
     cc4:	1afffff7 	bne	ca8 <main+0x20c>
     cc8:	e2484001 	sub	r4, r8, #1
     ccc:	e288a00f 	add	sl, r8, #15
						for (int i = 0; i < 16; i++) {
							char c = *(ptr + j * 8 + i);
							if (c >= 32)
								str[i] = c;
							else
								str[i] = '.';
     cd0:	e3a0902e 	mov	r9, #46	; 0x2e
							long_to_hex_string(c, buf, 2);
							buf[2] = ' ';
     cd4:	e3a07020 	mov	r7, #32
						long_to_hex_string(ptr + j * 16, buf, 8);
						buf[8] = ':';
						buf[9] = 0;
						uart0_printf(buf);
						for (int i = 0; i < 16; i++) {
							char c = *(ptr + j * 8 + i);
     cd8:	e5f40001 	ldrb	r0, [r4, #1]!
							if (c >= 32)
     cdc:	e350001f 	cmp	r0, #31
								str[i] = c;
     ce0:	87c50004 	strbhi	r0, [r5, r4]
							else
								str[i] = '.';
     ce4:	97c59004 	strbls	r9, [r5, r4]
							long_to_hex_string(c, buf, 2);
     ce8:	e28d1014 	add	r1, sp, #20
     cec:	e3a02002 	mov	r2, #2
     cf0:	ebfffeb3 	bl	7c4 <long_to_hex_string>
     cf4:	e5dd2014 	ldrb	r2, [sp, #20]
     cf8:	e3520000 	cmp	r2, #0
							buf[2] = ' ';
     cfc:	e5cd7016 	strb	r7, [sp, #22]
							buf[3] = 0;
     d00:	e5cd6017 	strb	r6, [sp, #23]
     d04:	128d1014 	addne	r1, sp, #20
     d08:	0a000007 	beq	d2c <main+0x290>
// ******************************************************************************
{
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));

	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
     d0c:	e51b3fe3 	ldr	r3, [fp, #-4067]	; 0xfe3
     d10:	e3130001 	tst	r3, #1
     d14:	e3e03a0f 	mvn	r3, #61440	; 0xf000
     d18:	0afffffb 	beq	d0c <main+0x270>
	UART0_DATA = (ch & 0x000000FF);
     d1c:	e5032fe7 	str	r2, [r3, #-4071]	; 0xfe7
     d20:	e5f12001 	ldrb	r2, [r1, #1]!
     d24:	e3520000 	cmp	r2, #0
     d28:	1afffff7 	bne	d0c <main+0x270>
						str[16] = 0;
						long_to_hex_string(ptr + j * 16, buf, 8);
						buf[8] = ':';
						buf[9] = 0;
						uart0_printf(buf);
						for (int i = 0; i < 16; i++) {
     d2c:	e154000a 	cmp	r4, sl
     d30:	1affffe8 	bne	cd8 <main+0x23c>
     d34:	e59f1560 	ldr	r1, [pc, #1376]	; 129c <main+0x800>
     d38:	e3a02020 	mov	r2, #32
// ******************************************************************************
{
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));

	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
     d3c:	e51b3fe3 	ldr	r3, [fp, #-4067]	; 0xfe3
     d40:	e3130001 	tst	r3, #1
     d44:	e3e03a0f 	mvn	r3, #61440	; 0xf000
     d48:	0afffffb 	beq	d3c <main+0x2a0>
	UART0_DATA = (ch & 0x000000FF);
     d4c:	e5032fe7 	str	r2, [r3, #-4071]	; 0xfe7
     d50:	e5f12001 	ldrb	r2, [r1, #1]!
     d54:	e3520000 	cmp	r2, #0
     d58:	1afffff7 	bne	d3c <main+0x2a0>
     d5c:	e5dd2024 	ldrb	r2, [sp, #36]	; 0x24
     d60:	e3520000 	cmp	r2, #0
     d64:	128d1024 	addne	r1, sp, #36	; 0x24
     d68:	0a000007 	beq	d8c <main+0x2f0>
// ******************************************************************************
{
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));

	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
     d6c:	e51b3fe3 	ldr	r3, [fp, #-4067]	; 0xfe3
     d70:	e3130001 	tst	r3, #1
     d74:	e3e03a0f 	mvn	r3, #61440	; 0xf000
     d78:	0afffffb 	beq	d6c <main+0x2d0>
	UART0_DATA = (ch & 0x000000FF);
     d7c:	e5032fe7 	str	r2, [r3, #-4071]	; 0xfe7
     d80:	e5f12001 	ldrb	r2, [r1, #1]!
     d84:	e3520000 	cmp	r2, #0
     d88:	1afffff7 	bne	d6c <main+0x2d0>
     d8c:	e59f1500 	ldr	r1, [pc, #1280]	; 1294 <main+0x7f8>
     d90:	e3a0200d 	mov	r2, #13
// ******************************************************************************
{
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));

	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
     d94:	e51b3fe3 	ldr	r3, [fp, #-4067]	; 0xfe3
     d98:	e3130001 	tst	r3, #1
     d9c:	e3e03a0f 	mvn	r3, #61440	; 0xf000
     da0:	0afffffb 	beq	d94 <main+0x2f8>
	UART0_DATA = (ch & 0x000000FF);
     da4:	e5032fe7 	str	r2, [r3, #-4071]	; 0xfe7
     da8:	e5f12001 	ldrb	r2, [r1, #1]!
     dac:	e3520000 	cmp	r2, #0
     db0:	1afffff7 	bne	d94 <main+0x2f8>
     db4:	e2888008 	add	r8, r8, #8
				uart0_printf("\r\n");
//				if (strcmp(line, "dump") == 0) {
				if (string_cmpc(line, "dump", 4) != 0) {
					char buf[16];
					unsigned char *ptr = 0x00000000;
					for (int j = 0; j < 16; j++) {
     db8:	e3580080 	cmp	r8, #128	; 0x80
     dbc:	e2455008 	sub	r5, r5, #8
     dc0:	1affffac 	bne	c78 <main+0x1dc>
     dc4:	e59d400c 	ldr	r4, [sp, #12]
     dc8:	e59f34d0 	ldr	r3, [pc, #1232]	; 12a0 <main+0x804>
     dcc:	e59db008 	ldr	fp, [sp, #8]
     dd0:	e28d203c 	add	r2, sp, #60	; 0x3c
		if(*string1++ != (unsigned char)*string2++)
     dd4:	e5fb0001 	ldrb	r0, [fp, #1]!
     dd8:	e5f31001 	ldrb	r1, [r3, #1]!
     ddc:	e1500001 	cmp	r0, r1
     de0:	1a00004b 	bne	f14 <main+0x478>
// ############################################################################################
// String compare, buffered string with immediate const char string
   unsigned char string_cmpc(unsigned char *string1, const char *string2, unsigned char length)
// ############################################################################################
{
	while(length != 0){
     de4:	e15b0002 	cmp	fp, r2
     de8:	1afffff9 	bne	dd4 <main+0x338>
					}
				}
				if (string_cmpc(line, "hdump", 5) != 0) {
					char buf[16];
					unsigned long *ptr = 0x10000000;
					for (int j = 0; j < 16; j++) {
     dec:	e59fa4b0 	ldr	sl, [pc, #1200]	; 12a4 <main+0x808>
     df0:	e3a08201 	mov	r8, #268435456	; 0x10000000
						long_to_hex_string(ptr + j * 8, buf, 8);
						buf[8] = ':';
     df4:	e3a0903a 	mov	r9, #58	; 0x3a
						buf[9] = 0;
     df8:	e3a06000 	mov	r6, #0
// ******************************************************************************
{
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));

	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
     dfc:	e3e05a0f 	mvn	r5, #61440	; 0xf000
				}
				if (string_cmpc(line, "hdump", 5) != 0) {
					char buf[16];
					unsigned long *ptr = 0x10000000;
					for (int j = 0; j < 16; j++) {
						long_to_hex_string(ptr + j * 8, buf, 8);
     e00:	e3a02008 	mov	r2, #8
     e04:	e1a00008 	mov	r0, r8
     e08:	e28d1024 	add	r1, sp, #36	; 0x24
     e0c:	ebfffe6c 	bl	7c4 <long_to_hex_string>
     e10:	e5dd2024 	ldrb	r2, [sp, #36]	; 0x24
     e14:	e3520000 	cmp	r2, #0
						buf[8] = ':';
     e18:	e5cd902c 	strb	r9, [sp, #44]	; 0x2c
						buf[9] = 0;
     e1c:	e5cd602d 	strb	r6, [sp, #45]	; 0x2d
     e20:	0a000008 	beq	e48 <main+0x3ac>
     e24:	e28d1024 	add	r1, sp, #36	; 0x24
     e28:	e5153fe3 	ldr	r3, [r5, #-4067]	; 0xfe3
     e2c:	e3130001 	tst	r3, #1
     e30:	e3e03a0f 	mvn	r3, #61440	; 0xf000
     e34:	0afffffb 	beq	e28 <main+0x38c>
	UART0_DATA = (ch & 0x000000FF);
     e38:	e5032fe7 	str	r2, [r3, #-4071]	; 0xfe7
     e3c:	e5f12001 	ldrb	r2, [r1, #1]!
     e40:	e3520000 	cmp	r2, #0
     e44:	1afffff7 	bne	e28 <main+0x38c>
     e48:	e1a0b008 	mov	fp, r8
						uart0_printf(buf);
						for (int i = 0; i < 8; i++) {
							long_to_hex_string(*(ptr + j * 8 + i), buf, 8);
							buf[8] = ' ';
     e4c:	e3a07020 	mov	r7, #32
     e50:	e2888020 	add	r8, r8, #32
						long_to_hex_string(ptr + j * 8, buf, 8);
						buf[8] = ':';
						buf[9] = 0;
						uart0_printf(buf);
						for (int i = 0; i < 8; i++) {
							long_to_hex_string(*(ptr + j * 8 + i), buf, 8);
     e54:	e28d1024 	add	r1, sp, #36	; 0x24
     e58:	e3a02008 	mov	r2, #8
     e5c:	e49b0004 	ldr	r0, [fp], #4
     e60:	ebfffe57 	bl	7c4 <long_to_hex_string>
     e64:	e5dd2024 	ldrb	r2, [sp, #36]	; 0x24
     e68:	e3520000 	cmp	r2, #0
							buf[8] = ' ';
     e6c:	e5cd702c 	strb	r7, [sp, #44]	; 0x2c
							buf[9] = 0;
     e70:	e5cd602d 	strb	r6, [sp, #45]	; 0x2d
     e74:	128d1024 	addne	r1, sp, #36	; 0x24
     e78:	0a000007 	beq	e9c <main+0x400>
// ******************************************************************************
{
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));

	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
     e7c:	e5153fe3 	ldr	r3, [r5, #-4067]	; 0xfe3
     e80:	e3130001 	tst	r3, #1
     e84:	e3e03a0f 	mvn	r3, #61440	; 0xf000
     e88:	0afffffb 	beq	e7c <main+0x3e0>
	UART0_DATA = (ch & 0x000000FF);
     e8c:	e5032fe7 	str	r2, [r3, #-4071]	; 0xfe7
     e90:	e5f12001 	ldrb	r2, [r1, #1]!
     e94:	e3520000 	cmp	r2, #0
     e98:	1afffff7 	bne	e7c <main+0x3e0>
					for (int j = 0; j < 16; j++) {
						long_to_hex_string(ptr + j * 8, buf, 8);
						buf[8] = ':';
						buf[9] = 0;
						uart0_printf(buf);
						for (int i = 0; i < 8; i++) {
     e9c:	e158000b 	cmp	r8, fp
     ea0:	1affffeb 	bne	e54 <main+0x3b8>
     ea4:	e59f13e8 	ldr	r1, [pc, #1000]	; 1294 <main+0x7f8>
     ea8:	e3a0200d 	mov	r2, #13
// ******************************************************************************
{
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));

	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
     eac:	e5153fe3 	ldr	r3, [r5, #-4067]	; 0xfe3
     eb0:	e3130001 	tst	r3, #1
     eb4:	e3e03a0f 	mvn	r3, #61440	; 0xf000
     eb8:	0afffffb 	beq	eac <main+0x410>
	UART0_DATA = (ch & 0x000000FF);
     ebc:	e5032fe7 	str	r2, [r3, #-4071]	; 0xfe7
     ec0:	e5f12001 	ldrb	r2, [r1, #1]!
     ec4:	e3520000 	cmp	r2, #0
     ec8:	1afffff7 	bne	eac <main+0x410>
					}
				}
				if (string_cmpc(line, "hdump", 5) != 0) {
					char buf[16];
					unsigned long *ptr = 0x10000000;
					for (int j = 0; j < 16; j++) {
     ecc:	e158000a 	cmp	r8, sl
     ed0:	1affffca 	bne	e00 <main+0x364>
				set_syscpreg((get_syscpreg(SYS_IO) ^ 0x40), SYS_IO);
			if (ch == '8')
				set_syscpreg((get_syscpreg(SYS_IO) ^ 0x80), SYS_IO);
			if (ch == 'c')
				set_syscpreg(0x00, SYS_IO);
			if (ch == 'f')
     ed4:	e3540066 	cmp	r4, #102	; 0x66
     ed8:	e3a05000 	mov	r5, #0
     edc:	0affff38 	beq	bc4 <main+0x128>
				set_syscpreg(0xFF, SYS_IO);
			if (ch == 'z')
     ee0:	e354007a 	cmp	r4, #122	; 0x7a
     ee4:	1a00002e 	bne	fa4 <main+0x508>
// ******************************************************************************
{
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));

		GPIO0_OUT = value;
     ee8:	e3e03a0f 	mvn	r3, #61440	; 0xf000
     eec:	e3a02000 	mov	r2, #0
     ef0:	e5032fff 	str	r2, [r3, #-4095]	; 0xfff
     ef4:	eaffff0c 	b	b2c <main+0x90>
//		case CSTAT:      asm volatile ("mcr p15,0,%0, c8, c8,0" : /* no outputs */ : "r" (_cp_val)); break;
//		case ADR_FB:     asm volatile ("mcr p15,0,%0, c9, c9,0" : /* no outputs */ : "r" (_cp_val)); break;
//		case 10:         asm volatile ("mcr p15,0,%0,c10,c10,0" : /* no outputs */ : "r" (_cp_val)); break;
		case LFSR_POLY:  asm volatile ("mcr p15,0,%0,c11,c11,0" : /* no outputs */ : "r" (_cp_val)); break;
		case LFSR_DATA:  asm volatile ("mcr p15,0,%0,c12,c12,0" : /* no outputs */ : "r" (_cp_val)); break;
		case SYS_IO:     asm volatile ("mcr p15,0,%0,c13,c13,0" : /* no outputs */ : "r" (_cp_val)); break;
     ef8:	e3a03000 	mov	r3, #0
     efc:	ee0d3f1d 	mcr	15, 0, r3, cr13, cr13, {0}
     f00:	eaffff09 	b	b2c <main+0x90>
		case CSTAT:      asm volatile ("mrc p15,0,%0, c8, c8" : "=r" (_cp_val) : /* no inputs */  ); break;
		case ADR_FB:     asm volatile ("mrc p15,0,%0, c9, c9" : "=r" (_cp_val) : /* no inputs */  ); break;
		case 10:         asm volatile ("mrc p15,0,%0,c10,c10" : "=r" (_cp_val) : /* no inputs */  ); break;
		case LFSR_POLY:  asm volatile ("mrc p15,0,%0,c11,c11" : "=r" (_cp_val) : /* no inputs */  ); break;
		case LFSR_DATA:  asm volatile ("mrc p15,0,%0,c12,c12" : "=r" (_cp_val) : /* no inputs */  ); break;
		case SYS_IO:     asm volatile ("mrc p15,0,%0,c13,c13" : "=r" (_cp_val) : /* no inputs */  ); break;
     f04:	ee1d3f1d 	mrc	15, 0, r3, cr13, cr13, {0}
			if (ch == '6')
				set_syscpreg((get_syscpreg(SYS_IO) ^ 0x20), SYS_IO);
			if (ch == '7')
				set_syscpreg((get_syscpreg(SYS_IO) ^ 0x40), SYS_IO);
			if (ch == '8')
				set_syscpreg((get_syscpreg(SYS_IO) ^ 0x80), SYS_IO);
     f08:	e2233080 	eor	r3, r3, #128	; 0x80
//		case CSTAT:      asm volatile ("mcr p15,0,%0, c8, c8,0" : /* no outputs */ : "r" (_cp_val)); break;
//		case ADR_FB:     asm volatile ("mcr p15,0,%0, c9, c9,0" : /* no outputs */ : "r" (_cp_val)); break;
//		case 10:         asm volatile ("mcr p15,0,%0,c10,c10,0" : /* no outputs */ : "r" (_cp_val)); break;
		case LFSR_POLY:  asm volatile ("mcr p15,0,%0,c11,c11,0" : /* no outputs */ : "r" (_cp_val)); break;
		case LFSR_DATA:  asm volatile ("mcr p15,0,%0,c12,c12,0" : /* no outputs */ : "r" (_cp_val)); break;
		case SYS_IO:     asm volatile ("mcr p15,0,%0,c13,c13,0" : /* no outputs */ : "r" (_cp_val)); break;
     f0c:	ee0d3f1d 	mcr	15, 0, r3, cr13, cr13, {0}
     f10:	eaffff05 	b	b2c <main+0x90>
     f14:	e59f038c 	ldr	r0, [pc, #908]	; 12a8 <main+0x80c>
     f18:	e3a01045 	mov	r1, #69	; 0x45
// ******************************************************************************
{
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));

	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
     f1c:	e3e02a0f 	mvn	r2, #61440	; 0xf000
     f20:	e5123fe3 	ldr	r3, [r2, #-4067]	; 0xfe3
     f24:	e3130001 	tst	r3, #1
     f28:	e3e03a0f 	mvn	r3, #61440	; 0xf000
     f2c:	0afffffb 	beq	f20 <main+0x484>
	UART0_DATA = (ch & 0x000000FF);
     f30:	e5031fe7 	str	r1, [r3, #-4071]	; 0xfe7
     f34:	e5f01001 	ldrb	r1, [r0, #1]!
     f38:	e3510000 	cmp	r1, #0
     f3c:	1afffff7 	bne	f20 <main+0x484>
     f40:	eaffffe3 	b	ed4 <main+0x438>
		case CSTAT:      asm volatile ("mrc p15,0,%0, c8, c8" : "=r" (_cp_val) : /* no inputs */  ); break;
		case ADR_FB:     asm volatile ("mrc p15,0,%0, c9, c9" : "=r" (_cp_val) : /* no inputs */  ); break;
		case 10:         asm volatile ("mrc p15,0,%0,c10,c10" : "=r" (_cp_val) : /* no inputs */  ); break;
		case LFSR_POLY:  asm volatile ("mrc p15,0,%0,c11,c11" : "=r" (_cp_val) : /* no inputs */  ); break;
		case LFSR_DATA:  asm volatile ("mrc p15,0,%0,c12,c12" : "=r" (_cp_val) : /* no inputs */  ); break;
		case SYS_IO:     asm volatile ("mrc p15,0,%0,c13,c13" : "=r" (_cp_val) : /* no inputs */  ); break;
     f44:	ee1d3f1d 	mrc	15, 0, r3, cr13, cr13, {0}
			if (ch == '3')
				set_syscpreg((get_syscpreg(SYS_IO) ^ 0x04), SYS_IO);
			if (ch == '4')
				set_syscpreg((get_syscpreg(SYS_IO) ^ 0x08), SYS_IO);
			if (ch == '5')
				set_syscpreg((get_syscpreg(SYS_IO) ^ 0x10), SYS_IO);
     f48:	e2233010 	eor	r3, r3, #16
//		case CSTAT:      asm volatile ("mcr p15,0,%0, c8, c8,0" : /* no outputs */ : "r" (_cp_val)); break;
//		case ADR_FB:     asm volatile ("mcr p15,0,%0, c9, c9,0" : /* no outputs */ : "r" (_cp_val)); break;
//		case 10:         asm volatile ("mcr p15,0,%0,c10,c10,0" : /* no outputs */ : "r" (_cp_val)); break;
		case LFSR_POLY:  asm volatile ("mcr p15,0,%0,c11,c11,0" : /* no outputs */ : "r" (_cp_val)); break;
		case LFSR_DATA:  asm volatile ("mcr p15,0,%0,c12,c12,0" : /* no outputs */ : "r" (_cp_val)); break;
		case SYS_IO:     asm volatile ("mcr p15,0,%0,c13,c13,0" : /* no outputs */ : "r" (_cp_val)); break;
     f4c:	ee0d3f1d 	mcr	15, 0, r3, cr13, cr13, {0}
     f50:	eafffef5 	b	b2c <main+0x90>
		case CSTAT:      asm volatile ("mrc p15,0,%0, c8, c8" : "=r" (_cp_val) : /* no inputs */  ); break;
		case ADR_FB:     asm volatile ("mrc p15,0,%0, c9, c9" : "=r" (_cp_val) : /* no inputs */  ); break;
		case 10:         asm volatile ("mrc p15,0,%0,c10,c10" : "=r" (_cp_val) : /* no inputs */  ); break;
		case LFSR_POLY:  asm volatile ("mrc p15,0,%0,c11,c11" : "=r" (_cp_val) : /* no inputs */  ); break;
		case LFSR_DATA:  asm volatile ("mrc p15,0,%0,c12,c12" : "=r" (_cp_val) : /* no inputs */  ); break;
		case SYS_IO:     asm volatile ("mrc p15,0,%0,c13,c13" : "=r" (_cp_val) : /* no inputs */  ); break;
     f54:	ee1d3f1d 	mrc	15, 0, r3, cr13, cr13, {0}
			if (ch == '2')
				set_syscpreg((get_syscpreg(SYS_IO) ^ 0x02), SYS_IO);
			if (ch == '3')
				set_syscpreg((get_syscpreg(SYS_IO) ^ 0x04), SYS_IO);
			if (ch == '4')
				set_syscpreg((get_syscpreg(SYS_IO) ^ 0x08), SYS_IO);
     f58:	e2233008 	eor	r3, r3, #8
//		case CSTAT:      asm volatile ("mcr p15,0,%0, c8, c8,0" : /* no outputs */ : "r" (_cp_val)); break;
//		case ADR_FB:     asm volatile ("mcr p15,0,%0, c9, c9,0" : /* no outputs */ : "r" (_cp_val)); break;
//		case 10:         asm volatile ("mcr p15,0,%0,c10,c10,0" : /* no outputs */ : "r" (_cp_val)); break;
		case LFSR_POLY:  asm volatile ("mcr p15,0,%0,c11,c11,0" : /* no outputs */ : "r" (_cp_val)); break;
		case LFSR_DATA:  asm volatile ("mcr p15,0,%0,c12,c12,0" : /* no outputs */ : "r" (_cp_val)); break;
		case SYS_IO:     asm volatile ("mcr p15,0,%0,c13,c13,0" : /* no outputs */ : "r" (_cp_val)); break;
     f5c:	ee0d3f1d 	mcr	15, 0, r3, cr13, cr13, {0}
     f60:	eaffff15 	b	bbc <main+0x120>
		case CSTAT:      asm volatile ("mrc p15,0,%0, c8, c8" : "=r" (_cp_val) : /* no inputs */  ); break;
		case ADR_FB:     asm volatile ("mrc p15,0,%0, c9, c9" : "=r" (_cp_val) : /* no inputs */  ); break;
		case 10:         asm volatile ("mrc p15,0,%0,c10,c10" : "=r" (_cp_val) : /* no inputs */  ); break;
		case LFSR_POLY:  asm volatile ("mrc p15,0,%0,c11,c11" : "=r" (_cp_val) : /* no inputs */  ); break;
		case LFSR_DATA:  asm volatile ("mrc p15,0,%0,c12,c12" : "=r" (_cp_val) : /* no inputs */  ); break;
		case SYS_IO:     asm volatile ("mrc p15,0,%0,c13,c13" : "=r" (_cp_val) : /* no inputs */  ); break;
     f64:	ee1d3f1d 	mrc	15, 0, r3, cr13, cr13, {0}
			}
			
			if (ch == '2')
				set_syscpreg((get_syscpreg(SYS_IO) ^ 0x02), SYS_IO);
			if (ch == '3')
				set_syscpreg((get_syscpreg(SYS_IO) ^ 0x04), SYS_IO);
     f68:	e2233004 	eor	r3, r3, #4
//		case CSTAT:      asm volatile ("mcr p15,0,%0, c8, c8,0" : /* no outputs */ : "r" (_cp_val)); break;
//		case ADR_FB:     asm volatile ("mcr p15,0,%0, c9, c9,0" : /* no outputs */ : "r" (_cp_val)); break;
//		case 10:         asm volatile ("mcr p15,0,%0,c10,c10,0" : /* no outputs */ : "r" (_cp_val)); break;
		case LFSR_POLY:  asm volatile ("mcr p15,0,%0,c11,c11,0" : /* no outputs */ : "r" (_cp_val)); break;
		case LFSR_DATA:  asm volatile ("mcr p15,0,%0,c12,c12,0" : /* no outputs */ : "r" (_cp_val)); break;
		case SYS_IO:     asm volatile ("mcr p15,0,%0,c13,c13,0" : /* no outputs */ : "r" (_cp_val)); break;
     f6c:	ee0d3f1d 	mcr	15, 0, r3, cr13, cr13, {0}
     f70:	eaffff11 	b	bbc <main+0x120>
		case CSTAT:      asm volatile ("mrc p15,0,%0, c8, c8" : "=r" (_cp_val) : /* no inputs */  ); break;
		case ADR_FB:     asm volatile ("mrc p15,0,%0, c9, c9" : "=r" (_cp_val) : /* no inputs */  ); break;
		case 10:         asm volatile ("mrc p15,0,%0,c10,c10" : "=r" (_cp_val) : /* no inputs */  ); break;
		case LFSR_POLY:  asm volatile ("mrc p15,0,%0,c11,c11" : "=r" (_cp_val) : /* no inputs */  ); break;
		case LFSR_DATA:  asm volatile ("mrc p15,0,%0,c12,c12" : "=r" (_cp_val) : /* no inputs */  ); break;
		case SYS_IO:     asm volatile ("mrc p15,0,%0,c13,c13" : "=r" (_cp_val) : /* no inputs */  ); break;
     f74:	ee1d3f1d 	mrc	15, 0, r3, cr13, cr13, {0}
				else
					uart0_printf("Error !\r\n");
			}
			
			if (ch == '2')
				set_syscpreg((get_syscpreg(SYS_IO) ^ 0x02), SYS_IO);
     f78:	e2233002 	eor	r3, r3, #2
//		case CSTAT:      asm volatile ("mcr p15,0,%0, c8, c8,0" : /* no outputs */ : "r" (_cp_val)); break;
//		case ADR_FB:     asm volatile ("mcr p15,0,%0, c9, c9,0" : /* no outputs */ : "r" (_cp_val)); break;
//		case 10:         asm volatile ("mcr p15,0,%0,c10,c10,0" : /* no outputs */ : "r" (_cp_val)); break;
		case LFSR_POLY:  asm volatile ("mcr p15,0,%0,c11,c11,0" : /* no outputs */ : "r" (_cp_val)); break;
		case LFSR_DATA:  asm volatile ("mcr p15,0,%0,c12,c12,0" : /* no outputs */ : "r" (_cp_val)); break;
		case SYS_IO:     asm volatile ("mcr p15,0,%0,c13,c13,0" : /* no outputs */ : "r" (_cp_val)); break;
     f7c:	ee0d3f1d 	mcr	15, 0, r3, cr13, cr13, {0}
     f80:	eaffff0d 	b	bbc <main+0x120>
		case CSTAT:      asm volatile ("mrc p15,0,%0, c8, c8" : "=r" (_cp_val) : /* no inputs */  ); break;
		case ADR_FB:     asm volatile ("mrc p15,0,%0, c9, c9" : "=r" (_cp_val) : /* no inputs */  ); break;
		case 10:         asm volatile ("mrc p15,0,%0,c10,c10" : "=r" (_cp_val) : /* no inputs */  ); break;
		case LFSR_POLY:  asm volatile ("mrc p15,0,%0,c11,c11" : "=r" (_cp_val) : /* no inputs */  ); break;
		case LFSR_DATA:  asm volatile ("mrc p15,0,%0,c12,c12" : "=r" (_cp_val) : /* no inputs */  ); break;
		case SYS_IO:     asm volatile ("mrc p15,0,%0,c13,c13" : "=r" (_cp_val) : /* no inputs */  ); break;
     f84:	ee1d3f1d 	mrc	15, 0, r3, cr13, cr13, {0}
			if (ch == '5')
				set_syscpreg((get_syscpreg(SYS_IO) ^ 0x10), SYS_IO);
			if (ch == '6')
				set_syscpreg((get_syscpreg(SYS_IO) ^ 0x20), SYS_IO);
			if (ch == '7')
				set_syscpreg((get_syscpreg(SYS_IO) ^ 0x40), SYS_IO);
     f88:	e2233040 	eor	r3, r3, #64	; 0x40
//		case CSTAT:      asm volatile ("mcr p15,0,%0, c8, c8,0" : /* no outputs */ : "r" (_cp_val)); break;
//		case ADR_FB:     asm volatile ("mcr p15,0,%0, c9, c9,0" : /* no outputs */ : "r" (_cp_val)); break;
//		case 10:         asm volatile ("mcr p15,0,%0,c10,c10,0" : /* no outputs */ : "r" (_cp_val)); break;
		case LFSR_POLY:  asm volatile ("mcr p15,0,%0,c11,c11,0" : /* no outputs */ : "r" (_cp_val)); break;
		case LFSR_DATA:  asm volatile ("mcr p15,0,%0,c12,c12,0" : /* no outputs */ : "r" (_cp_val)); break;
		case SYS_IO:     asm volatile ("mcr p15,0,%0,c13,c13,0" : /* no outputs */ : "r" (_cp_val)); break;
     f8c:	ee0d3f1d 	mcr	15, 0, r3, cr13, cr13, {0}
     f90:	eafffee5 	b	b2c <main+0x90>
		case CSTAT:      asm volatile ("mrc p15,0,%0, c8, c8" : "=r" (_cp_val) : /* no inputs */  ); break;
		case ADR_FB:     asm volatile ("mrc p15,0,%0, c9, c9" : "=r" (_cp_val) : /* no inputs */  ); break;
		case 10:         asm volatile ("mrc p15,0,%0,c10,c10" : "=r" (_cp_val) : /* no inputs */  ); break;
		case LFSR_POLY:  asm volatile ("mrc p15,0,%0,c11,c11" : "=r" (_cp_val) : /* no inputs */  ); break;
		case LFSR_DATA:  asm volatile ("mrc p15,0,%0,c12,c12" : "=r" (_cp_val) : /* no inputs */  ); break;
		case SYS_IO:     asm volatile ("mrc p15,0,%0,c13,c13" : "=r" (_cp_val) : /* no inputs */  ); break;
     f94:	ee1d3f1d 	mrc	15, 0, r3, cr13, cr13, {0}
			if (ch == '4')
				set_syscpreg((get_syscpreg(SYS_IO) ^ 0x08), SYS_IO);
			if (ch == '5')
				set_syscpreg((get_syscpreg(SYS_IO) ^ 0x10), SYS_IO);
			if (ch == '6')
				set_syscpreg((get_syscpreg(SYS_IO) ^ 0x20), SYS_IO);
     f98:	e2233020 	eor	r3, r3, #32
//		case CSTAT:      asm volatile ("mcr p15,0,%0, c8, c8,0" : /* no outputs */ : "r" (_cp_val)); break;
//		case ADR_FB:     asm volatile ("mcr p15,0,%0, c9, c9,0" : /* no outputs */ : "r" (_cp_val)); break;
//		case 10:         asm volatile ("mcr p15,0,%0,c10,c10,0" : /* no outputs */ : "r" (_cp_val)); break;
		case LFSR_POLY:  asm volatile ("mcr p15,0,%0,c11,c11,0" : /* no outputs */ : "r" (_cp_val)); break;
		case LFSR_DATA:  asm volatile ("mcr p15,0,%0,c12,c12,0" : /* no outputs */ : "r" (_cp_val)); break;
		case SYS_IO:     asm volatile ("mcr p15,0,%0,c13,c13,0" : /* no outputs */ : "r" (_cp_val)); break;
     f9c:	ee0d3f1d 	mcr	15, 0, r3, cr13, cr13, {0}
     fa0:	eafffee1 	b	b2c <main+0x90>
				set_syscpreg(0x00, SYS_IO);
			if (ch == 'f')
				set_syscpreg(0xFF, SYS_IO);
			if (ch == 'z')
				io_set_gpio0_port(0x0000000);
			if (ch == 'x')
     fa4:	e3540078 	cmp	r4, #120	; 0x78
// ******************************************************************************
{
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));

		GPIO0_OUT = value;
     fa8:	03e03a0f 	mvneq	r3, #61440	; 0xf000
     fac:	03e0220f 	mvneq	r2, #-268435456	; 0xf0000000
     fb0:	05032fff 	streq	r2, [r3, #-4095]	; 0xfff
     fb4:	0afffedc 	beq	b2c <main+0x90>
				io_set_gpio0_port(0xFFFFFFF);
			if (ch == 'a')
     fb8:	e3540061 	cmp	r4, #97	; 0x61
     fbc:	1a000003 	bne	fd0 <main+0x534>
		case CSTAT:      asm volatile ("mrc p15,0,%0, c8, c8" : "=r" (_cp_val) : /* no inputs */  ); break;
		case ADR_FB:     asm volatile ("mrc p15,0,%0, c9, c9" : "=r" (_cp_val) : /* no inputs */  ); break;
		case 10:         asm volatile ("mrc p15,0,%0,c10,c10" : "=r" (_cp_val) : /* no inputs */  ); break;
		case LFSR_POLY:  asm volatile ("mrc p15,0,%0,c11,c11" : "=r" (_cp_val) : /* no inputs */  ); break;
		case LFSR_DATA:  asm volatile ("mrc p15,0,%0,c12,c12" : "=r" (_cp_val) : /* no inputs */  ); break;
		case SYS_IO:     asm volatile ("mrc p15,0,%0,c13,c13" : "=r" (_cp_val) : /* no inputs */  ); break;
     fc0:	ee1d3f1d 	mrc	15, 0, r3, cr13, cr13, {0}
				set_syscpreg((get_syscpreg(SYS_IO) ^ 0x100), SYS_IO);
     fc4:	e2233c01 	eor	r3, r3, #256	; 0x100
//		case CSTAT:      asm volatile ("mcr p15,0,%0, c8, c8,0" : /* no outputs */ : "r" (_cp_val)); break;
//		case ADR_FB:     asm volatile ("mcr p15,0,%0, c9, c9,0" : /* no outputs */ : "r" (_cp_val)); break;
//		case 10:         asm volatile ("mcr p15,0,%0,c10,c10,0" : /* no outputs */ : "r" (_cp_val)); break;
		case LFSR_POLY:  asm volatile ("mcr p15,0,%0,c11,c11,0" : /* no outputs */ : "r" (_cp_val)); break;
		case LFSR_DATA:  asm volatile ("mcr p15,0,%0,c12,c12,0" : /* no outputs */ : "r" (_cp_val)); break;
		case SYS_IO:     asm volatile ("mcr p15,0,%0,c13,c13,0" : /* no outputs */ : "r" (_cp_val)); break;
     fc8:	ee0d3f1d 	mcr	15, 0, r3, cr13, cr13, {0}
     fcc:	eafffed6 	b	b2c <main+0x90>
			if (ch == 'q') {
     fd0:	e3540071 	cmp	r4, #113	; 0x71
     fd4:	1a000009 	bne	1000 <main+0x564>
     fd8:	e59f32cc 	ldr	r3, [pc, #716]	; 12ac <main+0x810>
     fdc:	e3a01201 	mov	r1, #268435456	; 0x10000000
     fe0:	ea000000 	b	fe8 <main+0x54c>
				char buf[16];
				unsigned long *ptr = 0x10000000;
				unsigned long val = 0xAA550000;
				for (int j = 0; j < 32; j++) {
					*(ptr++) = val++;
     fe4:	e1a03002 	mov	r3, r2
				set_syscpreg((get_syscpreg(SYS_IO) ^ 0x100), SYS_IO);
			if (ch == 'q') {
				char buf[16];
				unsigned long *ptr = 0x10000000;
				unsigned long val = 0xAA550000;
				for (int j = 0; j < 32; j++) {
     fe8:	e59fe2c0 	ldr	lr, [pc, #704]	; 12b0 <main+0x814>
					*(ptr++) = val++;
     fec:	e2832001 	add	r2, r3, #1
				set_syscpreg((get_syscpreg(SYS_IO) ^ 0x100), SYS_IO);
			if (ch == 'q') {
				char buf[16];
				unsigned long *ptr = 0x10000000;
				unsigned long val = 0xAA550000;
				for (int j = 0; j < 32; j++) {
     ff0:	e152000e 	cmp	r2, lr
					*(ptr++) = val++;
     ff4:	e4813004 	str	r3, [r1], #4
				set_syscpreg((get_syscpreg(SYS_IO) ^ 0x100), SYS_IO);
			if (ch == 'q') {
				char buf[16];
				unsigned long *ptr = 0x10000000;
				unsigned long val = 0xAA550000;
				for (int j = 0; j < 32; j++) {
     ff8:	1afffff9 	bne	fe4 <main+0x548>
     ffc:	eafffeca 	b	b2c <main+0x90>
					*(ptr++) = val++;
				}
			}
			if (ch == 'w') {
    1000:	e3540077 	cmp	r4, #119	; 0x77
    1004:	1a000007 	bne	1028 <main+0x58c>
    1008:	e59f22a4 	ldr	r2, [pc, #676]	; 12b4 <main+0x818>
    100c:	e59f32a4 	ldr	r3, [pc, #676]	; 12b8 <main+0x81c>
				char buf[16];
				unsigned long *ptr = 0x10000080;
				unsigned long val = 0x55AA0000;
				for (int j = 0; j < 32; j++) {
    1010:	e59f12a4 	ldr	r1, [pc, #676]	; 12bc <main+0x820>
					*(ptr++) = val++;
    1014:	e4832004 	str	r2, [r3], #4
			}
			if (ch == 'w') {
				char buf[16];
				unsigned long *ptr = 0x10000080;
				unsigned long val = 0x55AA0000;
				for (int j = 0; j < 32; j++) {
    1018:	e1530001 	cmp	r3, r1
					*(ptr++) = val++;
    101c:	e2822001 	add	r2, r2, #1
			}
			if (ch == 'w') {
				char buf[16];
				unsigned long *ptr = 0x10000080;
				unsigned long val = 0x55AA0000;
				for (int j = 0; j < 32; j++) {
    1020:	1afffffb 	bne	1014 <main+0x578>
    1024:	eafffec0 	b	b2c <main+0x90>
					*(ptr++) = val++;
				}
			}
			if (ch == 'e') {
    1028:	e3540065 	cmp	r4, #101	; 0x65
    102c:	1a000007 	bne	1050 <main+0x5b4>
    1030:	e59f2288 	ldr	r2, [pc, #648]	; 12c0 <main+0x824>
    1034:	e59f3280 	ldr	r3, [pc, #640]	; 12bc <main+0x820>
				char buf[16];
				unsigned long *ptr = 0x10000100;
				unsigned long val = 0x5A5A0000;
				for (int j = 0; j < 32; j++) {
    1038:	e59f1284 	ldr	r1, [pc, #644]	; 12c4 <main+0x828>
					*(ptr++) = val++;
    103c:	e4832004 	str	r2, [r3], #4
			}
			if (ch == 'e') {
				char buf[16];
				unsigned long *ptr = 0x10000100;
				unsigned long val = 0x5A5A0000;
				for (int j = 0; j < 32; j++) {
    1040:	e1530001 	cmp	r3, r1
					*(ptr++) = val++;
    1044:	e2822001 	add	r2, r2, #1
			}
			if (ch == 'e') {
				char buf[16];
				unsigned long *ptr = 0x10000100;
				unsigned long val = 0x5A5A0000;
				for (int j = 0; j < 32; j++) {
    1048:	1afffffb 	bne	103c <main+0x5a0>
    104c:	eafffeb6 	b	b2c <main+0x90>
					*(ptr++) = val++;
				}
			}
			if (ch == 'r') {
    1050:	e3540072 	cmp	r4, #114	; 0x72
    1054:	1a00003a 	bne	1144 <main+0x6a8>
				char buf[16];
				unsigned long *ptr = 0x10000000;
				for (int j = 0; j < 16; j++) {
    1058:	e59fa244 	ldr	sl, [pc, #580]	; 12a4 <main+0x808>
				unsigned long val = 0x5A5A0000;
				for (int j = 0; j < 32; j++) {
					*(ptr++) = val++;
				}
			}
			if (ch == 'r') {
    105c:	e3a0b201 	mov	fp, #268435456	; 0x10000000
				char buf[16];
				unsigned long *ptr = 0x10000000;
				for (int j = 0; j < 16; j++) {
					long_to_hex_string(ptr, buf, 8);
					buf[8] = ':';
    1060:	e3a0903a 	mov	r9, #58	; 0x3a
					buf[9] = 0;
    1064:	e3a06000 	mov	r6, #0
// ******************************************************************************
{
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));

	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
    1068:	e3e04a0f 	mvn	r4, #61440	; 0xf000
			}
			if (ch == 'r') {
				char buf[16];
				unsigned long *ptr = 0x10000000;
				for (int j = 0; j < 16; j++) {
					long_to_hex_string(ptr, buf, 8);
    106c:	e28d1024 	add	r1, sp, #36	; 0x24
    1070:	e3a02008 	mov	r2, #8
    1074:	e1a0000b 	mov	r0, fp
    1078:	ebfffdd1 	bl	7c4 <long_to_hex_string>
    107c:	e5dd2024 	ldrb	r2, [sp, #36]	; 0x24
    1080:	e3520000 	cmp	r2, #0
					buf[8] = ':';
    1084:	e5cd902c 	strb	r9, [sp, #44]	; 0x2c
					buf[9] = 0;
    1088:	e5cd602d 	strb	r6, [sp, #45]	; 0x2d
    108c:	128d1024 	addne	r1, sp, #36	; 0x24
    1090:	0a000007 	beq	10b4 <main+0x618>
    1094:	e5143fe3 	ldr	r3, [r4, #-4067]	; 0xfe3
    1098:	e3130001 	tst	r3, #1
    109c:	e3e03a0f 	mvn	r3, #61440	; 0xf000
    10a0:	0afffffb 	beq	1094 <main+0x5f8>
	UART0_DATA = (ch & 0x000000FF);
    10a4:	e5032fe7 	str	r2, [r3, #-4071]	; 0xfe7
    10a8:	e5f12001 	ldrb	r2, [r1, #1]!
    10ac:	e3520000 	cmp	r2, #0
    10b0:	1afffff7 	bne	1094 <main+0x5f8>
    10b4:	e28b8020 	add	r8, fp, #32
					uart0_printf(buf);
					for (int i = 0; i < 8; i++) {
						long_to_hex_string(*(ptr++), buf, 8);
						buf[8] = ' ';
    10b8:	e3a07020 	mov	r7, #32
					long_to_hex_string(ptr, buf, 8);
					buf[8] = ':';
					buf[9] = 0;
					uart0_printf(buf);
					for (int i = 0; i < 8; i++) {
						long_to_hex_string(*(ptr++), buf, 8);
    10bc:	e28d1024 	add	r1, sp, #36	; 0x24
    10c0:	e3a02008 	mov	r2, #8
    10c4:	e49b0004 	ldr	r0, [fp], #4
    10c8:	ebfffdbd 	bl	7c4 <long_to_hex_string>
    10cc:	e5dd2024 	ldrb	r2, [sp, #36]	; 0x24
    10d0:	e3520000 	cmp	r2, #0
						buf[8] = ' ';
    10d4:	e5cd702c 	strb	r7, [sp, #44]	; 0x2c
						buf[9] = 0;
    10d8:	e5cd602d 	strb	r6, [sp, #45]	; 0x2d
    10dc:	128d1024 	addne	r1, sp, #36	; 0x24
    10e0:	0a000007 	beq	1104 <main+0x668>
// ******************************************************************************
{
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));

	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
    10e4:	e5143fe3 	ldr	r3, [r4, #-4067]	; 0xfe3
    10e8:	e3130001 	tst	r3, #1
    10ec:	e3e03a0f 	mvn	r3, #61440	; 0xf000
    10f0:	0afffffb 	beq	10e4 <main+0x648>
	UART0_DATA = (ch & 0x000000FF);
    10f4:	e5032fe7 	str	r2, [r3, #-4071]	; 0xfe7
    10f8:	e5f12001 	ldrb	r2, [r1, #1]!
    10fc:	e3520000 	cmp	r2, #0
    1100:	1afffff7 	bne	10e4 <main+0x648>
				for (int j = 0; j < 16; j++) {
					long_to_hex_string(ptr, buf, 8);
					buf[8] = ':';
					buf[9] = 0;
					uart0_printf(buf);
					for (int i = 0; i < 8; i++) {
    1104:	e15b0008 	cmp	fp, r8
    1108:	1affffeb 	bne	10bc <main+0x620>
    110c:	e59f1180 	ldr	r1, [pc, #384]	; 1294 <main+0x7f8>
    1110:	e1a0b008 	mov	fp, r8
    1114:	e3a0200d 	mov	r2, #13
// ******************************************************************************
{
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));

	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
    1118:	e5143fe3 	ldr	r3, [r4, #-4067]	; 0xfe3
    111c:	e3130001 	tst	r3, #1
    1120:	e3e03a0f 	mvn	r3, #61440	; 0xf000
    1124:	0afffffb 	beq	1118 <main+0x67c>
	UART0_DATA = (ch & 0x000000FF);
    1128:	e5032fe7 	str	r2, [r3, #-4071]	; 0xfe7
    112c:	e5f12001 	ldrb	r2, [r1, #1]!
    1130:	e3520000 	cmp	r2, #0
    1134:	1afffff7 	bne	1118 <main+0x67c>
				}
			}
			if (ch == 'r') {
				char buf[16];
				unsigned long *ptr = 0x10000000;
				for (int j = 0; j < 16; j++) {
    1138:	e158000a 	cmp	r8, sl
    113c:	1affffca 	bne	106c <main+0x5d0>
    1140:	eafffe79 	b	b2c <main+0x90>
						uart0_printf(buf);
					}
					uart0_printf("\r\n");
				}
			}
			if (ch == 'o') {
    1144:	e354006f 	cmp	r4, #111	; 0x6f
    1148:	1a00003a 	bne	1238 <main+0x79c>
    114c:	e59fa174 	ldr	sl, [pc, #372]	; 12c8 <main+0x82c>
				char buf[16];
				unsigned long *ptr = 0xFFF00000;
				for (int j = 0; j < 16; j++) {
					long_to_hex_string(ptr, buf, 8);
					buf[8] = ':';
    1150:	e3a0903a 	mov	r9, #58	; 0x3a
					buf[9] = 0;
    1154:	e3a06000 	mov	r6, #0
// ******************************************************************************
{
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));

	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
    1158:	e3e04a0f 	mvn	r4, #61440	; 0xf000
			}
			if (ch == 'o') {
				char buf[16];
				unsigned long *ptr = 0xFFF00000;
				for (int j = 0; j < 16; j++) {
					long_to_hex_string(ptr, buf, 8);
    115c:	e28d1024 	add	r1, sp, #36	; 0x24
    1160:	e3a02008 	mov	r2, #8
    1164:	e1a0000a 	mov	r0, sl
    1168:	ebfffd95 	bl	7c4 <long_to_hex_string>
    116c:	e5dd2024 	ldrb	r2, [sp, #36]	; 0x24
    1170:	e3520000 	cmp	r2, #0
					buf[8] = ':';
    1174:	e5cd902c 	strb	r9, [sp, #44]	; 0x2c
					buf[9] = 0;
    1178:	e5cd602d 	strb	r6, [sp, #45]	; 0x2d
    117c:	128d1024 	addne	r1, sp, #36	; 0x24
    1180:	0a000007 	beq	11a4 <main+0x708>
    1184:	e5143fe3 	ldr	r3, [r4, #-4067]	; 0xfe3
    1188:	e3130001 	tst	r3, #1
    118c:	e3e03a0f 	mvn	r3, #61440	; 0xf000
    1190:	0afffffb 	beq	1184 <main+0x6e8>
	UART0_DATA = (ch & 0x000000FF);
    1194:	e5032fe7 	str	r2, [r3, #-4071]	; 0xfe7
    1198:	e5f12001 	ldrb	r2, [r1, #1]!
    119c:	e3520000 	cmp	r2, #0
    11a0:	1afffff7 	bne	1184 <main+0x6e8>
    11a4:	e28a8020 	add	r8, sl, #32
					uart0_printf(buf);
					for (int i = 0; i < 8; i++) {
						long_to_hex_string(*(ptr++), buf, 8);
						buf[8] = ' ';
    11a8:	e3a07020 	mov	r7, #32
					long_to_hex_string(ptr, buf, 8);
					buf[8] = ':';
					buf[9] = 0;
					uart0_printf(buf);
					for (int i = 0; i < 8; i++) {
						long_to_hex_string(*(ptr++), buf, 8);
    11ac:	e28d1024 	add	r1, sp, #36	; 0x24
    11b0:	e3a02008 	mov	r2, #8
    11b4:	e49a0004 	ldr	r0, [sl], #4
    11b8:	ebfffd81 	bl	7c4 <long_to_hex_string>
    11bc:	e5dd2024 	ldrb	r2, [sp, #36]	; 0x24
    11c0:	e3520000 	cmp	r2, #0
						buf[8] = ' ';
    11c4:	e5cd702c 	strb	r7, [sp, #44]	; 0x2c
						buf[9] = 0;
    11c8:	e5cd602d 	strb	r6, [sp, #45]	; 0x2d
    11cc:	128d1024 	addne	r1, sp, #36	; 0x24
    11d0:	0a000007 	beq	11f4 <main+0x758>
// ******************************************************************************
{
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));

	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
    11d4:	e5143fe3 	ldr	r3, [r4, #-4067]	; 0xfe3
    11d8:	e3130001 	tst	r3, #1
    11dc:	e3e03a0f 	mvn	r3, #61440	; 0xf000
    11e0:	0afffffb 	beq	11d4 <main+0x738>
	UART0_DATA = (ch & 0x000000FF);
    11e4:	e5032fe7 	str	r2, [r3, #-4071]	; 0xfe7
    11e8:	e5f12001 	ldrb	r2, [r1, #1]!
    11ec:	e3520000 	cmp	r2, #0
    11f0:	1afffff7 	bne	11d4 <main+0x738>
				for (int j = 0; j < 16; j++) {
					long_to_hex_string(ptr, buf, 8);
					buf[8] = ':';
					buf[9] = 0;
					uart0_printf(buf);
					for (int i = 0; i < 8; i++) {
    11f4:	e15a0008 	cmp	sl, r8
    11f8:	1affffeb 	bne	11ac <main+0x710>
    11fc:	e59f1090 	ldr	r1, [pc, #144]	; 1294 <main+0x7f8>
    1200:	e1a0a008 	mov	sl, r8
    1204:	e3a0200d 	mov	r2, #13
// ******************************************************************************
{
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));

	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
    1208:	e5143fe3 	ldr	r3, [r4, #-4067]	; 0xfe3
    120c:	e3130001 	tst	r3, #1
    1210:	e3e03a0f 	mvn	r3, #61440	; 0xf000
    1214:	0afffffb 	beq	1208 <main+0x76c>
	UART0_DATA = (ch & 0x000000FF);
    1218:	e5032fe7 	str	r2, [r3, #-4071]	; 0xfe7
    121c:	e5f12001 	ldrb	r2, [r1, #1]!
    1220:	e3520000 	cmp	r2, #0
    1224:	1afffff7 	bne	1208 <main+0x76c>
				}
			}
			if (ch == 'o') {
				char buf[16];
				unsigned long *ptr = 0xFFF00000;
				for (int j = 0; j < 16; j++) {
    1228:	e59f009c 	ldr	r0, [pc, #156]	; 12cc <main+0x830>
    122c:	e1580000 	cmp	r8, r0
    1230:	1affffc9 	bne	115c <main+0x6c0>
    1234:	eafffe3c 	b	b2c <main+0x90>
						uart0_printf(buf);
					}
					uart0_printf("\r\n");
				}
			}
			if (ch == 't') {
    1238:	e3540074 	cmp	r4, #116	; 0x74
    123c:	1afffe3a 	bne	b2c <main+0x90>
				// timer init
				STME0_CNT  = 0;
				STME0_VAL  = 5000000; // threshold value for 0.1s ticks
    1240:	e59fe088 	ldr	lr, [pc, #136]	; 12d0 <main+0x834>
					uart0_printf("\r\n");
				}
			}
			if (ch == 't') {
				// timer init
				STME0_CNT  = 0;
    1244:	e3e02a0f 	mvn	r2, #61440	; 0xf000
    1248:	e3a01000 	mov	r1, #0
				STME0_VAL  = 5000000; // threshold value for 0.1s ticks
				STME0_CONF = (1<<2) | (1<<1) | (1<<0); // interrupt en, auto reset, timer enable
    124c:	e3a0c007 	mov	ip, #7
					uart0_printf("\r\n");
				}
			}
			if (ch == 't') {
				// timer init
				STME0_CNT  = 0;
    1250:	e5021fdf 	str	r1, [r2, #-4063]	; 0xfdf
				STME0_VAL  = 5000000; // threshold value for 0.1s ticks
    1254:	e502efdb 	str	lr, [r2, #-4059]	; 0xfdb
				STME0_CONF = (1<<2) | (1<<1) | (1<<0); // interrupt en, auto reset, timer enable
    1258:	e502cfd7 	str	ip, [r2, #-4055]	; 0xfd7
				VICVectAddr0 = (unsigned long)timer0_isr;
    125c:	e59f2070 	ldr	r2, [pc, #112]	; 12d4 <main+0x838>
    1260:	e3e03000 	mvn	r3, #0
				VICVectCntl0 = (1<<5) | 0; // enable and channel select = 0 (timer0)
    1264:	e3a00020 	mov	r0, #32
				VICIntEnable = (1<<0); // enable channel 0 (timer0)
    1268:	e3a01001 	mov	r1, #1
			if (ch == 't') {
				// timer init
				STME0_CNT  = 0;
				STME0_VAL  = 5000000; // threshold value for 0.1s ticks
				STME0_CONF = (1<<2) | (1<<1) | (1<<0); // interrupt en, auto reset, timer enable
				VICVectAddr0 = (unsigned long)timer0_isr;
    126c:	e5032fbf 	str	r2, [r3, #-4031]	; 0xfbf
				VICVectCntl0 = (1<<5) | 0; // enable and channel select = 0 (timer0)
    1270:	e5030f7f 	str	r0, [r3, #-3967]	; 0xf7f
				VICIntEnable = (1<<0); // enable channel 0 (timer0)
    1274:	e5031fef 	str	r1, [r3, #-4079]	; 0xfef
// read CMSR value
   static inline unsigned long get_cmsr(void)
// ******************************************************************************
{
	unsigned long _cmsr;
	asm volatile (" mrs %0, cpsr" : "=r" (_cmsr) : /* no inputs */  );
    1278:	e10f3000 	mrs	r3, CPSR
// Enable all external INTs
   void io_enable_xint(void)
// ******************************************************************************
{
	unsigned long _cmsr = get_cmsr();
	_cmsr = _cmsr & ~(1<<CMSR_FIQ) &~(1<<CMSR_IRQ);
    127c:	e3c330c0 	bic	r3, r3, #192	; 0xc0
// ******************************************************************************
// write CMSR value
   static inline void set_cmsr(unsigned long _cmsr)
// ******************************************************************************
{
	asm volatile (" msr cpsr, %0" : /* no outputs */ : "r" (_cmsr)  );
    1280:	e129f003 	msr	CPSR_fc, r3
    1284:	eafffe28 	b	b2c <main+0x90>
    1288:	00000a30 	.word	0x00000a30
    128c:	00000a54 	.word	0x00000a54
    1290:	00000a78 	.word	0x00000a78
    1294:	00000a88 	.word	0x00000a88
    1298:	00000a27 	.word	0x00000a27
    129c:	00000a8c 	.word	0x00000a8c
    12a0:	00000a1f 	.word	0x00000a1f
    12a4:	10000200 	.word	0x10000200
    12a8:	00000a90 	.word	0x00000a90
    12ac:	aa550000 	.word	0xaa550000
    12b0:	aa550020 	.word	0xaa550020
    12b4:	55aa0000 	.word	0x55aa0000
    12b8:	10000080 	.word	0x10000080
    12bc:	10000100 	.word	0x10000100
    12c0:	5a5a0000 	.word	0x5a5a0000
    12c4:	10000180 	.word	0x10000180
    12c8:	fff00000 	.word	0xfff00000
    12cc:	fff00200 	.word	0xfff00200
    12d0:	004c4b40 	.word	0x004c4b40
    12d4:	00000290 	.word	0x00000290
