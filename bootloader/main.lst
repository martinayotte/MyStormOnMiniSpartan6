   1              		.cpu arm7tdmi
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 2
  10              		.eabi_attribute 34, 0
  11              		.eabi_attribute 18, 4
  12              		.file	"main.c"
  13              		.text
  14              	.Ltext0:
  15              		.cfi_sections	.debug_frame
  16              		.align	2
  17              		.global	io_read_gpio0_pin
  19              	io_read_gpio0_pin:
  20              	.LFB0:
  21              		.file 1 "../lib/io_driver.c"
   1:../lib/io_driver.c **** #include "io_driver.h"
   2:../lib/io_driver.c **** #include "storm_core.h"
   3:../lib/io_driver.c **** #include "storm_soc_basic.h"
   4:../lib/io_driver.c **** 
   5:../lib/io_driver.c **** // ################################################################################################
   6:../lib/io_driver.c **** // General Purpose IO (GENERAL_PURPOSE_CONTROLLER_0)
   7:../lib/io_driver.c **** // ################################################################################################
   8:../lib/io_driver.c **** 
   9:../lib/io_driver.c **** // ******************************************************************************
  10:../lib/io_driver.c **** // Read general purpose IO pin
  11:../lib/io_driver.c ****    unsigned long io_read_gpio0_pin(unsigned char pin)
  12:../lib/io_driver.c **** // ******************************************************************************
  13:../lib/io_driver.c **** {
  22              		.loc 1 13 0
  23              		.cfi_startproc
  24              		@ Function supports interworking.
  25              		@ args = 0, pretend = 0, frame = 0
  26              		@ frame_needed = 0, uses_anonymous_args = 0
  27              		@ link register save eliminated.
  28              	.LVL0:
  14:../lib/io_driver.c **** //	unsigned long _cmsr = get_cmsr();
  15:../lib/io_driver.c **** //	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));
  16:../lib/io_driver.c **** 
  17:../lib/io_driver.c **** 		unsigned long temp = GPIO0_IN & (1<<pin);
  29              		.loc 1 17 0
  30 0000 E3E03A0F 		mvn	r3, #61440
  31 0004 E5133FFB 		ldr	r3, [r3, #-4091]
  32              	.LVL1:
  33 0008 E3A02001 		mov	r2, #1
  18:../lib/io_driver.c **** 	
  19:../lib/io_driver.c **** //	set_cmsr(_cmsr);
  20:../lib/io_driver.c **** 	return temp;
  21:../lib/io_driver.c **** }
  34              		.loc 1 21 0
  35 000c E0030012 		and	r0, r3, r2, asl r0
  36              	.LVL2:
  37 0010 E12FFF1E 		bx	lr
  38              		.cfi_endproc
  39              	.LFE0:
  41              		.align	2
  42              		.global	io_read_gpio0_port
  44              	io_read_gpio0_port:
  45              	.LFB1:
  22:../lib/io_driver.c **** 
  23:../lib/io_driver.c **** // ******************************************************************************
  24:../lib/io_driver.c **** // Read general purpose IO port
  25:../lib/io_driver.c ****    unsigned long io_read_gpio0_port(void)
  26:../lib/io_driver.c **** // ******************************************************************************
  27:../lib/io_driver.c **** {
  46              		.loc 1 27 0
  47              		.cfi_startproc
  48              		@ Function supports interworking.
  49              		@ args = 0, pretend = 0, frame = 0
  50              		@ frame_needed = 0, uses_anonymous_args = 0
  51              		@ link register save eliminated.
  28:../lib/io_driver.c **** //	unsigned long _cmsr = get_cmsr();
  29:../lib/io_driver.c **** //	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));
  30:../lib/io_driver.c **** 
  31:../lib/io_driver.c **** 		unsigned long temp = GPIO0_IN;
  52              		.loc 1 31 0
  53 0014 E3E03A0F 		mvn	r3, #61440
  54 0018 E5130FFB 		ldr	r0, [r3, #-4091]
  55              	.LVL3:
  32:../lib/io_driver.c **** 
  33:../lib/io_driver.c **** //	set_cmsr(_cmsr);
  34:../lib/io_driver.c **** 	return temp;
  35:../lib/io_driver.c **** }
  56              		.loc 1 35 0
  57 001c E12FFF1E 		bx	lr
  58              		.cfi_endproc
  59              	.LFE1:
  61              		.align	2
  62              		.global	io_set_gpio0_pin
  64              	io_set_gpio0_pin:
  65              	.LFB2:
  36:../lib/io_driver.c **** 
  37:../lib/io_driver.c **** // ******************************************************************************
  38:../lib/io_driver.c **** // Set general purpose IO port
  39:../lib/io_driver.c ****    void io_set_gpio0_pin(unsigned char pin)
  40:../lib/io_driver.c **** // ******************************************************************************
  41:../lib/io_driver.c **** {
  66              		.loc 1 41 0
  67              		.cfi_startproc
  68              		@ Function supports interworking.
  69              		@ args = 0, pretend = 0, frame = 0
  70              		@ frame_needed = 0, uses_anonymous_args = 0
  71              		@ link register save eliminated.
  72              	.LVL4:
  42:../lib/io_driver.c **** //	unsigned long _cmsr = get_cmsr();
  43:../lib/io_driver.c **** //	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));
  44:../lib/io_driver.c **** 
  45:../lib/io_driver.c **** 		GPIO0_OUT = GPIO0_OUT | (1<<pin);
  73              		.loc 1 45 0
  74 0020 E3E03A0F 		mvn	r3, #61440
  75 0024 E5132FFF 		ldr	r2, [r3, #-4095]
  76 0028 E3A01001 		mov	r1, #1
  77 002c E1820011 		orr	r0, r2, r1, asl r0
  78              	.LVL5:
  79 0030 E5030FFF 		str	r0, [r3, #-4095]
  80 0034 E12FFF1E 		bx	lr
  81              		.cfi_endproc
  82              	.LFE2:
  84              		.align	2
  85              		.global	io_clr_gpio0_pin
  87              	io_clr_gpio0_pin:
  88              	.LFB3:
  46:../lib/io_driver.c **** 
  47:../lib/io_driver.c **** //	set_cmsr(_cmsr);
  48:../lib/io_driver.c **** }
  49:../lib/io_driver.c **** 
  50:../lib/io_driver.c **** // ******************************************************************************
  51:../lib/io_driver.c **** // Clear general purpose IO port
  52:../lib/io_driver.c ****    void io_clr_gpio0_pin(unsigned char pin)
  53:../lib/io_driver.c **** // ******************************************************************************
  54:../lib/io_driver.c **** {
  89              		.loc 1 54 0
  90              		.cfi_startproc
  91              		@ Function supports interworking.
  92              		@ args = 0, pretend = 0, frame = 0
  93              		@ frame_needed = 0, uses_anonymous_args = 0
  94              		@ link register save eliminated.
  95              	.LVL6:
  55:../lib/io_driver.c **** //	unsigned long _cmsr = get_cmsr();
  56:../lib/io_driver.c **** //	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));
  57:../lib/io_driver.c **** 
  58:../lib/io_driver.c **** 		GPIO0_OUT = GPIO0_OUT & ~(1<<pin);
  96              		.loc 1 58 0
  97 0038 E3E03A0F 		mvn	r3, #61440
  98 003c E5132FFF 		ldr	r2, [r3, #-4095]
  99 0040 E3A01001 		mov	r1, #1
 100 0044 E1C20011 		bic	r0, r2, r1, asl r0
 101              	.LVL7:
 102 0048 E5030FFF 		str	r0, [r3, #-4095]
 103 004c E12FFF1E 		bx	lr
 104              		.cfi_endproc
 105              	.LFE3:
 107              		.align	2
 108              		.global	io_toggle_gpio0_pin
 110              	io_toggle_gpio0_pin:
 111              	.LFB4:
  59:../lib/io_driver.c **** 
  60:../lib/io_driver.c **** //	set_cmsr(_cmsr);
  61:../lib/io_driver.c **** }
  62:../lib/io_driver.c **** // ******************************************************************************
  63:../lib/io_driver.c **** // Set general purpose IO port
  64:../lib/io_driver.c ****    void io_toggle_gpio0_pin(unsigned char pin)
  65:../lib/io_driver.c **** // ******************************************************************************
  66:../lib/io_driver.c **** {
 112              		.loc 1 66 0
 113              		.cfi_startproc
 114              		@ Function supports interworking.
 115              		@ args = 0, pretend = 0, frame = 0
 116              		@ frame_needed = 0, uses_anonymous_args = 0
 117              		@ link register save eliminated.
 118              	.LVL8:
  67:../lib/io_driver.c **** //	unsigned long _cmsr = get_cmsr();
  68:../lib/io_driver.c **** //	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));
  69:../lib/io_driver.c **** 
  70:../lib/io_driver.c **** 		GPIO0_OUT = GPIO0_OUT ^ (1<<pin);
 119              		.loc 1 70 0
 120 0050 E3E03A0F 		mvn	r3, #61440
 121 0054 E5132FFF 		ldr	r2, [r3, #-4095]
 122 0058 E3A01001 		mov	r1, #1
 123 005c E0220011 		eor	r0, r2, r1, asl r0
 124              	.LVL9:
 125 0060 E5030FFF 		str	r0, [r3, #-4095]
 126 0064 E12FFF1E 		bx	lr
 127              		.cfi_endproc
 128              	.LFE4:
 130              		.align	2
 131              		.global	io_set_gpio0_port
 133              	io_set_gpio0_port:
 134              	.LFB5:
  71:../lib/io_driver.c **** 
  72:../lib/io_driver.c **** //	set_cmsr(_cmsr);
  73:../lib/io_driver.c **** }
  74:../lib/io_driver.c **** 
  75:../lib/io_driver.c **** // ******************************************************************************
  76:../lib/io_driver.c **** // Clear general purpose IO port
  77:../lib/io_driver.c ****    void io_set_gpio0_port(unsigned long value)
  78:../lib/io_driver.c **** // ******************************************************************************
  79:../lib/io_driver.c **** {
 135              		.loc 1 79 0
 136              		.cfi_startproc
 137              		@ Function supports interworking.
 138              		@ args = 0, pretend = 0, frame = 0
 139              		@ frame_needed = 0, uses_anonymous_args = 0
 140              		@ link register save eliminated.
 141              	.LVL10:
  80:../lib/io_driver.c **** //	unsigned long _cmsr = get_cmsr();
  81:../lib/io_driver.c **** //	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));
  82:../lib/io_driver.c **** 
  83:../lib/io_driver.c **** 		GPIO0_OUT = value;
 142              		.loc 1 83 0
 143 0068 E3E03A0F 		mvn	r3, #61440
 144 006c E5030FFF 		str	r0, [r3, #-4095]
 145 0070 E12FFF1E 		bx	lr
 146              		.cfi_endproc
 147              	.LFE5:
 149              		.align	2
 150              		.global	io_set_pwm
 152              	io_set_pwm:
 153              	.LFB6:
  84:../lib/io_driver.c **** 
  85:../lib/io_driver.c **** //	set_cmsr(_cmsr);
  86:../lib/io_driver.c **** }
  87:../lib/io_driver.c **** 
  88:../lib/io_driver.c **** 
  89:../lib/io_driver.c **** 
  90:../lib/io_driver.c **** // ################################################################################################
  91:../lib/io_driver.c **** // Pulse-Width-Modulation Controller
  92:../lib/io_driver.c **** // ################################################################################################
  93:../lib/io_driver.c **** 
  94:../lib/io_driver.c **** // ******************************************************************************
  95:../lib/io_driver.c **** // Set pwm value
  96:../lib/io_driver.c ****    void io_set_pwm(unsigned char port, unsigned char data)
  97:../lib/io_driver.c **** // ******************************************************************************
  98:../lib/io_driver.c **** {
 154              		.loc 1 98 0
 155              		.cfi_startproc
 156              		@ Function supports interworking.
 157              		@ args = 0, pretend = 0, frame = 0
 158              		@ frame_needed = 0, uses_anonymous_args = 0
 159              		@ link register save eliminated.
 160              	.LVL11:
  99:../lib/io_driver.c **** //	unsigned long _cmsr = get_cmsr();
 100:../lib/io_driver.c **** //	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));
 101:../lib/io_driver.c **** 
 102:../lib/io_driver.c **** 	unsigned long temp = 0;
 103:../lib/io_driver.c **** 
 104:../lib/io_driver.c **** 	// value adjustment
 105:../lib/io_driver.c **** 	if(port > 7)
 161              		.loc 1 105 0
 162 0074 E3500007 		cmp	r0, #7
 163 0078 8A00000B 		bhi	.L11
 106:../lib/io_driver.c **** 		port = 0;
 107:../lib/io_driver.c **** 
 108:../lib/io_driver.c **** 	if(port < 4){
 164              		.loc 1 108 0
 165 007c E3500003 		cmp	r0, #3
 166 0080 9A000011 		bls	.L13
 167              	.LVL12:
 109:../lib/io_driver.c **** 		temp = PWM0_CONF0; // get working copy
 110:../lib/io_driver.c **** 		temp = temp & ~(0xFF << (port*8)); // clear old value
 111:../lib/io_driver.c **** 		temp = temp | (unsigned long)(data << (port*8)); // insert new value
 112:../lib/io_driver.c **** 		PWM0_CONF0 = temp;
 113:../lib/io_driver.c **** 	}
 114:../lib/io_driver.c **** 	else{
 115:../lib/io_driver.c **** 		port = port-4;
 116:../lib/io_driver.c **** 		temp = PWM0_CONF1; // get working copy
 168              		.loc 1 116 0
 169 0084 E3E03A0F 		mvn	r3, #61440
 115:../lib/io_driver.c **** 		port = port-4;
 170              		.loc 1 115 0
 171 0088 E2400004 		sub	r0, r0, #4
 172              	.LVL13:
 173              		.loc 1 116 0
 174 008c E5132F8B 		ldr	r2, [r3, #-3979]
 175              	.LVL14:
 117:../lib/io_driver.c **** 		temp = temp & ~(0xFF << (port*8)); // clear old value
 176              		.loc 1 117 0
 177 0090 E20000FF 		and	r0, r0, #255
 178              	.LVL15:
 179 0094 E1A00180 		mov	r0, r0, asl #3
 180 0098 E3A0C0FF 		mov	ip, #255
 181 009c E1C2201C 		bic	r2, r2, ip, asl r0
 182              	.LVL16:
 118:../lib/io_driver.c **** 		temp = temp | (unsigned long)(data << (port*8)); // insert new value
 183              		.loc 1 118 0
 184 00a0 E1821011 		orr	r1, r2, r1, asl r0
 185              	.LVL17:
 119:../lib/io_driver.c **** 		PWM0_CONF1 = temp;
 186              		.loc 1 119 0
 187 00a4 E5031F8B 		str	r1, [r3, #-3979]
 188 00a8 E12FFF1E 		bx	lr
 189              	.LVL18:
 190              	.L11:
 191 00ac E3E000FF 		mvn	r0, #255
 192              	.LVL19:
 193 00b0 E3A02000 		mov	r2, #0
 194              	.LVL20:
 195              	.L8:
 109:../lib/io_driver.c **** 		temp = PWM0_CONF0; // get working copy
 196              		.loc 1 109 0
 197 00b4 E3E03A0F 		mvn	r3, #61440
 198 00b8 E513CF8F 		ldr	ip, [r3, #-3983]
 199              	.LVL21:
 110:../lib/io_driver.c **** 		temp = temp & ~(0xFF << (port*8)); // clear old value
 200              		.loc 1 110 0
 201 00bc E000000C 		and	r0, r0, ip
 202              	.LVL22:
 111:../lib/io_driver.c **** 		temp = temp | (unsigned long)(data << (port*8)); // insert new value
 203              		.loc 1 111 0
 204 00c0 E1801211 		orr	r1, r0, r1, asl r2
 205              	.LVL23:
 112:../lib/io_driver.c **** 		PWM0_CONF0 = temp;
 206              		.loc 1 112 0
 207 00c4 E5031F8F 		str	r1, [r3, #-3983]
 208 00c8 E12FFF1E 		bx	lr
 209              	.LVL24:
 210              	.L13:
 211 00cc E1A02180 		mov	r2, r0, asl #3
 212 00d0 E3A000FF 		mov	r0, #255
 213              	.LVL25:
 214 00d4 E1E00210 		mvn	r0, r0, asl r2
 215 00d8 EAFFFFF5 		b	.L8
 216              		.cfi_endproc
 217              	.LFE6:
 219              		.align	2
 220              		.global	io_get_pwm
 222              	io_get_pwm:
 223              	.LFB7:
 120:../lib/io_driver.c **** 	}
 121:../lib/io_driver.c **** //	set_cmsr(_cmsr);
 122:../lib/io_driver.c **** }
 123:../lib/io_driver.c **** 
 124:../lib/io_driver.c **** // ******************************************************************************
 125:../lib/io_driver.c **** // Set pwm value
 126:../lib/io_driver.c ****    unsigned char io_get_pwm(unsigned char port)
 127:../lib/io_driver.c **** // ******************************************************************************
 128:../lib/io_driver.c **** {
 224              		.loc 1 128 0
 225              		.cfi_startproc
 226              		@ Function supports interworking.
 227              		@ args = 0, pretend = 0, frame = 0
 228              		@ frame_needed = 0, uses_anonymous_args = 0
 229              		@ link register save eliminated.
 230              	.LVL26:
 129:../lib/io_driver.c **** //	unsigned long _cmsr = get_cmsr();
 130:../lib/io_driver.c **** //	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));
 131:../lib/io_driver.c **** 
 132:../lib/io_driver.c **** 	unsigned long temp = 0;
 133:../lib/io_driver.c **** 
 134:../lib/io_driver.c **** 	// value adjustment
 135:../lib/io_driver.c **** 	if(port > 7)
 231              		.loc 1 135 0
 232 00dc E3500007 		cmp	r0, #7
 233 00e0 8A00000A 		bhi	.L18
 136:../lib/io_driver.c **** 		port = 0;
 137:../lib/io_driver.c **** 
 138:../lib/io_driver.c **** 	if(port < 4)
 234              		.loc 1 138 0
 235 00e4 E3500003 		cmp	r0, #3
 236 00e8 91A00180 		movls	r0, r0, asl #3
 237              	.LVL27:
 238 00ec 9A000008 		bls	.L15
 239              	.LVL28:
 139:../lib/io_driver.c **** 		temp = PWM0_CONF0; // get config register
 140:../lib/io_driver.c **** 	else{
 141:../lib/io_driver.c **** 		port = port-4;
 240              		.loc 1 141 0
 241 00f0 E2400004 		sub	r0, r0, #4
 242              	.LVL29:
 142:../lib/io_driver.c **** 		temp = PWM0_CONF1; // get config register
 243              		.loc 1 142 0
 244 00f4 E3E03A0F 		mvn	r3, #61440
 245 00f8 E20000FF 		and	r0, r0, #255
 246              	.LVL30:
 247 00fc E5133F8B 		ldr	r3, [r3, #-3979]
 248              	.LVL31:
 249 0100 E1A00180 		mov	r0, r0, asl #3
 250              	.L17:
 251              	.LVL32:
 143:../lib/io_driver.c **** 	}
 144:../lib/io_driver.c **** 
 145:../lib/io_driver.c **** 	temp = temp >> (port*8); // only keep designated byte
 252              		.loc 1 145 0
 253 0104 E1A00033 		mov	r0, r3, lsr r0
 254              	.LVL33:
 146:../lib/io_driver.c **** 
 147:../lib/io_driver.c **** //	set_cmsr(_cmsr);
 148:../lib/io_driver.c **** 	return (unsigned char)temp;
 255              		.loc 1 148 0
 256 0108 E20000FF 		and	r0, r0, #255
 257              	.LVL34:
 149:../lib/io_driver.c **** }
 258              		.loc 1 149 0
 259 010c E12FFF1E 		bx	lr
 260              	.LVL35:
 261              	.L18:
 262 0110 E3A00000 		mov	r0, #0
 263              	.LVL36:
 264              	.L15:
 139:../lib/io_driver.c **** 		temp = PWM0_CONF0; // get config register
 265              		.loc 1 139 0
 266 0114 E3E03A0F 		mvn	r3, #61440
 267 0118 E5133F8F 		ldr	r3, [r3, #-3983]
 268              	.LVL37:
 269 011c EAFFFFF8 		b	.L17
 270              		.cfi_endproc
 271              	.LFE7:
 273              		.align	2
 274              		.global	io_uart0_read_byte
 276              	io_uart0_read_byte:
 277              	.LFB8:
 150:../lib/io_driver.c **** 
 151:../lib/io_driver.c **** 
 152:../lib/io_driver.c **** 
 153:../lib/io_driver.c **** // ################################################################################################
 154:../lib/io_driver.c **** // General Purpose UART "miniUART" (UART_0)
 155:../lib/io_driver.c **** // ################################################################################################
 156:../lib/io_driver.c **** 
 157:../lib/io_driver.c **** // ******************************************************************************
 158:../lib/io_driver.c **** // Read one byte via UART 0
 159:../lib/io_driver.c ****    int io_uart0_read_byte(void)
 160:../lib/io_driver.c **** // ******************************************************************************
 161:../lib/io_driver.c **** {
 278              		.loc 1 161 0
 279              		.cfi_startproc
 280              		@ Function supports interworking.
 281              		@ args = 0, pretend = 0, frame = 0
 282              		@ frame_needed = 0, uses_anonymous_args = 0
 283              		@ link register save eliminated.
 162:../lib/io_driver.c **** //	unsigned long _cmsr = get_cmsr();
 163:../lib/io_driver.c **** //	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));
 164:../lib/io_driver.c **** 
 165:../lib/io_driver.c **** 	int temp;
 166:../lib/io_driver.c **** 	if ((UART0_SREG & (1<<CUART_RXD)) != 0) // byte available?
 284              		.loc 1 166 0
 285 0120 E3E03A0F 		mvn	r3, #61440
 286 0124 E5132FE3 		ldr	r2, [r3, #-4067]
 287 0128 E3120002 		tst	r2, #2
 167:../lib/io_driver.c **** 		temp = UART0_DATA;
 288              		.loc 1 167 0
 289 012c 15130FE7 		ldrne	r0, [r3, #-4071]
 290              	.LVL38:
 168:../lib/io_driver.c **** 	else
 169:../lib/io_driver.c **** 		temp = -1;
 291              		.loc 1 169 0
 292 0130 03E00000 		mvneq	r0, #0
 293              	.LVL39:
 170:../lib/io_driver.c **** 
 171:../lib/io_driver.c **** //	set_cmsr(_cmsr);
 172:../lib/io_driver.c **** 	return temp;
 173:../lib/io_driver.c **** }
 294              		.loc 1 173 0
 295 0134 E12FFF1E 		bx	lr
 296              		.cfi_endproc
 297              	.LFE8:
 299              		.align	2
 300              		.global	io_uart0_send_byte
 302              	io_uart0_send_byte:
 303              	.LFB9:
 174:../lib/io_driver.c **** 
 175:../lib/io_driver.c **** // ******************************************************************************
 176:../lib/io_driver.c **** // Write one byte via UART 0
 177:../lib/io_driver.c ****    int io_uart0_send_byte(int ch)
 178:../lib/io_driver.c **** // ******************************************************************************
 179:../lib/io_driver.c **** {
 304              		.loc 1 179 0
 305              		.cfi_startproc
 306              		@ Function supports interworking.
 307              		@ args = 0, pretend = 0, frame = 0
 308              		@ frame_needed = 0, uses_anonymous_args = 0
 309              		@ link register save eliminated.
 310              	.LVL40:
 180:../lib/io_driver.c **** //	unsigned long _cmsr = get_cmsr();
 181:../lib/io_driver.c **** //	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));
 182:../lib/io_driver.c **** 
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 311              		.loc 1 183 0
 312 0138 E3E02A0F 		mvn	r2, #61440
 313              	.L24:
 314              		.loc 1 183 0 is_stmt 0 discriminator 1
 315 013c E5123FE3 		ldr	r3, [r2, #-4067]
 316 0140 E3130001 		tst	r3, #1
 317 0144 E3E03A0F 		mvn	r3, #61440
 318 0148 0AFFFFFB 		beq	.L24
 184:../lib/io_driver.c **** 	UART0_DATA = (ch & 0x000000FF);
 319              		.loc 1 184 0 is_stmt 1
 320 014c E20020FF 		and	r2, r0, #255
 321 0150 E5032FE7 		str	r2, [r3, #-4071]
 185:../lib/io_driver.c **** 
 186:../lib/io_driver.c **** //	set_cmsr(_cmsr);
 187:../lib/io_driver.c **** 	return ch;
 188:../lib/io_driver.c **** }
 322              		.loc 1 188 0
 323 0154 E12FFF1E 		bx	lr
 324              		.cfi_endproc
 325              	.LFE9:
 327              		.align	2
 328              		.global	io_spi0_config
 330              	io_spi0_config:
 331              	.LFB10:
 189:../lib/io_driver.c **** 
 190:../lib/io_driver.c **** 
 191:../lib/io_driver.c **** 
 192:../lib/io_driver.c **** // ################################################################################################
 193:../lib/io_driver.c **** // Serial Peripherial Interface (SPI_CONTROLLER_0)
 194:../lib/io_driver.c **** // ################################################################################################
 195:../lib/io_driver.c **** 
 196:../lib/io_driver.c **** // ******************************************************************************
 197:../lib/io_driver.c **** // Configure SPI 0
 198:../lib/io_driver.c ****    void io_spi0_config(unsigned char auto_cs, unsigned long data_size)
 199:../lib/io_driver.c **** // ******************************************************************************
 200:../lib/io_driver.c **** {
 332              		.loc 1 200 0
 333              		.cfi_startproc
 334              		@ Function supports interworking.
 335              		@ args = 0, pretend = 0, frame = 0
 336              		@ frame_needed = 0, uses_anonymous_args = 0
 337              		@ link register save eliminated.
 338              	.LVL41:
 201:../lib/io_driver.c **** //	unsigned long _cmsr = get_cmsr();
 202:../lib/io_driver.c **** //	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));
 203:../lib/io_driver.c **** 	// devices update their serial input on a rising edge of sclk,
 204:../lib/io_driver.c **** 	// so we need to update the mosi output of the core before
 205:../lib/io_driver.c **** 	// -> at the falling edge of sclk = set SPI_TX_NEG
 206:../lib/io_driver.c **** 	if(auto_cs == 1)
 339              		.loc 1 206 0
 340 0158 E3500001 		cmp	r0, #1
 207:../lib/io_driver.c **** 		SPI0_CONF = (1<<SPI_ACS) | (1<<SPI_TX_NEG) | data_size; // auto assert cs
 341              		.loc 1 207 0
 342 015c 03811B09 		orreq	r1, r1, #9216
 343              	.LVL42:
 208:../lib/io_driver.c **** 	else
 209:../lib/io_driver.c **** 		SPI0_CONF = (0<<SPI_ACS) | (1<<SPI_TX_NEG) | data_size; // manual assert cs
 344              		.loc 1 209 0
 345 0160 13811B01 		orrne	r1, r1, #1024
 346 0164 E3E03A0F 		mvn	r3, #61440
 347 0168 E5031FCF 		str	r1, [r3, #-4047]
 348 016c E12FFF1E 		bx	lr
 349              		.cfi_endproc
 350              	.LFE10:
 352              		.align	2
 353              		.global	io_spi0_speed
 355              	io_spi0_speed:
 356              	.LFB11:
 210:../lib/io_driver.c **** //	set_cmsr(_cmsr);
 211:../lib/io_driver.c **** }
 212:../lib/io_driver.c **** 
 213:../lib/io_driver.c **** // ******************************************************************************
 214:../lib/io_driver.c **** // Configure SPI 0 CLK frequency -> (sys_clk/(spi_clk*2))-1
 215:../lib/io_driver.c ****    void io_spi0_speed(unsigned long clk_divider)
 216:../lib/io_driver.c **** // ******************************************************************************
 217:../lib/io_driver.c **** {
 357              		.loc 1 217 0
 358              		.cfi_startproc
 359              		@ Function supports interworking.
 360              		@ args = 0, pretend = 0, frame = 0
 361              		@ frame_needed = 0, uses_anonymous_args = 0
 362              		@ link register save eliminated.
 363              	.LVL43:
 218:../lib/io_driver.c **** //	unsigned long _cmsr = get_cmsr();
 219:../lib/io_driver.c **** //	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));
 220:../lib/io_driver.c **** 
 221:../lib/io_driver.c **** 		SPI0_PRSC = clk_divider; // (sys_clk/(spi_clk*2))-1;
 364              		.loc 1 221 0
 365 0170 E3E03A0F 		mvn	r3, #61440
 366 0174 E5030FCB 		str	r0, [r3, #-4043]
 367 0178 E12FFF1E 		bx	lr
 368              		.cfi_endproc
 369              	.LFE11:
 371              		.align	2
 372              		.global	io_spi0_trans
 374              	io_spi0_trans:
 375              	.LFB12:
 222:../lib/io_driver.c **** 
 223:../lib/io_driver.c **** //	set_cmsr(_cmsr);
 224:../lib/io_driver.c **** }
 225:../lib/io_driver.c **** 
 226:../lib/io_driver.c **** // ******************************************************************************
 227:../lib/io_driver.c **** // Sends/receives max 32 bits via SPI, CS and config must be done outside
 228:../lib/io_driver.c ****    unsigned long io_spi0_trans(unsigned long data)
 229:../lib/io_driver.c **** // ******************************************************************************
 230:../lib/io_driver.c **** {
 376              		.loc 1 230 0
 377              		.cfi_startproc
 378              		@ Function supports interworking.
 379              		@ args = 0, pretend = 0, frame = 0
 380              		@ frame_needed = 0, uses_anonymous_args = 0
 381              		@ link register save eliminated.
 382              	.LVL44:
 231:../lib/io_driver.c **** //	unsigned long _cmsr = get_cmsr();
 232:../lib/io_driver.c **** //	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));
 233:../lib/io_driver.c **** 
 234:../lib/io_driver.c **** 	// spi transmission
 235:../lib/io_driver.c **** 	while((SPI0_CONF & (1<<SPI_BUSY)) != 0); // wait for prev tx to finish
 383              		.loc 1 235 0
 384 017c E3E02A0F 		mvn	r2, #61440
 385              	.L31:
 386              		.loc 1 235 0 is_stmt 0 discriminator 1
 387 0180 E5123FCF 		ldr	r3, [r2, #-4047]
 388 0184 E3130C01 		tst	r3, #256
 389 0188 E3E03A0F 		mvn	r3, #61440
 390 018c 1AFFFFFB 		bne	.L31
 236:../lib/io_driver.c **** 	SPI0_DAT0 = data;
 391              		.loc 1 236 0 is_stmt 1
 392 0190 E5030FBF 		str	r0, [r3, #-4031]
 237:../lib/io_driver.c **** 	SPI0_CONF = SPI0_CONF | (1<<SPI_BUSY); // start transmitter
 393              		.loc 1 237 0
 394 0194 E5132FCF 		ldr	r2, [r3, #-4047]
 395 0198 E3822C01 		orr	r2, r2, #256
 396 019c E5032FCF 		str	r2, [r3, #-4047]
 238:../lib/io_driver.c **** 	while((SPI0_CONF & (1<<SPI_BUSY)) != 0); // wait for rx to finish
 397              		.loc 1 238 0
 398 01a0 E1A01003 		mov	r1, r3
 399              	.L33:
 400              		.loc 1 238 0 is_stmt 0 discriminator 1
 401 01a4 E5113FCF 		ldr	r3, [r1, #-4047]
 402 01a8 E3130C01 		tst	r3, #256
 403 01ac E3E02A0F 		mvn	r2, #61440
 404 01b0 1AFFFFFB 		bne	.L33
 239:../lib/io_driver.c **** 	unsigned long temp = SPI0_DAT0;
 405              		.loc 1 239 0 is_stmt 1
 406 01b4 E5120FBF 		ldr	r0, [r2, #-4031]
 407              	.LVL45:
 240:../lib/io_driver.c **** 
 241:../lib/io_driver.c **** //	set_cmsr(_cmsr);
 242:../lib/io_driver.c **** 	return temp;
 243:../lib/io_driver.c **** }
 408              		.loc 1 243 0
 409 01b8 E12FFF1E 		bx	lr
 410              		.cfi_endproc
 411              	.LFE12:
 413              		.align	2
 414              		.global	io_spi0_enable
 416              	io_spi0_enable:
 417              	.LFB13:
 244:../lib/io_driver.c **** 
 245:../lib/io_driver.c **** // ******************************************************************************
 246:../lib/io_driver.c **** // Controls the CS of SPI0, enables a connected CS (turns it LOW)
 247:../lib/io_driver.c ****    void io_spi0_enable(unsigned char device)
 248:../lib/io_driver.c **** // ******************************************************************************
 249:../lib/io_driver.c **** {
 418              		.loc 1 249 0
 419              		.cfi_startproc
 420              		@ Function supports interworking.
 421              		@ args = 0, pretend = 0, frame = 0
 422              		@ frame_needed = 0, uses_anonymous_args = 0
 423              		@ link register save eliminated.
 424              	.LVL46:
 250:../lib/io_driver.c **** //	unsigned long _cmsr = get_cmsr();
 251:../lib/io_driver.c **** //	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));
 252:../lib/io_driver.c **** 
 253:../lib/io_driver.c **** 		SPI0_SCSR = SPI0_SCSR | (1<<device);
 425              		.loc 1 253 0
 426 01bc E3E03A0F 		mvn	r3, #61440
 427 01c0 E5132FC7 		ldr	r2, [r3, #-4039]
 428 01c4 E3A01001 		mov	r1, #1
 429 01c8 E1820011 		orr	r0, r2, r1, asl r0
 430              	.LVL47:
 431 01cc E5030FC7 		str	r0, [r3, #-4039]
 432 01d0 E12FFF1E 		bx	lr
 433              		.cfi_endproc
 434              	.LFE13:
 436              		.align	2
 437              		.global	io_spi0_disable
 439              	io_spi0_disable:
 440              	.LFB14:
 254:../lib/io_driver.c **** 
 255:../lib/io_driver.c **** //	set_cmsr(_cmsr);
 256:../lib/io_driver.c **** }
 257:../lib/io_driver.c **** 
 258:../lib/io_driver.c **** // ******************************************************************************
 259:../lib/io_driver.c **** // Controls the CS of SPI0, disables a connected CS (turns it HIGH)
 260:../lib/io_driver.c ****    void io_spi0_disable(unsigned char device)
 261:../lib/io_driver.c **** // ******************************************************************************
 262:../lib/io_driver.c **** {
 441              		.loc 1 262 0
 442              		.cfi_startproc
 443              		@ Function supports interworking.
 444              		@ args = 0, pretend = 0, frame = 0
 445              		@ frame_needed = 0, uses_anonymous_args = 0
 446              		@ link register save eliminated.
 447              	.LVL48:
 263:../lib/io_driver.c **** //	unsigned long _cmsr = get_cmsr();
 264:../lib/io_driver.c **** //	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));
 265:../lib/io_driver.c **** 
 266:../lib/io_driver.c **** 		SPI0_SCSR = SPI0_SCSR & ~(1<<device);
 448              		.loc 1 266 0
 449 01d4 E3E03A0F 		mvn	r3, #61440
 450 01d8 E5132FC7 		ldr	r2, [r3, #-4039]
 451 01dc E3A01001 		mov	r1, #1
 452 01e0 E1C20011 		bic	r0, r2, r1, asl r0
 453              	.LVL49:
 454 01e4 E5030FC7 		str	r0, [r3, #-4039]
 455 01e8 E12FFF1E 		bx	lr
 456              		.cfi_endproc
 457              	.LFE14:
 459              		.align	2
 460              		.global	io_i2c0_speed
 462              	io_i2c0_speed:
 463              	.LFB15:
 267:../lib/io_driver.c **** 
 268:../lib/io_driver.c **** //	set_cmsr(_cmsr);
 269:../lib/io_driver.c **** }
 270:../lib/io_driver.c **** 
 271:../lib/io_driver.c **** 
 272:../lib/io_driver.c **** 
 273:../lib/io_driver.c **** 
 274:../lib/io_driver.c **** // ################################################################################################
 275:../lib/io_driver.c **** // Inter Intergrated Circuit Interface (I²C_CONTROLLER_0)
 276:../lib/io_driver.c **** // ################################################################################################
 277:../lib/io_driver.c **** 
 278:../lib/io_driver.c **** // ******************************************************************************
 279:../lib/io_driver.c **** // Configure SPI 0 CLK frequency -> (sys_clk/(5*i2c_clock)-1
 280:../lib/io_driver.c ****    void io_i2c0_speed(unsigned long clk_divider)
 281:../lib/io_driver.c **** // ******************************************************************************
 282:../lib/io_driver.c **** {
 464              		.loc 1 282 0
 465              		.cfi_startproc
 466              		@ Function supports interworking.
 467              		@ args = 0, pretend = 0, frame = 0
 468              		@ frame_needed = 0, uses_anonymous_args = 0
 469              		@ link register save eliminated.
 470              	.LVL50:
 283:../lib/io_driver.c **** //	unsigned long _cmsr = get_cmsr();
 284:../lib/io_driver.c **** //	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));
 285:../lib/io_driver.c **** 		I2C0_CTRL = I2C0_CTRL & ~(1<<I2C_EN); // disable i2c core
 471              		.loc 1 285 0
 472 01ec E3E03A0F 		mvn	r3, #61440
 473 01f0 E5132F97 		ldr	r2, [r3, #-3991]
 286:../lib/io_driver.c **** 		I2C0_PRLO = clk_divider;
 287:../lib/io_driver.c **** 		I2C0_PRHI = clk_divider >> 8;
 474              		.loc 1 287 0
 475 01f4 E1A01420 		mov	r1, r0, lsr #8
 285:../lib/io_driver.c **** 		I2C0_CTRL = I2C0_CTRL & ~(1<<I2C_EN); // disable i2c core
 476              		.loc 1 285 0
 477 01f8 E3C22080 		bic	r2, r2, #128
 478 01fc E5032F97 		str	r2, [r3, #-3991]
 286:../lib/io_driver.c **** 		I2C0_PRLO = clk_divider;
 479              		.loc 1 286 0
 480 0200 E5030F9F 		str	r0, [r3, #-3999]
 481              		.loc 1 287 0
 482 0204 E5031F9B 		str	r1, [r3, #-3995]
 288:../lib/io_driver.c **** 		I2C0_CTRL = I2C0_CTRL | (1<<I2C_EN); // enable i2c core
 483              		.loc 1 288 0
 484 0208 E5132F97 		ldr	r2, [r3, #-3991]
 485 020c E3822080 		orr	r2, r2, #128
 486 0210 E5032F97 		str	r2, [r3, #-3991]
 487 0214 E12FFF1E 		bx	lr
 488              		.cfi_endproc
 489              	.LFE15:
 491              		.align	2
 492              		.global	io_i2c0_byte_transfer
 494              	io_i2c0_byte_transfer:
 495              	.LFB16:
 289:../lib/io_driver.c **** //	set_cmsr(_cmsr);
 290:../lib/io_driver.c **** }
 291:../lib/io_driver.c **** 
 292:../lib/io_driver.c **** // ******************************************************************************
 293:../lib/io_driver.c **** // Read/write byte from/to I²C slave, max 2 address bytes
 294:../lib/io_driver.c ****    int io_i2c0_byte_transfer(unsigned char rw,        // 'r' read / 'w' write cycle
 295:../lib/io_driver.c ****                              unsigned char id,        // device ID
 296:../lib/io_driver.c **** 							 unsigned long data_adr,  // data address
 297:../lib/io_driver.c **** 							 unsigned char adr_bytes, // number of adr bytes
 298:../lib/io_driver.c **** 							 unsigned char data)      // data byte
 299:../lib/io_driver.c **** // ******************************************************************************
 300:../lib/io_driver.c **** {
 496              		.loc 1 300 0
 497              		.cfi_startproc
 498              		@ Function supports interworking.
 499              		@ args = 4, pretend = 0, frame = 0
 500              		@ frame_needed = 0, uses_anonymous_args = 0
 501              		@ link register save eliminated.
 502              	.LVL51:
 503 0218 E92D00F0 		stmfd	sp!, {r4, r5, r6, r7}
 504              	.LCFI0:
 505              		.cfi_def_cfa_offset 16
 506              		.cfi_offset 4, -16
 507              		.cfi_offset 5, -12
 508              		.cfi_offset 6, -8
 509              		.cfi_offset 7, -4
 301:../lib/io_driver.c **** //	unsigned long _cmsr = get_cmsr();
 302:../lib/io_driver.c **** //	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));
 303:../lib/io_driver.c **** 
 304:../lib/io_driver.c **** 	// transfer slave identification address
 305:../lib/io_driver.c **** 	I2C0_DATA = id & 0xFE;                  // device id and write
 306:../lib/io_driver.c **** 	I2C0_CMD = (1<<I2C_STA) | (1<<I2C_WR);  // start condition and write cycle
 510              		.loc 1 306 0
 511 021c E3A0C090 		mov	ip, #144
 305:../lib/io_driver.c **** 	I2C0_DATA = id & 0xFE;                  // device id and write
 512              		.loc 1 305 0
 513 0220 E3E06A0F 		mvn	r6, #61440
 514 0224 E20140FE 		and	r4, r1, #254
 300:../lib/io_driver.c **** {
 515              		.loc 1 300 0
 516 0228 E5DD5013 		ldrb	r5, [sp, #19]	@ zero_extendqisi2
 305:../lib/io_driver.c **** 	I2C0_DATA = id & 0xFE;                  // device id and write
 517              		.loc 1 305 0
 518 022c E5064F93 		str	r4, [r6, #-3987]
 519              	.LVL52:
 520              		.loc 1 306 0
 521 0230 E506CFAF 		str	ip, [r6, #-4015]
 522              	.L39:
 307:../lib/io_driver.c **** 	while((I2C0_STAT & (1<<I2C_TIP)) != 0); // wait for transfer to finish
 523              		.loc 1 307 0 discriminator 1
 524 0234 E516CFAF 		ldr	ip, [r6, #-4015]
 525 0238 E31C0002 		tst	ip, #2
 526 023c E3E04A0F 		mvn	r4, #61440
 527 0240 1AFFFFFB 		bne	.L39
 308:../lib/io_driver.c **** 	if((I2C0_STAT & (1<<I2C_RXACK)) != 0){  // ack received?
 528              		.loc 1 308 0
 529 0244 E514CFAF 		ldr	ip, [r4, #-4015]
 530 0248 E31C0080 		tst	ip, #128
 531 024c 1A00003F 		bne	.L70
 309:../lib/io_driver.c **** //		set_cmsr(_cmsr);
 310:../lib/io_driver.c **** 		return -1;
 311:../lib/io_driver.c **** 	}
 312:../lib/io_driver.c **** 
 313:../lib/io_driver.c **** 	// transfer data address
 314:../lib/io_driver.c **** 	while(adr_bytes != 0){
 532              		.loc 1 314 0 discriminator 1
 533 0250 E3530000 		cmp	r3, #0
 315:../lib/io_driver.c **** 		adr_bytes--;
 316:../lib/io_driver.c **** 		if(adr_bytes == 1)
 317:../lib/io_driver.c **** 			I2C0_DATA = data_adr >> 8;          // high byte
 534              		.loc 1 317 0 discriminator 1
 535 0254 11A07422 		movne	r7, r2, lsr #8
 318:../lib/io_driver.c **** 		else
 319:../lib/io_driver.c **** 			I2C0_DATA = data_adr;               // low byte
 320:../lib/io_driver.c **** 		I2C0_CMD = (1<<I2C_WR);                 // write cycle
 536              		.loc 1 320 0 discriminator 1
 537 0258 13A06010 		movne	r6, #16
 314:../lib/io_driver.c **** 	while(adr_bytes != 0){
 538              		.loc 1 314 0 discriminator 1
 539 025c 0A00000E 		beq	.L50
 540              	.LVL53:
 541              	.L51:
 315:../lib/io_driver.c **** 		adr_bytes--;
 542              		.loc 1 315 0
 543 0260 E2433001 		sub	r3, r3, #1
 544              	.LVL54:
 545 0264 E20330FF 		and	r3, r3, #255
 546              	.LVL55:
 316:../lib/io_driver.c **** 		if(adr_bytes == 1)
 547              		.loc 1 316 0
 548 0268 E3530001 		cmp	r3, #1
 317:../lib/io_driver.c **** 			I2C0_DATA = data_adr >> 8;          // high byte
 549              		.loc 1 317 0
 550 026c 05047F93 		streq	r7, [r4, #-3987]
 319:../lib/io_driver.c **** 			I2C0_DATA = data_adr;               // low byte
 551              		.loc 1 319 0
 552 0270 15042F93 		strne	r2, [r4, #-3987]
 553              		.loc 1 320 0
 554 0274 E5046FAF 		str	r6, [r4, #-4015]
 555              	.L45:
 321:../lib/io_driver.c **** 		while((I2C0_STAT & (1<<I2C_TIP)) != 0); // wait for transfer to finish
 556              		.loc 1 321 0 discriminator 1
 557 0278 E514CFAF 		ldr	ip, [r4, #-4015]
 558 027c E31C0002 		tst	ip, #2
 559 0280 E3E0CA0F 		mvn	ip, #61440
 560 0284 1AFFFFFB 		bne	.L45
 322:../lib/io_driver.c **** 		if((I2C0_STAT & (1<<I2C_RXACK)) != 0){  // ack received?
 561              		.loc 1 322 0
 562 0288 E51CCFAF 		ldr	ip, [ip, #-4015]
 563 028c E31C0080 		tst	ip, #128
 564 0290 1A00001B 		bne	.L71
 314:../lib/io_driver.c **** 	while(adr_bytes != 0){
 565              		.loc 1 314 0 discriminator 1
 566 0294 E3530000 		cmp	r3, #0
 567 0298 1AFFFFF0 		bne	.L51
 568              	.LVL56:
 569              	.L50:
 570              	.LBB350:
 571              	.LBB351:
 323:../lib/io_driver.c **** //			set_cmsr(_cmsr);
 324:../lib/io_driver.c **** 			return -2;
 325:../lib/io_driver.c **** 		}
 326:../lib/io_driver.c **** 	}
 327:../lib/io_driver.c **** 
 328:../lib/io_driver.c **** 	if(rw == 'w'){
 572              		.loc 1 328 0
 573 029c E3500077 		cmp	r0, #119
 574 02a0 0A00001A 		beq	.L72
 329:../lib/io_driver.c **** 		// write adressed byte
 330:../lib/io_driver.c **** 		I2C0_DATA = data;                       // send data
 331:../lib/io_driver.c **** 		I2C0_CMD = (1<<I2C_STO) | (1<<I2C_WR);  // stop condition and write cycle
 332:../lib/io_driver.c **** 		while((I2C0_STAT & (1<<I2C_TIP)) != 0); // wait for transfer to finish
 333:../lib/io_driver.c **** 		if((I2C0_STAT & (1<<I2C_RXACK)) != 0){  // ack received?
 334:../lib/io_driver.c **** //			set_cmsr(_cmsr);
 335:../lib/io_driver.c **** 			return -3;
 336:../lib/io_driver.c **** 		}
 337:../lib/io_driver.c **** 		else{
 338:../lib/io_driver.c **** //			set_cmsr(_cmsr);
 339:../lib/io_driver.c **** 			return 0;
 340:../lib/io_driver.c **** 		}
 341:../lib/io_driver.c **** 	}
 342:../lib/io_driver.c **** 
 343:../lib/io_driver.c **** 	if(rw == 'r'){
 575              		.loc 1 343 0
 576 02a4 E3500072 		cmp	r0, #114
 577 02a8 1A000026 		bne	.L63
 344:../lib/io_driver.c **** 		// re-send control byte - this time with read-bit
 345:../lib/io_driver.c **** 		I2C0_DATA = id | 0x01;                  // device id and READ
 578              		.loc 1 345 0
 579 02ac E3E02A0F 		mvn	r2, #61440
 580              	.LVL57:
 581 02b0 E3811001 		orr	r1, r1, #1
 582              	.LVL58:
 346:../lib/io_driver.c **** 		I2C0_CMD = (1<<I2C_STA) | (1<<I2C_WR);  // start condition and write cycle
 583              		.loc 1 346 0
 584 02b4 E3A03090 		mov	r3, #144
 585              	.LVL59:
 345:../lib/io_driver.c **** 		I2C0_DATA = id | 0x01;                  // device id and READ
 586              		.loc 1 345 0
 587 02b8 E5021F93 		str	r1, [r2, #-3987]
 588              		.loc 1 346 0
 589 02bc E5023FAF 		str	r3, [r2, #-4015]
 590              	.L56:
 347:../lib/io_driver.c **** 		while((I2C0_STAT & (1<<I2C_TIP)) != 0); // wait for transfer to finish
 591              		.loc 1 347 0
 592 02c0 E5123FAF 		ldr	r3, [r2, #-4015]
 593 02c4 E3130002 		tst	r3, #2
 594 02c8 E3E03A0F 		mvn	r3, #61440
 595 02cc 1AFFFFFB 		bne	.L56
 348:../lib/io_driver.c **** 		if((I2C0_STAT & (1<<I2C_RXACK)) != 0){  // ack received?
 596              		.loc 1 348 0
 597 02d0 E5132FAF 		ldr	r2, [r3, #-4015]
 598 02d4 E3120080 		tst	r2, #128
 599 02d8 1A000018 		bne	.L57
 349:../lib/io_driver.c **** //			set_cmsr(_cmsr);
 350:../lib/io_driver.c **** 			return -3;
 351:../lib/io_driver.c **** 		}
 352:../lib/io_driver.c **** 		// read adressed byte
 353:../lib/io_driver.c **** 		I2C0_CMD = (1<<I2C_STO) | (1<<I2C_RD) | (1<<I2C_ACK);
 600              		.loc 1 353 0
 601 02dc E3A02068 		mov	r2, #104
 602 02e0 E5032FAF 		str	r2, [r3, #-4015]
 354:../lib/io_driver.c **** 		while((I2C0_STAT & (1<<I2C_TIP)) != 0); // wait for transfer to finish
 603              		.loc 1 354 0
 604 02e4 E1A01003 		mov	r1, r3
 605              	.L59:
 606 02e8 E5113FAF 		ldr	r3, [r1, #-4015]
 607 02ec E3130002 		tst	r3, #2
 608 02f0 E3E02A0F 		mvn	r2, #61440
 609 02f4 1AFFFFFB 		bne	.L59
 355:../lib/io_driver.c **** 		return I2C0_DATA;
 610              		.loc 1 355 0
 611 02f8 E5120F93 		ldr	r0, [r2, #-3987]
 612              	.LVL60:
 613              	.L40:
 614              	.LBE351:
 615              	.LBE350:
 356:../lib/io_driver.c **** 	}
 357:../lib/io_driver.c **** 
 358:../lib/io_driver.c **** //	set_cmsr(_cmsr);
 359:../lib/io_driver.c **** 	return -4;
 360:../lib/io_driver.c **** }
 616              		.loc 1 360 0
 617 02fc E8BD00F0 		ldmfd	sp!, {r4, r5, r6, r7}
 618 0300 E12FFF1E 		bx	lr
 619              	.LVL61:
 620              	.L71:
 324:../lib/io_driver.c **** 			return -2;
 621              		.loc 1 324 0
 622 0304 E3E00001 		mvn	r0, #1
 623              	.LVL62:
 624              		.loc 1 360 0
 625 0308 E8BD00F0 		ldmfd	sp!, {r4, r5, r6, r7}
 626 030c E12FFF1E 		bx	lr
 627              	.LVL63:
 628              	.L72:
 629              	.LBB353:
 630              	.LBB352:
 330:../lib/io_driver.c **** 		I2C0_DATA = data;                       // send data
 631              		.loc 1 330 0
 632 0310 E3E02A0F 		mvn	r2, #61440
 633              	.LVL64:
 331:../lib/io_driver.c **** 		I2C0_CMD = (1<<I2C_STO) | (1<<I2C_WR);  // stop condition and write cycle
 634              		.loc 1 331 0
 635 0314 E3A03050 		mov	r3, #80
 636              	.LVL65:
 330:../lib/io_driver.c **** 		I2C0_DATA = data;                       // send data
 637              		.loc 1 330 0
 638 0318 E5025F93 		str	r5, [r2, #-3987]
 331:../lib/io_driver.c **** 		I2C0_CMD = (1<<I2C_STO) | (1<<I2C_WR);  // stop condition and write cycle
 639              		.loc 1 331 0
 640 031c E5023FAF 		str	r3, [r2, #-4015]
 641              	.L53:
 332:../lib/io_driver.c **** 		while((I2C0_STAT & (1<<I2C_TIP)) != 0); // wait for transfer to finish
 642              		.loc 1 332 0
 643 0320 E5123FAF 		ldr	r3, [r2, #-4015]
 644 0324 E3130002 		tst	r3, #2
 645 0328 E3E03A0F 		mvn	r3, #61440
 646 032c 1AFFFFFB 		bne	.L53
 333:../lib/io_driver.c **** 		if((I2C0_STAT & (1<<I2C_RXACK)) != 0){  // ack received?
 647              		.loc 1 333 0
 648 0330 E5133FAF 		ldr	r3, [r3, #-4015]
 649 0334 E2133080 		ands	r3, r3, #128
 339:../lib/io_driver.c **** 			return 0;
 650              		.loc 1 339 0
 651 0338 01A00003 		moveq	r0, r3
 652              	.LVL66:
 333:../lib/io_driver.c **** 		if((I2C0_STAT & (1<<I2C_RXACK)) != 0){  // ack received?
 653              		.loc 1 333 0
 654 033c 0AFFFFEE 		beq	.L40
 655              	.LVL67:
 656              	.L57:
 335:../lib/io_driver.c **** 			return -3;
 657              		.loc 1 335 0
 658 0340 E3E00002 		mvn	r0, #2
 659 0344 EAFFFFEC 		b	.L40
 660              	.LVL68:
 661              	.L63:
 359:../lib/io_driver.c **** 	return -4;
 662              		.loc 1 359 0
 663 0348 E3E00003 		mvn	r0, #3
 664              	.LVL69:
 665 034c EAFFFFEA 		b	.L40
 666              	.LVL70:
 667              	.L70:
 668              	.LBE352:
 669              	.LBE353:
 310:../lib/io_driver.c **** 		return -1;
 670              		.loc 1 310 0
 671 0350 E3E00000 		mvn	r0, #0
 672              	.LVL71:
 673 0354 EAFFFFE8 		b	.L40
 674              		.cfi_endproc
 675              	.LFE16:
 677              		.align	2
 678              		.global	get_syscpreg
 680              	get_syscpreg:
 681              	.LFB17:
 361:../lib/io_driver.c **** 
 362:../lib/io_driver.c **** 
 363:../lib/io_driver.c **** 
 364:../lib/io_driver.c **** 
 365:../lib/io_driver.c **** // ################################################################################################
 366:../lib/io_driver.c **** // System
 367:../lib/io_driver.c **** // ################################################################################################
 368:../lib/io_driver.c **** 
 369:../lib/io_driver.c **** // ******************************************************************************
 370:../lib/io_driver.c **** // read system coprocessor register x
 371:../lib/io_driver.c ****    unsigned long get_syscpreg(unsigned char index)
 372:../lib/io_driver.c **** // ******************************************************************************
 373:../lib/io_driver.c **** {
 682              		.loc 1 373 0
 683              		.cfi_startproc
 684              		@ Function supports interworking.
 685              		@ args = 0, pretend = 0, frame = 0
 686              		@ frame_needed = 0, uses_anonymous_args = 0
 687              		@ link register save eliminated.
 688              	.LVL72:
 374:../lib/io_driver.c **** 	unsigned long _cp_val;
 375:../lib/io_driver.c **** 	switch(index){
 689              		.loc 1 375 0
 690 0358 E350000F 		cmp	r0, #15
 691 035c 979FF100 		ldrls	pc, [pc, r0, asl #2]
 692 0360 EA00002F 		b	.L92
 693              	.L76:
 694 0364 000003AC 		.word	.L75
 695 0368 000003B4 		.word	.L77
 696 036c 000003BC 		.word	.L78
 697 0370 000003C4 		.word	.L79
 698 0374 000003CC 		.word	.L80
 699 0378 000003D4 		.word	.L81
 700 037c 000003DC 		.word	.L82
 701 0380 000003E4 		.word	.L83
 702 0384 000003EC 		.word	.L84
 703 0388 000003F4 		.word	.L85
 704 038c 000003FC 		.word	.L86
 705 0390 00000404 		.word	.L87
 706 0394 0000040C 		.word	.L88
 707 0398 00000414 		.word	.L89
 708 039c 0000041C 		.word	.L90
 709 03a0 000003A4 		.word	.L91
 710              	.L91:
 376:../lib/io_driver.c **** 		case ID_REG_0:   asm volatile ("mrc p15,0,%0, c0, c0" : "=r" (_cp_val) : /* no inputs */  ); brea
 377:../lib/io_driver.c **** 		case ID_REG_1:   asm volatile ("mrc p15,0,%0, c1, c1" : "=r" (_cp_val) : /* no inputs */  ); brea
 378:../lib/io_driver.c **** 		case ID_REG_2:   asm volatile ("mrc p15,0,%0, c2, c2" : "=r" (_cp_val) : /* no inputs */  ); brea
 379:../lib/io_driver.c **** 		case 3:          asm volatile ("mrc p15,0,%0, c3, c3" : "=r" (_cp_val) : /* no inputs */  ); brea
 380:../lib/io_driver.c **** 		case 4:          asm volatile ("mrc p15,0,%0, c4, c4" : "=r" (_cp_val) : /* no inputs */  ); brea
 381:../lib/io_driver.c **** 		case 5:          asm volatile ("mrc p15,0,%0, c5, c5" : "=r" (_cp_val) : /* no inputs */  ); brea
 382:../lib/io_driver.c **** 		case SYS_CTRL_0: asm volatile ("mrc p15,0,%0, c6, c6" : "=r" (_cp_val) : /* no inputs */  ); brea
 383:../lib/io_driver.c **** 		case 7:          asm volatile ("mrc p15,0,%0, c7, c7" : "=r" (_cp_val) : /* no inputs */  ); brea
 384:../lib/io_driver.c **** 		case CSTAT:      asm volatile ("mrc p15,0,%0, c8, c8" : "=r" (_cp_val) : /* no inputs */  ); brea
 385:../lib/io_driver.c **** 		case ADR_FB:     asm volatile ("mrc p15,0,%0, c9, c9" : "=r" (_cp_val) : /* no inputs */  ); brea
 386:../lib/io_driver.c **** 		case 10:         asm volatile ("mrc p15,0,%0,c10,c10" : "=r" (_cp_val) : /* no inputs */  ); brea
 387:../lib/io_driver.c **** 		case LFSR_POLY:  asm volatile ("mrc p15,0,%0,c11,c11" : "=r" (_cp_val) : /* no inputs */  ); brea
 388:../lib/io_driver.c **** 		case LFSR_DATA:  asm volatile ("mrc p15,0,%0,c12,c12" : "=r" (_cp_val) : /* no inputs */  ); brea
 389:../lib/io_driver.c **** 		case SYS_IO:     asm volatile ("mrc p15,0,%0,c13,c13" : "=r" (_cp_val) : /* no inputs */  ); brea
 390:../lib/io_driver.c **** 		case 14:         asm volatile ("mrc p15,0,%0,c14,c14" : "=r" (_cp_val) : /* no inputs */  ); brea
 391:../lib/io_driver.c **** 		case 15:         asm volatile ("mrc p15,0,%0,c15,c15" : "=r" (_cp_val) : /* no inputs */  ); brea
 711              		.loc 1 391 0
 712              	@ 391 "../lib/io_driver.c" 1
 713 03a4 EE1F0F1F 		mrc p15,0,r0,c15,c15
 714              	@ 0 "" 2
 715              	.LVL73:
 716 03a8 E12FFF1E 		bx	lr
 717              	.LVL74:
 718              	.L75:
 376:../lib/io_driver.c **** 		case ID_REG_0:   asm volatile ("mrc p15,0,%0, c0, c0" : "=r" (_cp_val) : /* no inputs */  ); brea
 719              		.loc 1 376 0
 720              	@ 376 "../lib/io_driver.c" 1
 721 03ac EE100F10 		mrc p15,0,r0, c0, c0
 722              	@ 0 "" 2
 723              	.LVL75:
 724 03b0 E12FFF1E 		bx	lr
 725              	.LVL76:
 726              	.L77:
 377:../lib/io_driver.c **** 		case ID_REG_1:   asm volatile ("mrc p15,0,%0, c1, c1" : "=r" (_cp_val) : /* no inputs */  ); brea
 727              		.loc 1 377 0
 728              	@ 377 "../lib/io_driver.c" 1
 729 03b4 EE110F11 		mrc p15,0,r0, c1, c1
 730              	@ 0 "" 2
 731              	.LVL77:
 732 03b8 E12FFF1E 		bx	lr
 733              	.LVL78:
 734              	.L78:
 378:../lib/io_driver.c **** 		case ID_REG_2:   asm volatile ("mrc p15,0,%0, c2, c2" : "=r" (_cp_val) : /* no inputs */  ); brea
 735              		.loc 1 378 0
 736              	@ 378 "../lib/io_driver.c" 1
 737 03bc EE120F12 		mrc p15,0,r0, c2, c2
 738              	@ 0 "" 2
 739              	.LVL79:
 740 03c0 E12FFF1E 		bx	lr
 741              	.LVL80:
 742              	.L79:
 379:../lib/io_driver.c **** 		case 3:          asm volatile ("mrc p15,0,%0, c3, c3" : "=r" (_cp_val) : /* no inputs */  ); brea
 743              		.loc 1 379 0
 744              	@ 379 "../lib/io_driver.c" 1
 745 03c4 EE130F13 		mrc p15,0,r0, c3, c3
 746              	@ 0 "" 2
 747              	.LVL81:
 748 03c8 E12FFF1E 		bx	lr
 749              	.LVL82:
 750              	.L80:
 380:../lib/io_driver.c **** 		case 4:          asm volatile ("mrc p15,0,%0, c4, c4" : "=r" (_cp_val) : /* no inputs */  ); brea
 751              		.loc 1 380 0
 752              	@ 380 "../lib/io_driver.c" 1
 753 03cc EE140F14 		mrc p15,0,r0, c4, c4
 754              	@ 0 "" 2
 755              	.LVL83:
 756 03d0 E12FFF1E 		bx	lr
 757              	.LVL84:
 758              	.L81:
 381:../lib/io_driver.c **** 		case 5:          asm volatile ("mrc p15,0,%0, c5, c5" : "=r" (_cp_val) : /* no inputs */  ); brea
 759              		.loc 1 381 0
 760              	@ 381 "../lib/io_driver.c" 1
 761 03d4 EE150F15 		mrc p15,0,r0, c5, c5
 762              	@ 0 "" 2
 763              	.LVL85:
 764 03d8 E12FFF1E 		bx	lr
 765              	.LVL86:
 766              	.L82:
 382:../lib/io_driver.c **** 		case SYS_CTRL_0: asm volatile ("mrc p15,0,%0, c6, c6" : "=r" (_cp_val) : /* no inputs */  ); brea
 767              		.loc 1 382 0
 768              	@ 382 "../lib/io_driver.c" 1
 769 03dc EE160F16 		mrc p15,0,r0, c6, c6
 770              	@ 0 "" 2
 771              	.LVL87:
 772 03e0 E12FFF1E 		bx	lr
 773              	.LVL88:
 774              	.L83:
 383:../lib/io_driver.c **** 		case 7:          asm volatile ("mrc p15,0,%0, c7, c7" : "=r" (_cp_val) : /* no inputs */  ); brea
 775              		.loc 1 383 0
 776              	@ 383 "../lib/io_driver.c" 1
 777 03e4 EE170F17 		mrc p15,0,r0, c7, c7
 778              	@ 0 "" 2
 779              	.LVL89:
 780 03e8 E12FFF1E 		bx	lr
 781              	.LVL90:
 782              	.L84:
 384:../lib/io_driver.c **** 		case CSTAT:      asm volatile ("mrc p15,0,%0, c8, c8" : "=r" (_cp_val) : /* no inputs */  ); brea
 783              		.loc 1 384 0
 784              	@ 384 "../lib/io_driver.c" 1
 785 03ec EE180F18 		mrc p15,0,r0, c8, c8
 786              	@ 0 "" 2
 787              	.LVL91:
 788 03f0 E12FFF1E 		bx	lr
 789              	.LVL92:
 790              	.L85:
 385:../lib/io_driver.c **** 		case ADR_FB:     asm volatile ("mrc p15,0,%0, c9, c9" : "=r" (_cp_val) : /* no inputs */  ); brea
 791              		.loc 1 385 0
 792              	@ 385 "../lib/io_driver.c" 1
 793 03f4 EE190F19 		mrc p15,0,r0, c9, c9
 794              	@ 0 "" 2
 795              	.LVL93:
 796 03f8 E12FFF1E 		bx	lr
 797              	.LVL94:
 798              	.L86:
 386:../lib/io_driver.c **** 		case 10:         asm volatile ("mrc p15,0,%0,c10,c10" : "=r" (_cp_val) : /* no inputs */  ); brea
 799              		.loc 1 386 0
 800              	@ 386 "../lib/io_driver.c" 1
 801 03fc EE1A0F1A 		mrc p15,0,r0,c10,c10
 802              	@ 0 "" 2
 803              	.LVL95:
 804 0400 E12FFF1E 		bx	lr
 805              	.LVL96:
 806              	.L87:
 387:../lib/io_driver.c **** 		case LFSR_POLY:  asm volatile ("mrc p15,0,%0,c11,c11" : "=r" (_cp_val) : /* no inputs */  ); brea
 807              		.loc 1 387 0
 808              	@ 387 "../lib/io_driver.c" 1
 809 0404 EE1B0F1B 		mrc p15,0,r0,c11,c11
 810              	@ 0 "" 2
 811              	.LVL97:
 812 0408 E12FFF1E 		bx	lr
 813              	.LVL98:
 814              	.L88:
 388:../lib/io_driver.c **** 		case LFSR_DATA:  asm volatile ("mrc p15,0,%0,c12,c12" : "=r" (_cp_val) : /* no inputs */  ); brea
 815              		.loc 1 388 0
 816              	@ 388 "../lib/io_driver.c" 1
 817 040c EE1C0F1C 		mrc p15,0,r0,c12,c12
 818              	@ 0 "" 2
 819              	.LVL99:
 820 0410 E12FFF1E 		bx	lr
 821              	.LVL100:
 822              	.L89:
 389:../lib/io_driver.c **** 		case SYS_IO:     asm volatile ("mrc p15,0,%0,c13,c13" : "=r" (_cp_val) : /* no inputs */  ); brea
 823              		.loc 1 389 0
 824              	@ 389 "../lib/io_driver.c" 1
 825 0414 EE1D0F1D 		mrc p15,0,r0,c13,c13
 826              	@ 0 "" 2
 827              	.LVL101:
 828 0418 E12FFF1E 		bx	lr
 829              	.LVL102:
 830              	.L90:
 390:../lib/io_driver.c **** 		case 14:         asm volatile ("mrc p15,0,%0,c14,c14" : "=r" (_cp_val) : /* no inputs */  ); brea
 831              		.loc 1 390 0
 832              	@ 390 "../lib/io_driver.c" 1
 833 041c EE1E0F1E 		mrc p15,0,r0,c14,c14
 834              	@ 0 "" 2
 835              	.LVL103:
 836 0420 E12FFF1E 		bx	lr
 837              	.LVL104:
 838              	.L92:
 392:../lib/io_driver.c **** 		default:         _cp_val = 0; break;
 839              		.loc 1 392 0
 840 0424 E3A00000 		mov	r0, #0
 841              	.LVL105:
 393:../lib/io_driver.c **** 	}
 394:../lib/io_driver.c **** 	return _cp_val;
 395:../lib/io_driver.c **** }
 842              		.loc 1 395 0
 843 0428 E12FFF1E 		bx	lr
 844              		.cfi_endproc
 845              	.LFE17:
 847              		.align	2
 848              		.global	set_syscpreg
 850              	set_syscpreg:
 851              	.LFB18:
 396:../lib/io_driver.c **** 
 397:../lib/io_driver.c **** // ******************************************************************************
 398:../lib/io_driver.c **** // write system coprocessor register x
 399:../lib/io_driver.c ****    void set_syscpreg(unsigned long _cp_val, unsigned char index)
 400:../lib/io_driver.c **** // ******************************************************************************
 401:../lib/io_driver.c **** {
 852              		.loc 1 401 0
 853              		.cfi_startproc
 854              		@ Function supports interworking.
 855              		@ args = 0, pretend = 0, frame = 0
 856              		@ frame_needed = 0, uses_anonymous_args = 0
 857              		@ link register save eliminated.
 858              	.LVL106:
 402:../lib/io_driver.c **** 	switch(index){
 859              		.loc 1 402 0
 860 042c E2411006 		sub	r1, r1, #6
 861              	.LVL107:
 862 0430 E3510007 		cmp	r1, #7
 863 0434 979FF101 		ldrls	pc, [pc, r1, asl #2]
 864 0438 EA000008 		b	.L93
 865              	.L96:
 866 043c 00000474 		.word	.L95
 867 0440 00000460 		.word	.L93
 868 0444 00000460 		.word	.L93
 869 0448 00000460 		.word	.L93
 870 044c 00000460 		.word	.L93
 871 0450 0000046C 		.word	.L97
 872 0454 00000464 		.word	.L98
 873 0458 0000045C 		.word	.L99
 874              	.L99:
 403:../lib/io_driver.c **** //		case ID_REG_0:   asm volatile ("mcr p15,0,%0, c0, c0,0" : /* no outputs */ : "r" (_cp_val)); br
 404:../lib/io_driver.c **** //		case ID_REG_1:   asm volatile ("mcr p15,0,%0, c1, c1,0" : /* no outputs */ : "r" (_cp_val)); br
 405:../lib/io_driver.c **** //		case ID_REG_2:   asm volatile ("mcr p15,0,%0, c2, c2,0" : /* no outputs */ : "r" (_cp_val)); br
 406:../lib/io_driver.c **** //		case 3:          asm volatile ("mcr p15,0,%0, c3, c3,0" : /* no outputs */ : "r" (_cp_val)); br
 407:../lib/io_driver.c **** //		case 4:          asm volatile ("mcr p15,0,%0, c4, c4,0" : /* no outputs */ : "r" (_cp_val)); br
 408:../lib/io_driver.c **** //		case 5:          asm volatile ("mcr p15,0,%0, c5, c5,0" : /* no outputs */ : "r" (_cp_val)); br
 409:../lib/io_driver.c **** 		case SYS_CTRL_0: asm volatile ("mcr p15,0,%0, c6, c6,0" : /* no outputs */ : "r" (_cp_val)); brea
 410:../lib/io_driver.c **** //		case 7:          asm volatile ("mcr p15,0,%0, c7, c7,0" : /* no outputs */ : "r" (_cp_val)); br
 411:../lib/io_driver.c **** //		case CSTAT:      asm volatile ("mcr p15,0,%0, c8, c8,0" : /* no outputs */ : "r" (_cp_val)); br
 412:../lib/io_driver.c **** //		case ADR_FB:     asm volatile ("mcr p15,0,%0, c9, c9,0" : /* no outputs */ : "r" (_cp_val)); br
 413:../lib/io_driver.c **** //		case 10:         asm volatile ("mcr p15,0,%0,c10,c10,0" : /* no outputs */ : "r" (_cp_val)); br
 414:../lib/io_driver.c **** 		case LFSR_POLY:  asm volatile ("mcr p15,0,%0,c11,c11,0" : /* no outputs */ : "r" (_cp_val)); brea
 415:../lib/io_driver.c **** 		case LFSR_DATA:  asm volatile ("mcr p15,0,%0,c12,c12,0" : /* no outputs */ : "r" (_cp_val)); brea
 416:../lib/io_driver.c **** 		case SYS_IO:     asm volatile ("mcr p15,0,%0,c13,c13,0" : /* no outputs */ : "r" (_cp_val)); brea
 875              		.loc 1 416 0
 876              	@ 416 "../lib/io_driver.c" 1
 877 045c EE0D0F1D 		mcr p15,0,r0,c13,c13,0
 878              	@ 0 "" 2
 879              	.L93:
 880 0460 E12FFF1E 		bx	lr
 881              	.L98:
 415:../lib/io_driver.c **** 		case LFSR_DATA:  asm volatile ("mcr p15,0,%0,c12,c12,0" : /* no outputs */ : "r" (_cp_val)); brea
 882              		.loc 1 415 0
 883              	@ 415 "../lib/io_driver.c" 1
 884 0464 EE0C0F1C 		mcr p15,0,r0,c12,c12,0
 885              	@ 0 "" 2
 886 0468 E12FFF1E 		bx	lr
 887              	.L97:
 414:../lib/io_driver.c **** 		case LFSR_POLY:  asm volatile ("mcr p15,0,%0,c11,c11,0" : /* no outputs */ : "r" (_cp_val)); brea
 888              		.loc 1 414 0
 889              	@ 414 "../lib/io_driver.c" 1
 890 046c EE0B0F1B 		mcr p15,0,r0,c11,c11,0
 891              	@ 0 "" 2
 892 0470 E12FFF1E 		bx	lr
 893              	.L95:
 409:../lib/io_driver.c **** 		case SYS_CTRL_0: asm volatile ("mcr p15,0,%0, c6, c6,0" : /* no outputs */ : "r" (_cp_val)); brea
 894              		.loc 1 409 0
 895              	@ 409 "../lib/io_driver.c" 1
 896 0474 EE060F16 		mcr p15,0,r0, c6, c6,0
 897              	@ 0 "" 2
 898 0478 E12FFF1E 		bx	lr
 899              		.cfi_endproc
 900              	.LFE18:
 902              		.align	2
 903              		.global	io_enable_xint
 905              	io_enable_xint:
 906              	.LFB21:
 417:../lib/io_driver.c **** //		case 14:         asm volatile ("mcr p15,0,%0,c14,c14,0" : /* no outputs */ : "r" (_cp_val)); br
 418:../lib/io_driver.c **** //		case 15:         asm volatile ("mcr p15,0,%0,c15,c15,0" : /* no outputs */ : "r" (_cp_val)); br
 419:../lib/io_driver.c **** 		default:         break;
 420:../lib/io_driver.c **** 	}
 421:../lib/io_driver.c **** }
 422:../lib/io_driver.c **** // ******************************************************************************
 423:../lib/io_driver.c **** // read CMSR value
 424:../lib/io_driver.c ****    static inline unsigned long get_cmsr(void)
 425:../lib/io_driver.c **** // ******************************************************************************
 426:../lib/io_driver.c **** {
 427:../lib/io_driver.c **** 	unsigned long _cmsr;
 428:../lib/io_driver.c **** 	asm volatile (" mrs %0, cpsr" : "=r" (_cmsr) : /* no inputs */  );
 429:../lib/io_driver.c **** 	return _cmsr;
 430:../lib/io_driver.c **** }
 431:../lib/io_driver.c **** 
 432:../lib/io_driver.c **** // ******************************************************************************
 433:../lib/io_driver.c **** // write CMSR value
 434:../lib/io_driver.c ****    static inline void set_cmsr(unsigned long _cmsr)
 435:../lib/io_driver.c **** // ******************************************************************************
 436:../lib/io_driver.c **** {
 437:../lib/io_driver.c **** 	asm volatile (" msr cpsr, %0" : /* no outputs */ : "r" (_cmsr)  );
 438:../lib/io_driver.c **** }
 439:../lib/io_driver.c **** 
 440:../lib/io_driver.c **** // ******************************************************************************
 441:../lib/io_driver.c **** // Enable all external INTs
 442:../lib/io_driver.c ****    void io_enable_xint(void)
 443:../lib/io_driver.c **** // ******************************************************************************
 444:../lib/io_driver.c **** {
 907              		.loc 1 444 0
 908              		.cfi_startproc
 909              		@ Function supports interworking.
 910              		@ args = 0, pretend = 0, frame = 0
 911              		@ frame_needed = 0, uses_anonymous_args = 0
 912              		@ link register save eliminated.
 913              	.LBB354:
 914              	.LBB355:
 428:../lib/io_driver.c **** 	asm volatile (" mrs %0, cpsr" : "=r" (_cmsr) : /* no inputs */  );
 915              		.loc 1 428 0
 916              	@ 428 "../lib/io_driver.c" 1
 917 047c E10F3000 		 mrs r3, cpsr
 918              	@ 0 "" 2
 919              	.LVL108:
 920              	.LBE355:
 921              	.LBE354:
 445:../lib/io_driver.c **** 	unsigned long _cmsr = get_cmsr();
 446:../lib/io_driver.c **** 	_cmsr = _cmsr & ~(1<<CMSR_FIQ) &~(1<<CMSR_IRQ);
 922              		.loc 1 446 0
 923 0480 E3C330C0 		bic	r3, r3, #192
 924              	.LVL109:
 925              	.LBB356:
 926              	.LBB357:
 437:../lib/io_driver.c **** 	asm volatile (" msr cpsr, %0" : /* no outputs */ : "r" (_cmsr)  );
 927              		.loc 1 437 0
 928              	@ 437 "../lib/io_driver.c" 1
 929 0484 E129F003 		 msr cpsr, r3
 930              	@ 0 "" 2
 931 0488 E12FFF1E 		bx	lr
 932              	.LBE357:
 933              	.LBE356:
 934              		.cfi_endproc
 935              	.LFE21:
 937              		.align	2
 938              		.global	io_disable_xint
 940              	io_disable_xint:
 941              	.LFB22:
 447:../lib/io_driver.c **** 	set_cmsr(_cmsr);
 448:../lib/io_driver.c **** }
 449:../lib/io_driver.c **** 
 450:../lib/io_driver.c **** // ******************************************************************************
 451:../lib/io_driver.c **** // Disable all global IBTs
 452:../lib/io_driver.c ****    void io_disable_xint(void)
 453:../lib/io_driver.c **** // ******************************************************************************
 454:../lib/io_driver.c **** {
 942              		.loc 1 454 0
 943              		.cfi_startproc
 944              		@ Function supports interworking.
 945              		@ args = 0, pretend = 0, frame = 0
 946              		@ frame_needed = 0, uses_anonymous_args = 0
 947              		@ link register save eliminated.
 948              	.LBB358:
 949              	.LBB359:
 428:../lib/io_driver.c **** 	asm volatile (" mrs %0, cpsr" : "=r" (_cmsr) : /* no inputs */  );
 950              		.loc 1 428 0
 951              	@ 428 "../lib/io_driver.c" 1
 952 048c E10F3000 		 mrs r3, cpsr
 953              	@ 0 "" 2
 954              	.LVL110:
 955              	.LBE359:
 956              	.LBE358:
 455:../lib/io_driver.c **** 	unsigned long _cmsr = get_cmsr();
 456:../lib/io_driver.c **** 	_cmsr = _cmsr | (1<<CMSR_FIQ) | (1<<CMSR_IRQ);
 957              		.loc 1 456 0
 958 0490 E38330C0 		orr	r3, r3, #192
 959              	.LVL111:
 960              	.LBB360:
 961              	.LBB361:
 437:../lib/io_driver.c **** 	asm volatile (" msr cpsr, %0" : /* no outputs */ : "r" (_cmsr)  );
 962              		.loc 1 437 0
 963              	@ 437 "../lib/io_driver.c" 1
 964 0494 E129F003 		 msr cpsr, r3
 965              	@ 0 "" 2
 966 0498 E12FFF1E 		bx	lr
 967              	.LBE361:
 968              	.LBE360:
 969              		.cfi_endproc
 970              	.LFE22:
 972              		.align	2
 973              		.global	uart0_printf
 975              	uart0_printf:
 976              	.LFB23:
 977              		.file 2 "../lib/uart.c"
   1:../lib/uart.c **** #include "uart.h"
   2:../lib/uart.c **** 
   3:../lib/uart.c **** // ############################################################################################
   4:../lib/uart.c **** // Print text string via UART 0
   5:../lib/uart.c ****    const char *uart0_printf(const char *string)
   6:../lib/uart.c **** // ############################################################################################
   7:../lib/uart.c **** {
 978              		.loc 2 7 0
 979              		.cfi_startproc
 980              		@ Function supports interworking.
 981              		@ args = 0, pretend = 0, frame = 0
 982              		@ frame_needed = 0, uses_anonymous_args = 0
 983              		@ link register save eliminated.
 984              	.LVL112:
   8:../lib/uart.c **** 	char ch;
   9:../lib/uart.c **** 
  10:../lib/uart.c **** 	while ((ch = *string)){
 985              		.loc 2 10 0
 986 049c E5D01000 		ldrb	r1, [r0]	@ zero_extendqisi2
 987              	.LVL113:
 988 04a0 E3510000 		cmp	r1, #0
 989 04a4 012FFF1E 		bxeq	lr
 990 04a8 E280C001 		add	ip, r0, #1
 991              	.LBB362:
 992              	.LBB363:
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 993              		.loc 1 183 0
 994 04ac E3E02A0F 		mvn	r2, #61440
 995              	.LVL114:
 996              	.L105:
 997 04b0 E5123FE3 		ldr	r3, [r2, #-4067]
 998 04b4 E3130001 		tst	r3, #1
 999 04b8 E3E03A0F 		mvn	r3, #61440
 1000 04bc 0AFFFFFB 		beq	.L105
 184:../lib/io_driver.c **** 	UART0_DATA = (ch & 0x000000FF);
 1001              		.loc 1 184 0
 1002 04c0 E5031FE7 		str	r1, [r3, #-4071]
 1003              	.LBE363:
 1004              	.LBE362:
  11:../lib/uart.c **** 		if (io_uart0_send_byte(ch)<=0)
  12:../lib/uart.c **** 			break;
  13:../lib/uart.c **** 		string++;
 1005              		.loc 2 13 0
 1006 04c4 E1A0000C 		mov	r0, ip
 1007              	.LVL115:
  10:../lib/uart.c **** 	while ((ch = *string)){
 1008              		.loc 2 10 0
 1009 04c8 E4DC1001 		ldrb	r1, [ip], #1	@ zero_extendqisi2
 1010              	.LVL116:
 1011 04cc E3510000 		cmp	r1, #0
 1012 04d0 1AFFFFF6 		bne	.L105
  14:../lib/uart.c **** 	}
  15:../lib/uart.c **** 	return string;
  16:../lib/uart.c **** }
 1013              		.loc 2 16 0
 1014 04d4 E12FFF1E 		bx	lr
 1015              		.cfi_endproc
 1016              	.LFE23:
 1018              		.align	2
 1019              		.global	uart0_scanf
 1021              	uart0_scanf:
 1022              	.LFB24:
  17:../lib/uart.c **** 
  18:../lib/uart.c **** // ############################################################################################
  19:../lib/uart.c **** // Read text string via UART 0
  20:../lib/uart.c ****    void uart0_scanf(unsigned char *buffer, int length, unsigned char en_echo)
  21:../lib/uart.c **** // ############################################################################################
  22:../lib/uart.c **** {
 1023              		.loc 2 22 0
 1024              		.cfi_startproc
 1025              		@ Function supports interworking.
 1026              		@ args = 0, pretend = 0, frame = 0
 1027              		@ frame_needed = 0, uses_anonymous_args = 0
 1028              		@ link register save eliminated.
 1029              	.LVL117:
  23:../lib/uart.c **** 	int temp = 0;
  24:../lib/uart.c **** 
  25:../lib/uart.c **** 	while(length > 0){
 1030              		.loc 2 25 0
 1031 04d8 E3510000 		cmp	r1, #0
  22:../lib/uart.c **** {
 1032              		.loc 2 22 0
 1033 04dc E52D4004 		str	r4, [sp, #-4]!
 1034              	.LCFI1:
 1035              		.cfi_def_cfa_offset 4
 1036              		.cfi_offset 4, -4
 1037              	.LBB364:
 1038              	.LBB365:
 166:../lib/io_driver.c **** 	if ((UART0_SREG & (1<<CUART_RXD)) != 0) // byte available?
 1039              		.loc 1 166 0
 1040 04e0 E3E03A0F 		mvn	r3, #61440
 1041              	.LBE365:
 1042              	.LBE364:
 1043              		.loc 2 25 0
 1044 04e4 DA00000D 		ble	.L113
 1045              	.LVL118:
 1046              	.L116:
 1047              	.LBB367:
 1048              	.LBB366:
 166:../lib/io_driver.c **** 	if ((UART0_SREG & (1<<CUART_RXD)) != 0) // byte available?
 1049              		.loc 1 166 0
 1050 04e8 E513CFE3 		ldr	ip, [r3, #-4067]
 1051 04ec E31C0002 		tst	ip, #2
 1052 04f0 0AFFFFFC 		beq	.L116
 167:../lib/io_driver.c **** 		temp = UART0_DATA;
 1053              		.loc 1 167 0
 1054 04f4 E513CFE7 		ldr	ip, [r3, #-4071]
 1055              	.LVL119:
 1056              	.LBE366:
 1057              	.LBE367:
  26:../lib/uart.c **** 		temp = io_uart0_read_byte();
  27:../lib/uart.c **** 		if(temp != -1){
 1058              		.loc 2 27 0
 1059 04f8 E37C0001 		cmn	ip, #1
 1060 04fc 0AFFFFF9 		beq	.L116
  28:../lib/uart.c **** 			temp = (unsigned char)(temp & 0x000000FF);
 1061              		.loc 2 28 0
 1062 0500 E20CC0FF 		and	ip, ip, #255
 1063              	.LVL120:
  29:../lib/uart.c **** 			*buffer++ = temp;
  30:../lib/uart.c **** 			if(en_echo == 1)
 1064              		.loc 2 30 0
 1065 0504 E3520001 		cmp	r2, #1
  29:../lib/uart.c **** 			*buffer++ = temp;
 1066              		.loc 2 29 0
 1067 0508 E5C0C000 		strb	ip, [r0]
 1068 050c E2800001 		add	r0, r0, #1
 1069              	.LVL121:
 1070              		.loc 2 30 0
 1071 0510 0A000004 		beq	.L121
 1072              	.L119:
 1073 0514 E2411001 		sub	r1, r1, #1
 1074              	.LVL122:
  25:../lib/uart.c **** 	while(length > 0){
 1075              		.loc 2 25 0
 1076 0518 E3510000 		cmp	r1, #0
 1077 051c CAFFFFF1 		bgt	.L116
 1078              	.LVL123:
 1079              	.L113:
  31:../lib/uart.c **** 				io_uart0_send_byte(temp); // echo
  32:../lib/uart.c **** 			length--;
  33:../lib/uart.c **** 		}
  34:../lib/uart.c **** 	}
  35:../lib/uart.c **** }
 1080              		.loc 2 35 0
 1081 0520 E49D4004 		ldr	r4, [sp], #4
 1082 0524 E12FFF1E 		bx	lr
 1083              	.LVL124:
 1084              	.L121:
 1085              	.LBB368:
 1086              	.LBB369:
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 1087              		.loc 1 183 0
 1088 0528 E5134FE3 		ldr	r4, [r3, #-4067]
 1089 052c E3140001 		tst	r4, #1
 1090 0530 E3E04A0F 		mvn	r4, #61440
 1091 0534 0AFFFFFB 		beq	.L121
 184:../lib/io_driver.c **** 	UART0_DATA = (ch & 0x000000FF);
 1092              		.loc 1 184 0
 1093 0538 E504CFE7 		str	ip, [r4, #-4071]
 1094 053c EAFFFFF4 		b	.L119
 1095              	.LBE369:
 1096              	.LBE368:
 1097              		.cfi_endproc
 1098              	.LFE24:
 1100              		.align	2
 1101              		.global	uart0_print_buffer
 1103              	uart0_print_buffer:
 1104              	.LFB25:
  36:../lib/uart.c **** 
  37:../lib/uart.c **** // ############################################################################################
  38:../lib/uart.c **** // Print character buffer via UART 0
  39:../lib/uart.c ****    void uart0_print_buffer(unsigned char *buffer, int size)
  40:../lib/uart.c **** // ############################################################################################
  41:../lib/uart.c **** {
 1105              		.loc 2 41 0
 1106              		.cfi_startproc
 1107              		@ Function supports interworking.
 1108              		@ args = 0, pretend = 0, frame = 0
 1109              		@ frame_needed = 0, uses_anonymous_args = 0
 1110              		@ link register save eliminated.
 1111              	.LVL125:
  42:../lib/uart.c **** 	unsigned char char_buffer = 0;
  43:../lib/uart.c **** 	while(size > 0){
 1112              		.loc 2 43 0
 1113 0540 E3510000 		cmp	r1, #0
 1114              	.LVL126:
 1115 0544 D12FFF1E 		bxle	lr
 1116 0548 E080C001 		add	ip, r0, r1
 1117              	.LBB370:
 1118              	.LBB371:
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 1119              		.loc 1 183 0
 1120 054c E3E02A0F 		mvn	r2, #61440
 1121              	.LVL127:
 1122              	.L130:
 1123              	.LBE371:
 1124              	.LBE370:
  44:../lib/uart.c **** 		char_buffer = *buffer++;
 1125              		.loc 2 44 0
 1126 0550 E4D01001 		ldrb	r1, [r0], #1	@ zero_extendqisi2
 1127              	.LVL128:
 1128              	.L128:
 1129              	.LBB374:
 1130              	.LBB372:
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 1131              		.loc 1 183 0
 1132 0554 E5123FE3 		ldr	r3, [r2, #-4067]
 1133 0558 E3130001 		tst	r3, #1
 1134 055c E3E03A0F 		mvn	r3, #61440
 1135 0560 0AFFFFFB 		beq	.L128
 1136              	.LBE372:
 1137              	.LBE374:
  43:../lib/uart.c **** 	while(size > 0){
 1138              		.loc 2 43 0
 1139 0564 E150000C 		cmp	r0, ip
 1140              	.LBB375:
 1141              	.LBB373:
 184:../lib/io_driver.c **** 	UART0_DATA = (ch & 0x000000FF);
 1142              		.loc 1 184 0
 1143 0568 E5031FE7 		str	r1, [r3, #-4071]
 1144              	.LVL129:
 1145              	.LBE373:
 1146              	.LBE375:
  43:../lib/uart.c **** 	while(size > 0){
 1147              		.loc 2 43 0
 1148 056c 1AFFFFF7 		bne	.L130
 1149 0570 E12FFF1E 		bx	lr
 1150              		.cfi_endproc
 1151              	.LFE25:
 1153              		.align	2
 1154              		.global	long_to_hex_string
 1156              	long_to_hex_string:
 1157              	.LFB26:
 1158              		.file 3 "../lib/utilities.c"
   1:../lib/utilities.c **** #include "utilities.h"
   2:../lib/utilities.c **** 
   3:../lib/utilities.c **** // ############################################################################################
   4:../lib/utilities.c **** // Convert 4/8/12/16/20/24/28/32 bit hexadecimal value to ASCII string
   5:../lib/utilities.c ****    void long_to_hex_string(unsigned long data,    // max 32 bit data word
   6:../lib/utilities.c ****                            unsigned char *buffer, // buffer to store the string
   7:../lib/utilities.c **** 						   unsigned char numbers) // number of places, max 8
   8:../lib/utilities.c **** // ############################################################################################
   9:../lib/utilities.c **** {
 1159              		.loc 3 9 0
 1160              		.cfi_startproc
 1161              		@ Function supports interworking.
 1162              		@ args = 0, pretend = 0, frame = 0
 1163              		@ frame_needed = 0, uses_anonymous_args = 0
 1164              		@ link register save eliminated.
 1165              	.LVL130:
  10:../lib/utilities.c **** 	unsigned char temp_char = 0;
  11:../lib/utilities.c **** 	unsigned long temp_data = 0;
  12:../lib/utilities.c **** 
  13:../lib/utilities.c **** 	// fit into range
  14:../lib/utilities.c **** 	if(numbers > 8)
 1166              		.loc 3 14 0
 1167 0574 E3520008 		cmp	r2, #8
   9:../lib/utilities.c **** {
 1168              		.loc 3 9 0
 1169 0578 E52D4004 		str	r4, [sp, #-4]!
 1170              	.LCFI2:
 1171              		.cfi_def_cfa_offset 4
 1172              		.cfi_offset 4, -4
  15:../lib/utilities.c **** 		numbers = 8;
 1173              		.loc 3 15 0
 1174 057c 83A02008 		movhi	r2, #8
 1175              	.LVL131:
  14:../lib/utilities.c **** 	if(numbers > 8)
 1176              		.loc 3 14 0
 1177 0580 8A000001 		bhi	.L134
 1178              	.LVL132:
  16:../lib/utilities.c **** 	if(numbers < 1)
  17:../lib/utilities.c **** 		numbers = 1;
 1179              		.loc 3 17 0
 1180 0584 E3520000 		cmp	r2, #0
 1181 0588 03A02001 		moveq	r2, #1
 1182              	.LVL133:
 1183              	.L134:
 1184              		.loc 3 17 0 is_stmt 0 discriminator 1
 1185 058c E1A03002 		mov	r3, r2
 1186 0590 E1A04001 		mov	r4, r1
 1187              	.LVL134:
 1188              	.L139:
  18:../lib/utilities.c **** 
  19:../lib/utilities.c **** 	while(numbers > 0){
  20:../lib/utilities.c **** 		// isolate one 4-bit value
  21:../lib/utilities.c **** 		if(numbers > 1)
 1189              		.loc 3 21 0 is_stmt 1
 1190 0594 E3530001 		cmp	r3, #1
  22:../lib/utilities.c **** 			temp_data = data >> ((numbers-1)*4);
 1191              		.loc 3 22 0
 1192 0598 12433001 		subne	r3, r3, #1
 1193              	.LVL135:
 1194 059c 11A0C103 		movne	ip, r3, asl #2
 1195 05a0 11A0CC30 		movne	ip, r0, lsr ip
 1196              	.LVL136:
  23:../lib/utilities.c **** 		else
  24:../lib/utilities.c **** 			temp_data = data;
 1197              		.loc 3 24 0
 1198 05a4 01A0C000 		moveq	ip, r0
 1199              	.LVL137:
  25:../lib/utilities.c **** 		temp_data = temp_data & 0x0000000F;
 1200              		.loc 3 25 0
 1201 05a8 E20CC00F 		and	ip, ip, #15
 1202 05ac 03A03000 		moveq	r3, #0
 1203              	.LVL138:
  26:../lib/utilities.c **** 		numbers--;
 1204              		.loc 3 26 0
 1205 05b0 E20330FF 		and	r3, r3, #255
 1206              	.LVL139:
  27:../lib/utilities.c **** 
  28:../lib/utilities.c **** 		// convert 4-bit value temp_data to char temp_char
  29:../lib/utilities.c **** 		if(temp_data < 10)
 1207              		.loc 3 29 0
 1208 05b4 E35C0009 		cmp	ip, #9
  30:../lib/utilities.c **** 			temp_char = '0' + temp_data;
 1209              		.loc 3 30 0
 1210 05b8 928CC030 		addls	ip, ip, #48
 1211              	.LVL140:
  31:../lib/utilities.c **** 		else
  32:../lib/utilities.c **** 			temp_char = 'A' + temp_data - 10;
 1212              		.loc 3 32 0
 1213 05bc 828CC037 		addhi	ip, ip, #55
 1214              	.LVL141:
  19:../lib/utilities.c **** 	while(numbers > 0){
 1215              		.loc 3 19 0
 1216 05c0 E3530000 		cmp	r3, #0
  33:../lib/utilities.c **** 
  34:../lib/utilities.c **** 		// save character
  35:../lib/utilities.c **** 		*buffer++ = temp_char;
 1217              		.loc 3 35 0
 1218 05c4 E4C4C001 		strb	ip, [r4], #1
 1219              	.LVL142:
  19:../lib/utilities.c **** 	while(numbers > 0){
 1220              		.loc 3 19 0
 1221 05c8 1AFFFFF1 		bne	.L139
 1222              	.LVL143:
 1223 05cc E2422001 		sub	r2, r2, #1
 1224              	.LVL144:
 1225 05d0 E20220FF 		and	r2, r2, #255
 1226              	.LVL145:
  36:../lib/utilities.c **** 	}
  37:../lib/utilities.c **** 
  38:../lib/utilities.c **** 	*buffer++ = 0; // terminate string
 1227              		.loc 3 38 0
 1228 05d4 E0811002 		add	r1, r1, r2
 1229 05d8 E5C13001 		strb	r3, [r1, #1]
  39:../lib/utilities.c **** }
 1230              		.loc 3 39 0
 1231 05dc E49D4004 		ldr	r4, [sp], #4
 1232 05e0 E12FFF1E 		bx	lr
 1233              		.cfi_endproc
 1234              	.LFE26:
 1236              		.align	2
 1237              		.global	get_adc
 1239              	get_adc:
 1240              	.LFB27:
  40:../lib/utilities.c **** 
  41:../lib/utilities.c **** /*
  42:../lib/utilities.c **** // ############################################################################################
  43:../lib/utilities.c **** unsigned long hex_string_to_long(unsigned char *buffer, unsigned char numbers)
  44:../lib/utilities.c **** // ############################################################################################
  45:../lib/utilities.c **** {
  46:../lib/utilities.c ****   unsigned long data = 0;
  47:../lib/utilities.c ****   for (int i = numbers; i >=0; i--) {
  48:../lib/utilities.c ****    char ch = buffer[i];
  49:../lib/utilities.c ****    if (ch >= 'a' && ch <= 'f') {
  50:../lib/utilities.c ****     ch = ch - 'a' + 10;
  51:../lib/utilities.c ****    }
  52:../lib/utilities.c ****    else if (ch >= 'A' && ch <= 'F') {
  53:../lib/utilities.c ****     ch = ch - 'A' + 10;
  54:../lib/utilities.c ****    }
  55:../lib/utilities.c ****    else if (ch >= '0' && ch <= '9') {
  56:../lib/utilities.c ****     ch = ch - '0';
  57:../lib/utilities.c ****    }
  58:../lib/utilities.c ****    data = (data << 4) + ch; 
  59:../lib/utilities.c ****   }
  60:../lib/utilities.c ****   return data;
  61:../lib/utilities.c **** }
  62:../lib/utilities.c **** 
  63:../lib/utilities.c **** 
  64:../lib/utilities.c **** // ############################################################################################
  65:../lib/utilities.c **** unsigned long qbytes_to_long(unsigned char *buffer)
  66:../lib/utilities.c **** // ############################################################################################
  67:../lib/utilities.c **** {
  68:../lib/utilities.c ****   return hex_string_to_long(buffer, 2);
  69:../lib/utilities.c **** }
  70:../lib/utilities.c **** */
  71:../lib/utilities.c **** 
  72:../lib/utilities.c **** 
  73:../lib/utilities.c **** // ############################################################################################
  74:../lib/utilities.c **** // read external ADC value
  75:../lib/utilities.c ****    unsigned int get_adc(int adc_index) // adc 0..7
  76:../lib/utilities.c **** // ############################################################################################
  77:../lib/utilities.c **** {
 1241              		.loc 3 77 0
 1242              		.cfi_startproc
 1243              		@ Function supports interworking.
 1244              		@ args = 0, pretend = 0, frame = 0
 1245              		@ frame_needed = 0, uses_anonymous_args = 0
 1246              		@ link register save eliminated.
 1247              	.LVL146:
  78:../lib/utilities.c **** 	unsigned long temp;
  79:../lib/utilities.c **** 
  80:../lib/utilities.c **** 	if ((adc_index < 0) || (adc_index > 7))
 1248              		.loc 3 80 0
 1249 05e4 E3500007 		cmp	r0, #7
 1250 05e8 8A000023 		bhi	.L153
 1251              	.LVL147:
 1252              	.LBB376:
 1253              	.LBB377:
 207:../lib/io_driver.c **** 		SPI0_CONF = (1<<SPI_ACS) | (1<<SPI_TX_NEG) | data_size; // auto assert cs
 1254              		.loc 1 207 0
 1255 05ec E59F3090 		ldr	r3, .L154
 1256 05f0 E3E01A0F 		mvn	r1, #61440
 1257 05f4 E5013FCF 		str	r3, [r1, #-4047]
 1258              	.LVL148:
 1259              	.LBE377:
 1260              	.LBE376:
 1261              	.LBB378:
 1262              	.LBB379:
 253:../lib/io_driver.c **** 		SPI0_SCSR = SPI0_SCSR | (1<<device);
 1263              		.loc 1 253 0
 1264 05f8 E5113FC7 		ldr	r3, [r1, #-4039]
 1265 05fc E3833040 		orr	r3, r3, #64
 1266 0600 E5013FC7 		str	r3, [r1, #-4039]
 1267              	.LBE379:
 1268              	.LBE378:
  81:../lib/utilities.c **** 		return 0;
  82:../lib/utilities.c **** 
  83:../lib/utilities.c **** 	// config spi
  84:../lib/utilities.c **** 	io_spi0_config(1,16); // auto assert cs, 16 bit transfer
  85:../lib/utilities.c **** 	io_spi0_enable(adc_cs);
  86:../lib/utilities.c **** 
  87:../lib/utilities.c **** 	temp = adc_index * 2048;
 1269              		.loc 3 87 0
 1270 0604 E1A00580 		mov	r0, r0, asl #11
 1271              	.LVL149:
 1272              	.L146:
 1273              	.LBB380:
 1274              	.LBB381:
 235:../lib/io_driver.c **** 	while((SPI0_CONF & (1<<SPI_BUSY)) != 0); // wait for prev tx to finish
 1275              		.loc 1 235 0
 1276 0608 E5113FCF 		ldr	r3, [r1, #-4047]
 1277 060c E2133C01 		ands	r3, r3, #256
 1278 0610 E3E02A0F 		mvn	r2, #61440
 1279 0614 1AFFFFFB 		bne	.L146
 236:../lib/io_driver.c **** 	SPI0_DAT0 = data;
 1280              		.loc 1 236 0
 1281 0618 E5023FBF 		str	r3, [r2, #-4031]
 237:../lib/io_driver.c **** 	SPI0_CONF = SPI0_CONF | (1<<SPI_BUSY); // start transmitter
 1282              		.loc 1 237 0
 1283 061c E5123FCF 		ldr	r3, [r2, #-4047]
 1284 0620 E3833C01 		orr	r3, r3, #256
 1285 0624 E5023FCF 		str	r3, [r2, #-4047]
 1286              	.L148:
 238:../lib/io_driver.c **** 	while((SPI0_CONF & (1<<SPI_BUSY)) != 0); // wait for rx to finish
 1287              		.loc 1 238 0
 1288 0628 E5123FCF 		ldr	r3, [r2, #-4047]
 1289 062c E3130C01 		tst	r3, #256
 1290 0630 E3E03A0F 		mvn	r3, #61440
 1291 0634 1AFFFFFB 		bne	.L148
 239:../lib/io_driver.c **** 	unsigned long temp = SPI0_DAT0;
 1292              		.loc 1 239 0
 1293 0638 E5132FBF 		ldr	r2, [r3, #-4031]
 1294              	.LVL150:
 1295              	.LBE381:
 1296              	.LBE380:
 1297              	.LBB382:
 1298              	.LBB383:
 235:../lib/io_driver.c **** 	while((SPI0_CONF & (1<<SPI_BUSY)) != 0); // wait for prev tx to finish
 1299              		.loc 1 235 0
 1300 063c E1A02003 		mov	r2, r3
 1301              	.L150:
 1302 0640 E5123FCF 		ldr	r3, [r2, #-4047]
 1303 0644 E3130C01 		tst	r3, #256
 1304 0648 E3E03A0F 		mvn	r3, #61440
 1305 064c 1AFFFFFB 		bne	.L150
 236:../lib/io_driver.c **** 	SPI0_DAT0 = data;
 1306              		.loc 1 236 0
 1307 0650 E5030FBF 		str	r0, [r3, #-4031]
 237:../lib/io_driver.c **** 	SPI0_CONF = SPI0_CONF | (1<<SPI_BUSY); // start transmitter
 1308              		.loc 1 237 0
 1309 0654 E5132FCF 		ldr	r2, [r3, #-4047]
 1310 0658 E3822C01 		orr	r2, r2, #256
 1311 065c E5032FCF 		str	r2, [r3, #-4047]
 238:../lib/io_driver.c **** 	while((SPI0_CONF & (1<<SPI_BUSY)) != 0); // wait for rx to finish
 1312              		.loc 1 238 0
 1313 0660 E1A01003 		mov	r1, r3
 1314              	.L152:
 1315 0664 E5113FCF 		ldr	r3, [r1, #-4047]
 1316 0668 E3130C01 		tst	r3, #256
 1317 066c E3E02A0F 		mvn	r2, #61440
 1318 0670 1AFFFFFB 		bne	.L152
 239:../lib/io_driver.c **** 	unsigned long temp = SPI0_DAT0;
 1319              		.loc 1 239 0
 1320 0674 E5120FBF 		ldr	r0, [r2, #-4031]
 1321              	.LVL151:
 1322              	.LBE383:
 1323              	.LBE382:
  88:../lib/utilities.c **** 	io_spi0_trans(0); // dummy read
  89:../lib/utilities.c **** 	return (unsigned int)io_spi0_trans(temp);
 1324              		.loc 3 89 0
 1325 0678 E12FFF1E 		bx	lr
 1326              	.LVL152:
 1327              	.L153:
  81:../lib/utilities.c **** 		return 0;
 1328              		.loc 3 81 0
 1329 067c E3A00000 		mov	r0, #0
 1330              	.LVL153:
  90:../lib/utilities.c **** }
 1331              		.loc 3 90 0
 1332 0680 E12FFF1E 		bx	lr
 1333              	.L155:
 1334              		.align	2
 1335              	.L154:
 1336 0684 00002410 		.word	9232
 1337              		.cfi_endproc
 1338              	.LFE27:
 1340              		.align	2
 1341              		.global	delay
 1343              	delay:
 1344              	.LFB28:
  91:../lib/utilities.c **** 
  92:../lib/utilities.c **** // ############################################################################################
  93:../lib/utilities.c **** // simple delay routine
  94:../lib/utilities.c ****    void delay(int time) // waits time*10000 clock ticks
  95:../lib/utilities.c **** // ############################################################################################
  96:../lib/utilities.c **** {
 1345              		.loc 3 96 0
 1346              		.cfi_startproc
 1347              		@ Function supports interworking.
 1348              		@ args = 0, pretend = 0, frame = 0
 1349              		@ frame_needed = 0, uses_anonymous_args = 0
 1350              		@ link register save eliminated.
 1351              	.LVL154:
  97:../lib/utilities.c **** 	time = time*2500*4;
 1352              		.loc 3 97 0
 1353 0688 E0603280 		rsb	r3, r0, r0, asl #5
 1354 068c E0800103 		add	r0, r0, r3, asl #2
 1355              	.LVL155:
 1356 0690 E0800100 		add	r0, r0, r0, asl #2
 1357 0694 E1A03200 		mov	r3, r0, asl #4
 1358              	.LVL156:
  98:../lib/utilities.c **** 	while(time > 0){
 1359              		.loc 3 98 0
 1360 0698 E3530000 		cmp	r3, #0
 1361 069c D12FFF1E 		bxle	lr
 1362              	.L158:
  99:../lib/utilities.c **** 		asm volatile ("NOP");
 1363              		.loc 3 99 0
 1364              	@ 99 "../lib/utilities.c" 1
 1365 06a0 E1A00000 		NOP
 1366              	@ 0 "" 2
 1367              	.LVL157:
  98:../lib/utilities.c **** 	while(time > 0){
 1368              		.loc 3 98 0
 1369 06a4 E2533001 		subs	r3, r3, #1
 1370              	.LVL158:
 1371 06a8 1AFFFFFC 		bne	.L158
 1372 06ac E12FFF1E 		bx	lr
 1373              		.cfi_endproc
 1374              	.LFE28:
 1376              		.align	2
 1377              		.global	string_cmpc
 1379              	string_cmpc:
 1380              	.LFB29:
 100:../lib/utilities.c **** 		time--;
 101:../lib/utilities.c **** 	}
 102:../lib/utilities.c **** }
 103:../lib/utilities.c **** 
 104:../lib/utilities.c **** // ############################################################################################
 105:../lib/utilities.c **** // String compare, buffered string with immediate const char string
 106:../lib/utilities.c ****    unsigned char string_cmpc(unsigned char *string1, const char *string2, unsigned char length)
 107:../lib/utilities.c **** // ############################################################################################
 108:../lib/utilities.c **** {
 1381              		.loc 3 108 0
 1382              		.cfi_startproc
 1383              		@ Function supports interworking.
 1384              		@ args = 0, pretend = 0, frame = 0
 1385              		@ frame_needed = 0, uses_anonymous_args = 0
 1386              		@ link register save eliminated.
 1387              	.LVL159:
 109:../lib/utilities.c **** 	while(length != 0){
 1388              		.loc 3 109 0
 1389 06b0 E2523000 		subs	r3, r2, #0
 1390 06b4 0A00000B 		beq	.L167
 1391              	.LVL160:
 110:../lib/utilities.c **** 		if(*string1++ != (unsigned char)*string2++)
 1392              		.loc 3 110 0
 1393 06b8 E5D0C000 		ldrb	ip, [r0]	@ zero_extendqisi2
 1394 06bc E5D12000 		ldrb	r2, [r1]	@ zero_extendqisi2
 1395              	.LVL161:
 1396 06c0 E15C0002 		cmp	ip, r2
 1397 06c4 0A000004 		beq	.L165
 1398 06c8 EA000008 		b	.L169
 1399              	.LVL162:
 1400              	.L166:
 1401 06cc E5F0C001 		ldrb	ip, [r0, #1]!	@ zero_extendqisi2
 1402              	.LVL163:
 1403 06d0 E5F12001 		ldrb	r2, [r1, #1]!	@ zero_extendqisi2
 1404 06d4 E15C0002 		cmp	ip, r2
 1405 06d8 1A000004 		bne	.L169
 1406              	.LVL164:
 1407              	.L165:
 111:../lib/utilities.c **** 			return(0); // missmatch
 112:../lib/utilities.c **** 		length--;
 1408              		.loc 3 112 0
 1409 06dc E2433001 		sub	r3, r3, #1
 1410              	.LVL165:
 109:../lib/utilities.c **** 	while(length != 0){
 1411              		.loc 3 109 0
 1412 06e0 E21330FF 		ands	r3, r3, #255
 1413              	.LVL166:
 1414 06e4 1AFFFFF8 		bne	.L166
 1415              	.LVL167:
 1416              	.L167:
 113:../lib/utilities.c **** 	}
 114:../lib/utilities.c **** 	return(1); // match
 1417              		.loc 3 114 0
 1418 06e8 E3A00001 		mov	r0, #1
 1419 06ec E12FFF1E 		bx	lr
 1420              	.L169:
 111:../lib/utilities.c **** 			return(0); // missmatch
 1421              		.loc 3 111 0
 1422 06f0 E3A00000 		mov	r0, #0
 115:../lib/utilities.c **** }
 1423              		.loc 3 115 0
 1424 06f4 E12FFF1E 		bx	lr
 1425              		.cfi_endproc
 1426              	.LFE29:
 1428              		.align	2
 1429              		.global	hex_string_to_long
 1431              	hex_string_to_long:
 1432              	.LFB30:
 1433              		.file 4 "main.c"
   1:main.c        **** #include "../lib/storm_core.h"
   2:main.c        **** #include "../lib/storm_soc_basic.h"
   3:main.c        **** #include "../lib/io_driver.c"
   4:main.c        **** #include "../lib/uart.c"
   5:main.c        **** #include "../lib/utilities.c"
   6:main.c        **** //#include <stdlib.h>
   7:main.c        **** 
   8:main.c        **** unsigned long int hex_string_to_long ( char *hexstr, int charlen )
   9:main.c        **** {
 1434              		.loc 4 9 0
 1435              		.cfi_startproc
 1436              		@ Function supports interworking.
 1437              		@ args = 0, pretend = 0, frame = 0
 1438              		@ frame_needed = 0, uses_anonymous_args = 0
 1439              		@ link register save eliminated.
 1440              	.LVL168:
  10:main.c        **** 	unsigned long int hexval =  0 ;
  11:main.c        **** 	int i;
  12:main.c        **** 
  13:main.c        **** 	for (i=0 ; i< (charlen*2) ; i++ ) {
 1441              		.loc 4 13 0
 1442 06f8 E1A01081 		mov	r1, r1, asl #1
 1443              	.LVL169:
 1444 06fc E3510000 		cmp	r1, #0
   9:main.c        **** {
 1445              		.loc 4 9 0
 1446 0700 E52D4004 		str	r4, [sp, #-4]!
 1447              	.LCFI3:
 1448              		.cfi_def_cfa_offset 4
 1449              		.cfi_offset 4, -4
 1450              		.loc 4 13 0
 1451 0704 DA000018 		ble	.L176
 1452 0708 E1A02000 		mov	r2, r0
 1453 070c E0804001 		add	r4, r0, r1
  10:main.c        **** 	unsigned long int hexval =  0 ;
 1454              		.loc 4 10 0
 1455 0710 E3A00000 		mov	r0, #0
 1456              	.LVL170:
 1457              	.L175:
  14:main.c        **** 		if (( hexstr[i] >= 48 ) & (hexstr[i] <= 57 )) 
 1458              		.loc 4 14 0
 1459 0714 E4D23001 		ldrb	r3, [r2], #1	@ zero_extendqisi2
 1460              	.LVL171:
 1461 0718 E2431030 		sub	r1, r3, #48
 1462 071c E20110FF 		and	r1, r1, #255
 1463 0720 E3510009 		cmp	r1, #9
  15:main.c        **** 			hexval = (hexval <<4 ) + hexstr[i] - (int) '0';
  16:main.c        **** 		else if (( hexstr[i] >= 65 ) & ( hexstr[i] <= 70 )) 
 1464              		.loc 4 16 0
 1465 0724 E243C041 		sub	ip, r3, #65
  15:main.c        **** 			hexval = (hexval <<4 ) + hexstr[i] - (int) '0';
 1466              		.loc 4 15 0
 1467 0728 90830200 		addls	r0, r3, r0, asl #4
 1468              	.LVL172:
 1469              		.loc 4 16 0
 1470 072c E20CC0FF 		and	ip, ip, #255
  15:main.c        **** 			hexval = (hexval <<4 ) + hexstr[i] - (int) '0';
 1471              		.loc 4 15 0
 1472 0730 92400030 		subls	r0, r0, #48
  14:main.c        **** 		if (( hexstr[i] >= 48 ) & (hexstr[i] <= 57 )) 
 1473              		.loc 4 14 0
 1474 0734 9A000008 		bls	.L173
 1475              		.loc 4 16 0
 1476 0738 E35C0005 		cmp	ip, #5
  17:main.c        **** 			hexval = (hexval <<4 ) + hexstr[i] + 10 - (int) 'A';
  18:main.c        **** 		else if (( hexstr[i] >= 97 ) & ( hexstr[i] <= 102)) 
 1477              		.loc 4 18 0
 1478 073c E2431061 		sub	r1, r3, #97
  17:main.c        **** 			hexval = (hexval <<4 ) + hexstr[i] + 10 - (int) 'A';
 1479              		.loc 4 17 0
 1480 0740 90830200 		addls	r0, r3, r0, asl #4
 1481              		.loc 4 18 0
 1482 0744 E20110FF 		and	r1, r1, #255
  17:main.c        **** 			hexval = (hexval <<4 ) + hexstr[i] + 10 - (int) 'A';
 1483              		.loc 4 17 0
 1484 0748 92400037 		subls	r0, r0, #55
  16:main.c        **** 		else if (( hexstr[i] >= 65 ) & ( hexstr[i] <= 70 )) 
 1485              		.loc 4 16 0
 1486 074c 9A000002 		bls	.L173
 1487              		.loc 4 18 0
 1488 0750 E3510005 		cmp	r1, #5
  19:main.c        **** 			hexval = (hexval <<4 ) + hexstr[i] +10 - (int) 'a';
 1489              		.loc 4 19 0
 1490 0754 90830200 		addls	r0, r3, r0, asl #4
 1491 0758 92400057 		subls	r0, r0, #87
 1492              	.LVL173:
 1493              	.L173:
  13:main.c        **** 	for (i=0 ; i< (charlen*2) ; i++ ) {
 1494              		.loc 4 13 0
 1495 075c E1520004 		cmp	r2, r4
 1496 0760 1AFFFFEB 		bne	.L175
 1497              	.LVL174:
 1498              	.L171:
  20:main.c        **** 	} //for
  21:main.c        ****  
  22:main.c        **** 	return hexval;
  23:main.c        **** }
 1499              		.loc 4 23 0
 1500 0764 E49D4004 		ldr	r4, [sp], #4
 1501 0768 E12FFF1E 		bx	lr
 1502              	.LVL175:
 1503              	.L176:
  10:main.c        **** 	unsigned long int hexval =  0 ;
 1504              		.loc 4 10 0
 1505 076c E3A00000 		mov	r0, #0
 1506              	.LVL176:
 1507 0770 EAFFFFFB 		b	.L171
 1508              		.cfi_endproc
 1509              	.LFE30:
 1511              		.align	2
 1512              		.global	qbytes_to_long
 1514              	qbytes_to_long:
 1515              	.LFB31:
  24:main.c        **** 
  25:main.c        **** unsigned long int qbytes_to_long ( unsigned char *buffer )
  26:main.c        **** {
 1516              		.loc 4 26 0
 1517              		.cfi_startproc
 1518              		@ Function supports interworking.
 1519              		@ args = 0, pretend = 0, frame = 0
 1520              		@ frame_needed = 0, uses_anonymous_args = 0
 1521              		@ link register save eliminated.
 1522              	.LVL177:
  27:main.c        **** 	unsigned char d = buffer[0];
  28:main.c        **** 	unsigned char c = buffer[1];
  29:main.c        **** 	unsigned char b = buffer[2];
  30:main.c        **** 	unsigned char a = buffer[3];
  31:main.c        **** 	unsigned long n;
  32:main.c        **** 
  33:main.c        **** 
  34:main.c        **** 	n = a|(b<<8)|(c<<16)|(d<<24);
 1523              		.loc 4 34 0
 1524 0774 E5D03001 		ldrb	r3, [r0, #1]	@ zero_extendqisi2
 1525              	.LVL178:
 1526 0778 E5D01002 		ldrb	r1, [r0, #2]	@ zero_extendqisi2
 1527              	.LVL179:
 1528 077c E5D02003 		ldrb	r2, [r0, #3]	@ zero_extendqisi2
 1529 0780 E1A03803 		mov	r3, r3, asl #16
 1530              	.LVL180:
 1531 0784 E1833401 		orr	r3, r3, r1, asl #8
 1532 0788 E5D00000 		ldrb	r0, [r0]	@ zero_extendqisi2
 1533              	.LVL181:
 1534 078c E1833002 		orr	r3, r3, r2
  35:main.c        **** 	return n;
  36:main.c        **** }
 1535              		.loc 4 36 0
 1536 0790 E1830C00 		orr	r0, r3, r0, asl #24
 1537              	.LVL182:
 1538 0794 E12FFF1E 		bx	lr
 1539              		.cfi_endproc
 1540              	.LFE31:
 1542              		.section	.text.startup,"ax",%progbits
 1543              		.align	2
 1544              		.global	main
 1546              	main:
 1547              	.LFB32:
  37:main.c        **** 
  38:main.c        **** // ############################################################################################
  39:main.c        **** // STORM SoC Bootloader
  40:main.c        ****    int main(void)
  41:main.c        **** // ############################################################################################
  42:main.c        **** {
 1548              		.loc 4 42 0
 1549              		.cfi_startproc
 1550              		@ Function supports interworking.
 1551              		@ args = 0, pretend = 0, frame = 8
 1552              		@ frame_needed = 0, uses_anonymous_args = 0
 1553              	.LVL183:
 1554 0000 E92D47F0 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, lr}
 1555              	.LCFI4:
 1556              		.cfi_def_cfa_offset 32
 1557              		.cfi_offset 4, -32
 1558              		.cfi_offset 5, -28
 1559              		.cfi_offset 6, -24
 1560              		.cfi_offset 7, -20
 1561              		.cfi_offset 8, -16
 1562              		.cfi_offset 9, -12
 1563              		.cfi_offset 10, -8
 1564              		.cfi_offset 14, -4
 1565              	.LBB714:
 1566              	.LBB715:
  83:../lib/io_driver.c **** 		GPIO0_OUT = value;
 1567              		.loc 1 83 0
 1568 0004 E3E03A0F 		mvn	r3, #61440
 1569 0008 E3A02000 		mov	r2, #0
 1570 000c E5032FFF 		str	r2, [r3, #-4095]
 1571              	.LVL184:
 1572              	.LBE715:
 1573              	.LBE714:
 1574              		.loc 4 42 0
 1575 0010 E24DD010 		sub	sp, sp, #16
 1576              	.LCFI5:
 1577              		.cfi_def_cfa_offset 48
 1578              	.LBB716:
 1579              	.LBB717:
 416:../lib/io_driver.c **** 		case SYS_IO:     asm volatile ("mcr p15,0,%0,c13,c13,0" : /* no outputs */ : "r" (_cp_val)); brea
 1580              		.loc 1 416 0
 1581 0014 E3A030C3 		mov	r3, #195
 1582              	@ 416 "../lib/io_driver.c" 1
 1583 0018 EE0D3F1D 		mcr p15,0,r3,c13,c13,0
 1584              	@ 0 "" 2
 1585              	.LVL185:
 1586              	.LBE717:
 1587              	.LBE716:
 1588              	.LBB718:
 1589              	.LBB719:
 285:../lib/io_driver.c **** 		I2C0_CTRL = I2C0_CTRL & ~(1<<I2C_EN); // disable i2c core
 1590              		.loc 1 285 0
 1591 001c E3E03A0F 		mvn	r3, #61440
 1592 0020 E5130F97 		ldr	r0, [r3, #-3991]
 286:../lib/io_driver.c **** 		I2C0_PRLO = clk_divider;
 1593              		.loc 1 286 0
 1594 0024 E3A01063 		mov	r1, #99
 285:../lib/io_driver.c **** 		I2C0_CTRL = I2C0_CTRL & ~(1<<I2C_EN); // disable i2c core
 1595              		.loc 1 285 0
 1596 0028 E3C00080 		bic	r0, r0, #128
 1597 002c E5030F97 		str	r0, [r3, #-3991]
 286:../lib/io_driver.c **** 		I2C0_PRLO = clk_divider;
 1598              		.loc 1 286 0
 1599 0030 E5031F9F 		str	r1, [r3, #-3999]
 287:../lib/io_driver.c **** 		I2C0_PRHI = clk_divider >> 8;
 1600              		.loc 1 287 0
 1601 0034 E5032F9B 		str	r2, [r3, #-3995]
 288:../lib/io_driver.c **** 		I2C0_CTRL = I2C0_CTRL | (1<<I2C_EN); // enable i2c core
 1602              		.loc 1 288 0
 1603 0038 E5132F97 		ldr	r2, [r3, #-3991]
 1604 003c E3822080 		orr	r2, r2, #128
 1605 0040 E5032F97 		str	r2, [r3, #-3991]
 1606              	.LVL186:
 1607              	.LBE719:
 1608              	.LBE718:
 1609              	.LBB720:
 1610              	.LBB721:
 382:../lib/io_driver.c **** 		case SYS_CTRL_0: asm volatile ("mrc p15,0,%0, c6, c6" : "=r" (_cp_val) : /* no inputs */  ); brea
 1611              		.loc 1 382 0
 1612              	@ 382 "../lib/io_driver.c" 1
 1613 0044 EE163F16 		mrc p15,0,r3, c6, c6
 1614              	@ 0 "" 2
 1615              	.LVL187:
 1616              	.LBE721:
 1617              	.LBE720:
  43:main.c        **** 	int function_sel, data, i, start_app = 0;
  44:main.c        **** 	unsigned long *data_pointer, word_buffer, adr_buffer, cnt;
  45:main.c        **** 	unsigned char buffer[5], char_tmp, *char_pointer, device_id;
  46:main.c        **** 
  47:main.c        **** 	// show reset ack
  48:main.c        **** 	io_set_gpio0_port(0);
  49:main.c        **** 	set_syscpreg(0xC3, SYS_IO);
  50:main.c        **** 
  51:main.c        **** 	// init I2C
  52:main.c        **** 	io_i2c0_speed(0x0063); // 100kHz
  53:main.c        **** 
  54:main.c        **** 	// enable write-through strategy
  55:main.c        **** 	set_syscpreg(get_syscpreg(SYS_CTRL_0) | (1<<DC_WTHRU), SYS_CTRL_0);
 1618              		.loc 4 55 0
 1619 0048 E3833008 		orr	r3, r3, #8
 1620              	.LVL188:
 1621              	.LBB722:
 1622              	.LBB723:
 409:../lib/io_driver.c **** 		case SYS_CTRL_0: asm volatile ("mcr p15,0,%0, c6, c6,0" : /* no outputs */ : "r" (_cp_val)); brea
 1623              		.loc 1 409 0
 1624              	@ 409 "../lib/io_driver.c" 1
 1625 004c EE063F16 		mcr p15,0,r3, c6, c6,0
 1626              	@ 0 "" 2
 1627              	.LVL189:
 1628              	.LBE723:
 1629              	.LBE722:
 1630              	.LBB724:
 1631              	.LBB725:
 389:../lib/io_driver.c **** 		case SYS_IO:     asm volatile ("mrc p15,0,%0,c13,c13" : "=r" (_cp_val) : /* no inputs */  ); brea
 1632              		.loc 1 389 0
 1633              	@ 389 "../lib/io_driver.c" 1
 1634 0050 EE1D3F1D 		mrc p15,0,r3,c13,c13
 1635              	@ 0 "" 2
 1636              	.LVL190:
 1637              	.LBE725:
 1638              	.LBE724:
  56:main.c        **** 
  57:main.c        **** 	// Check config switches for immediate boot-config
  58:main.c        **** 	function_sel = (int)((~(get_syscpreg(SYS_IO) >> 17)) & 0x0F);
 1639              		.loc 4 58 0
 1640 0054 E1E038A3 		mvn	r3, r3, lsr #17
 1641              	.LVL191:
 1642 0058 E203300F 		and	r3, r3, #15
 1643              	.LVL192:
  59:main.c        **** 	switch(function_sel){
 1644              		.loc 4 59 0
 1645 005c E3530001 		cmp	r3, #1
 1646 0060 0A00008C 		beq	.L181
 1647 0064 E3530002 		cmp	r3, #2
 1648 0068 1A00009C 		bne	.L596
  43:main.c        **** 	int function_sel, data, i, start_app = 0;
 1649              		.loc 4 43 0
 1650 006c E3A07000 		mov	r7, #0
  60:main.c        **** 		case 1: function_sel = '0'; goto main_menu; break; // auto start application from RAM
  61:main.c        **** 		case 2: function_sel = '3'; goto main_menu; start_app = 1; device_id = 0xA0; break; // auto boot 
 1651              		.loc 4 61 0
 1652 0070 E3A03033 		mov	r3, #51
 1653              	.LVL193:
 1654 0074 E28D5008 		add	r5, sp, #8
 1655              	.LVL194:
 1656              	.L182:
 1657              	.LBB726:
 1658              	.LBB727:
 389:../lib/io_driver.c **** 		case SYS_IO:     asm volatile ("mrc p15,0,%0,c13,c13" : "=r" (_cp_val) : /* no inputs */  ); brea
 1659              		.loc 1 389 0
 1660              	@ 389 "../lib/io_driver.c" 1
 1661 0078 EE1D2F1D 		mrc p15,0,r2,c13,c13
 1662              	@ 0 "" 2
 1663              	.LVL195:
 1664              	.LBE727:
 1665              	.LBE726:
  62:main.c        **** 		default: break;
  63:main.c        **** 	}
  64:main.c        **** 
  65:main.c        **** 	// Intro screen
  66:main.c        **** 	uart0_printf("\r\n\r\n\r\n+----------------------------------------------------------------+\r\n")
  67:main.c        **** 	uart0_printf(            "|    <<< STORM Core Processor System - By Stephan Nolting >>>    |\r\n")
  68:main.c        **** 	uart0_printf(            "+----------------------------------------------------------------+\r\n")
  69:main.c        **** 	uart0_printf(            "|         Bootloader for STORM SoC   Version: 20120524-D         |\r\n")
  70:main.c        **** 	uart0_printf(            "|               Contact: stnolting@googlemail.com                |\r\n")
  71:main.c        **** 	uart0_printf(            "+----------------------------------------------------------------+\r\n\r
  72:main.c        **** 
  73:main.c        **** 	uart0_printf(            " < Welcome to the STORM SoC bootloader console! >\r\n < Select an operat
  74:main.c        **** 	uart0_printf(            " < the boot key for immediate application start. >\r\n\r\n");
  75:main.c        **** 
  76:main.c        **** 	// Console menu
  77:main.c        **** 	uart0_printf(" 0 - boot from core RAM (start application)\r\n 1 - program core RAM via UART_0\r\n 
  78:main.c        **** 	uart0_printf(" 3 - boot from I2C EEPROM\r\n 4 - program I2C EEPROM via UART_0\r\n 5 - show content
  79:main.c        **** 	uart0_printf(" a - automatic boot configuration\r\n h - help\r\n r - restart system\r\n\r\nSelect:
  80:main.c        **** 
  81:main.c        **** 	while(1){
  82:main.c        **** 
  83:main.c        **** 		// console input
  84:main.c        **** 		function_sel = io_uart0_read_byte();
  85:main.c        **** 
  86:main.c        **** main_menu:
  87:main.c        **** 
  88:main.c        **** 		// boot button
  89:main.c        **** 		if (((get_syscpreg(SYS_IO) >> 16) & 0x01) == 0){
 1666              		.loc 4 89 0
 1667 007c E3120801 		tst	r2, #65536
 1668 0080 0A000039 		beq	.L525
 1669              	.L598:
  90:main.c        **** 			function_sel = '3';
  91:main.c        **** 			start_app    = 1;
  92:main.c        **** 			device_id    = 0xA0;
  93:main.c        **** 		}
  94:main.c        **** 
  95:main.c        **** 		// main functions
  96:main.c        **** 		switch(function_sel){
 1670              		.loc 4 96 0
 1671 0084 E3530034 		cmp	r3, #52
 1672 0088 0A00010F 		beq	.L229
 1673 008c DA00036D 		ble	.L597
 1674 0090 E3530066 		cmp	r3, #102
 1675 0094 0A000329 		beq	.L237
 1676 0098 CA000082 		bgt	.L238
 1677 009c E3530035 		cmp	r3, #53
 1678 00a0 0A000343 		beq	.L239
 1679 00a4 E3530061 		cmp	r3, #97
 1680              	.LBB729:
 1681              	.LBB730:
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 1682              		.loc 1 183 0
 1683 00a8 03E03A0F 		mvneq	r3, #61440
 1684              	.LVL196:
 1685              	.LBE730:
 1686              	.LBE729:
 1687              		.loc 4 96 0
 1688 00ac 1A000311 		bne	.L228
 1689              	.LVL197:
 1690              	.L402:
 1691              	.LBB732:
 1692              	.LBB731:
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 1693              		.loc 1 183 0
 1694 00b0 E5132FE3 		ldr	r2, [r3, #-4067]
 1695 00b4 E3120001 		tst	r2, #1
 1696 00b8 E3E01A0F 		mvn	r1, #61440
 1697 00bc 0AFFFFFB 		beq	.L402
 184:../lib/io_driver.c **** 	UART0_DATA = (ch & 0x000000FF);
 1698              		.loc 1 184 0
 1699 00c0 E3A03061 		mov	r3, #97
 1700 00c4 E5013FE7 		str	r3, [r1, #-4071]
 1701              	.LVL198:
 1702 00c8 E59F0F14 		ldr	r0, .L609
 1703              	.LBE731:
 1704              	.LBE732:
 1705              	.LBB733:
 1706              	.LBB734:
  10:../lib/uart.c **** 	while ((ch = *string)){
 1707              		.loc 2 10 0
 1708 00cc E3A0200D 		mov	r2, #13
 1709              	.LVL199:
 1710              	.L404:
 1711              	.LBB735:
 1712              	.LBB736:
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 1713              		.loc 1 183 0
 1714 00d0 E5113FE3 		ldr	r3, [r1, #-4067]
 1715 00d4 E3130001 		tst	r3, #1
 1716 00d8 E3E03A0F 		mvn	r3, #61440
 1717 00dc 0AFFFFFB 		beq	.L404
 184:../lib/io_driver.c **** 	UART0_DATA = (ch & 0x000000FF);
 1718              		.loc 1 184 0
 1719 00e0 E5032FE7 		str	r2, [r3, #-4071]
 1720              	.LVL200:
 1721              	.LBE736:
 1722              	.LBE735:
  10:../lib/uart.c **** 	while ((ch = *string)){
 1723              		.loc 2 10 0
 1724 00e4 E5F02001 		ldrb	r2, [r0, #1]!	@ zero_extendqisi2
 1725              	.LVL201:
 1726 00e8 E3520000 		cmp	r2, #0
 1727 00ec 1AFFFFF7 		bne	.L404
 1728 00f0 E59FCEF0 		ldr	ip, .L609+4
 1729              	.LBE734:
 1730              	.LBE733:
 1731              	.LBB737:
 1732              	.LBB738:
 1733              	.LBB739:
 1734              	.LBB740:
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 1735              		.loc 1 183 0
 1736 00f4 E1A00003 		mov	r0, r3
 1737              	.LVL202:
 1738              	.LBE740:
 1739              	.LBE739:
  10:../lib/uart.c **** 	while ((ch = *string)){
 1740              		.loc 2 10 0
 1741 00f8 E3A0205B 		mov	r2, #91
 1742              	.LVL203:
 1743              	.L408:
 1744              	.LBB742:
 1745              	.LBB741:
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 1746              		.loc 1 183 0
 1747 00fc E5101FE3 		ldr	r1, [r0, #-4067]
 1748 0100 E3110001 		tst	r1, #1
 1749 0104 E3E03A0F 		mvn	r3, #61440
 1750 0108 0AFFFFFB 		beq	.L408
 184:../lib/io_driver.c **** 	UART0_DATA = (ch & 0x000000FF);
 1751              		.loc 1 184 0
 1752 010c E5032FE7 		str	r2, [r3, #-4071]
 1753              	.LVL204:
 1754              	.LBE741:
 1755              	.LBE742:
  10:../lib/uart.c **** 	while ((ch = *string)){
 1756              		.loc 2 10 0
 1757 0110 E5FC2001 		ldrb	r2, [ip, #1]!	@ zero_extendqisi2
 1758              	.LVL205:
 1759 0114 E3520000 		cmp	r2, #0
 1760 0118 1AFFFFF7 		bne	.L408
 1761 011c E59F0EC8 		ldr	r0, .L609+8
 1762              	.LBE738:
 1763              	.LBE737:
 1764              	.LBB743:
 1765              	.LBB744:
 1766              	.LBB745:
 1767              	.LBB746:
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 1768              		.loc 1 183 0
 1769 0120 E1A01003 		mov	r1, r3
 1770              	.LBE746:
 1771              	.LBE745:
  10:../lib/uart.c **** 	while ((ch = *string)){
 1772              		.loc 2 10 0
 1773 0124 E3A03020 		mov	r3, #32
 1774              	.LVL206:
 1775              	.L412:
 1776              	.LBB748:
 1777              	.LBB747:
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 1778              		.loc 1 183 0
 1779 0128 E5112FE3 		ldr	r2, [r1, #-4067]
 1780 012c E3120001 		tst	r2, #1
 1781 0130 E3E02A0F 		mvn	r2, #61440
 1782 0134 0AFFFFFB 		beq	.L412
 184:../lib/io_driver.c **** 	UART0_DATA = (ch & 0x000000FF);
 1783              		.loc 1 184 0
 1784 0138 E5023FE7 		str	r3, [r2, #-4071]
 1785              	.LVL207:
 1786              	.LBE747:
 1787              	.LBE748:
  10:../lib/uart.c **** 	while ((ch = *string)){
 1788              		.loc 2 10 0
 1789 013c E5F03001 		ldrb	r3, [r0, #1]!	@ zero_extendqisi2
 1790              	.LVL208:
 1791 0140 E3530000 		cmp	r3, #0
 1792 0144 1AFFFFF7 		bne	.L412
 1793              	.LVL209:
 1794              	.L225:
 1795              	.LBE744:
 1796              	.LBE743:
 1797              	.LBB749:
 1798              	.LBB750:
 166:../lib/io_driver.c **** 	if ((UART0_SREG & (1<<CUART_RXD)) != 0) // byte available?
 1799              		.loc 1 166 0
 1800 0148 E3E03A0F 		mvn	r3, #61440
 1801 014c E5132FE3 		ldr	r2, [r3, #-4067]
 1802 0150 E3120002 		tst	r2, #2
 167:../lib/io_driver.c **** 		temp = UART0_DATA;
 1803              		.loc 1 167 0
 1804 0154 15133FE7 		ldrne	r3, [r3, #-4071]
 166:../lib/io_driver.c **** 	if ((UART0_SREG & (1<<CUART_RXD)) != 0) // byte available?
 1805              		.loc 1 166 0
 1806 0158 1AFFFFC6 		bne	.L182
 169:../lib/io_driver.c **** 		temp = -1;
 1807              		.loc 1 169 0
 1808 015c E3E03000 		mvn	r3, #0
 1809              	.LVL210:
 1810              	.LBE750:
 1811              	.LBE749:
 1812              	.LBB751:
 1813              	.LBB728:
 389:../lib/io_driver.c **** 		case SYS_IO:     asm volatile ("mrc p15,0,%0,c13,c13" : "=r" (_cp_val) : /* no inputs */  ); brea
 1814              		.loc 1 389 0
 1815              	@ 389 "../lib/io_driver.c" 1
 1816 0160 EE1D2F1D 		mrc p15,0,r2,c13,c13
 1817              	@ 0 "" 2
 1818              	.LVL211:
 1819              	.LBE728:
 1820              	.LBE751:
  89:main.c        **** 		if (((get_syscpreg(SYS_IO) >> 16) & 0x01) == 0){
 1821              		.loc 4 89 0
 1822 0164 E3120801 		tst	r2, #65536
 1823 0168 1AFFFFC5 		bne	.L598
 1824              	.L525:
  91:main.c        **** 			start_app    = 1;
 1825              		.loc 4 91 0
 1826 016c E3A07001 		mov	r7, #1
 1827              	.LVL212:
  92:main.c        **** 			device_id    = 0xA0;
 1828              		.loc 4 92 0
 1829 0170 E3A040A0 		mov	r4, #160
 1830              	.LVL213:
 1831              	.L227:
 1832 0174 E59F3E74 		ldr	r3, .L609+12
 1833              	.LBB752:
 1834              	.LBB753:
  10:../lib/uart.c **** 	while ((ch = *string)){
 1835              		.loc 2 10 0
 1836 0178 E3A0600D 		mov	r6, #13
 1837              	.LBB754:
 1838              	.LBB755:
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 1839              		.loc 1 183 0
 1840 017c E3E02A0F 		mvn	r2, #61440
 1841              	.LVL214:
 1842              	.L300:
 1843 0180 E5121FE3 		ldr	r1, [r2, #-4067]
 1844 0184 E3110001 		tst	r1, #1
 1845 0188 E3E01A0F 		mvn	r1, #61440
 1846 018c 0AFFFFFB 		beq	.L300
 184:../lib/io_driver.c **** 	UART0_DATA = (ch & 0x000000FF);
 1847              		.loc 1 184 0
 1848 0190 E5016FE7 		str	r6, [r1, #-4071]
 1849              	.LVL215:
 1850              	.LBE755:
 1851              	.LBE754:
  10:../lib/uart.c **** 	while ((ch = *string)){
 1852              		.loc 2 10 0
 1853 0194 E5F36001 		ldrb	r6, [r3, #1]!	@ zero_extendqisi2
 1854              	.LVL216:
 1855 0198 E3560000 		cmp	r6, #0
 1856 019c 1AFFFFF7 		bne	.L300
 1857              	.LVL217:
 1858              	.LBE753:
 1859              	.LBE752:
  97:main.c        **** 
  98:main.c        **** 			// boot from RAM (start application)
  99:main.c        **** 			// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 100:main.c        **** 			case '0':
 101:main.c        **** 				io_uart0_send_byte((char)function_sel);
 102:main.c        **** 				start_app = 1;
 103:main.c        **** 				break;
 104:main.c        **** 
 105:main.c        **** 			// load ram via UART0
 106:main.c        **** 			// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 107:main.c        **** 			case '1':
 108:main.c        **** 				io_uart0_send_byte((char)function_sel);
 109:main.c        **** 				uart0_printf("\r\n\r\nApplication will start automatically after download.\r\n-> Waiting for 's
 110:main.c        **** 				uart0_scanf(buffer,4,0); // get storm master boot record code
 111:main.c        **** 				if((buffer[0] == 'S') && (buffer[1] == 'M') && (buffer[2] == 'B') && (buffer[3] == 'R')){
 112:main.c        **** 					uart0_scanf(buffer,4,0); // get image size
 113:main.c        **** 					adr_buffer = qbytes_to_long(buffer);
 114:main.c        **** 					if (adr_buffer > RAM_SIZE-8){
 115:main.c        **** 						uart0_printf(" ERROR! Program file too big!\r\n\r\n");
 116:main.c        **** 						break;
 117:main.c        **** 					}
 118:main.c        **** 					data_pointer = 0;
 119:main.c        **** 					while(data_pointer != adr_buffer+4){
 120:main.c        **** 						uart0_scanf(buffer,4,0); // get word
 121:main.c        **** 						*data_pointer = qbytes_to_long(buffer); // store memory entry
 122:main.c        **** 						data_pointer = data_pointer + 1;
 123:main.c        **** 					}
 124:main.c        **** 					start_app = 1;
 125:main.c        **** 				}
 126:main.c        **** 				else
 127:main.c        **** 					uart0_printf(" Invalid programming file!\r\n\r\nSelect: ");
 128:main.c        **** 				break;
 129:main.c        **** 
 130:main.c        **** 			// ram memory dump
 131:main.c        **** 			// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 132:main.c        **** 			case '2':
 133:main.c        **** 				io_uart0_send_byte((char)function_sel);
 134:main.c        **** 				uart0_printf("\r\n\r\nAbort dumping by pressing any key.\r\nPress any key to continue.\r\n\r\n"
 135:main.c        **** 				while(io_uart0_read_byte() == -1);
 136:main.c        **** 				while(io_uart0_read_byte() != -1);
 137:main.c        **** 				data_pointer = 0;
 138:main.c        **** 				while(data_pointer != RAM_SIZE){
 139:main.c        **** 					word_buffer = *data_pointer;
 140:main.c        **** 					io_uart0_send_byte(word_buffer >> 24);
 141:main.c        **** 					io_uart0_send_byte(word_buffer >> 16);
 142:main.c        **** 					io_uart0_send_byte(word_buffer >>  8);
 143:main.c        **** 					io_uart0_send_byte(word_buffer >>  0);
 144:main.c        **** 					data_pointer++;
 145:main.c        **** 					if(io_uart0_read_byte() != -1){
 146:main.c        **** 						break;
 147:main.c        **** 						uart0_printf("\r\n\r\nAborted!");
 148:main.c        **** 					}
 149:main.c        **** 				}
 150:main.c        **** 				uart0_printf("\r\n\r\nDumping completed.\r\n\r\nSelect: ");
 151:main.c        **** 				break;
 152:main.c        **** 
 153:main.c        **** 			// boot from I2C EEPROM
 154:main.c        **** 			// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 155:main.c        **** 			case '3':
 156:main.c        **** 				if(start_app == 0){
 157:main.c        **** 					io_uart0_send_byte((char)function_sel);
 158:main.c        **** 					uart0_printf("\r\n\r\nEnter device address (2x hex_chars, set LSB to '0'): ");
 159:main.c        **** 					uart0_scanf(buffer,2,1);
 160:main.c        **** 					device_id = (unsigned char)hex_string_to_long(buffer, 2);
 161:main.c        **** 					if(device_id == 0){
 162:main.c        **** 						uart0_printf(" Invalid address!\r\n\r\nSelect: ");
 163:main.c        **** 						break;
 164:main.c        **** 					}
 165:main.c        **** 				}
 166:main.c        **** 
 167:main.c        **** 				uart0_printf("\r\nApplication will start automatically after upload.\r\n-> Loading boot image..
 168:main.c        **** 				cnt = 0;
 169:main.c        **** 				buffer[0] = (unsigned char)io_i2c0_byte_transfer('r',device_id,cnt++,2,0x00);
 1860              		.loc 4 169 0
 1861 01a0 E1A01004 		mov	r1, r4
 1862 01a4 E1A02006 		mov	r2, r6
 1863 01a8 E3A03002 		mov	r3, #2
 1864              	.LVL218:
 1865 01ac E58D6000 		str	r6, [sp]
 1866 01b0 E3A00072 		mov	r0, #114
 1867 01b4 EBFFFFFE 		bl	io_i2c0_byte_transfer
 1868              	.LVL219:
 170:main.c        **** 				buffer[1] = (unsigned char)io_i2c0_byte_transfer('r',device_id,cnt++,2,0x00);
 1869              		.loc 4 170 0
 1870 01b8 E1A01004 		mov	r1, r4
 169:main.c        **** 				buffer[0] = (unsigned char)io_i2c0_byte_transfer('r',device_id,cnt++,2,0x00);
 1871              		.loc 4 169 0
 1872 01bc E5CD0008 		strb	r0, [sp, #8]
 1873              	.LVL220:
 1874              		.loc 4 170 0
 1875 01c0 E3A02001 		mov	r2, #1
 1876 01c4 E3A03002 		mov	r3, #2
 1877 01c8 E58D6000 		str	r6, [sp]
 1878 01cc E3A00072 		mov	r0, #114
 1879 01d0 EBFFFFFE 		bl	io_i2c0_byte_transfer
 1880              	.LVL221:
 171:main.c        **** 				buffer[2] = (unsigned char)io_i2c0_byte_transfer('r',device_id,cnt++,2,0x00);
 1881              		.loc 4 171 0
 1882 01d4 E3A02002 		mov	r2, #2
 1883 01d8 E1A03002 		mov	r3, r2
 170:main.c        **** 				buffer[1] = (unsigned char)io_i2c0_byte_transfer('r',device_id,cnt++,2,0x00);
 1884              		.loc 4 170 0
 1885 01dc E5CD0009 		strb	r0, [sp, #9]
 1886              	.LVL222:
 1887              		.loc 4 171 0
 1888 01e0 E1A01004 		mov	r1, r4
 1889 01e4 E58D6000 		str	r6, [sp]
 1890 01e8 E3A00072 		mov	r0, #114
 1891 01ec EBFFFFFE 		bl	io_i2c0_byte_transfer
 1892              	.LVL223:
 172:main.c        **** 				buffer[3] = (unsigned char)io_i2c0_byte_transfer('r',device_id,cnt++,2,0x00);
 1893              		.loc 4 172 0
 1894 01f0 E3A02003 		mov	r2, #3
 171:main.c        **** 				buffer[2] = (unsigned char)io_i2c0_byte_transfer('r',device_id,cnt++,2,0x00);
 1895              		.loc 4 171 0
 1896 01f4 E5CD000A 		strb	r0, [sp, #10]
 1897              	.LVL224:
 1898              		.loc 4 172 0
 1899 01f8 E3A03002 		mov	r3, #2
 1900 01fc E58D6000 		str	r6, [sp]
 1901 0200 E1A01004 		mov	r1, r4
 1902 0204 E3A00072 		mov	r0, #114
 1903 0208 EBFFFFFE 		bl	io_i2c0_byte_transfer
 1904              	.LVL225:
 173:main.c        **** 				if((buffer[0] == 'S') && (buffer[1] == 'M') && (buffer[2] == 'B') && (buffer[3] == 'R')){
 1905              		.loc 4 173 0
 1906 020c E5DD2008 		ldrb	r2, [sp, #8]	@ zero_extendqisi2
 172:main.c        **** 				buffer[3] = (unsigned char)io_i2c0_byte_transfer('r',device_id,cnt++,2,0x00);
 1907              		.loc 4 172 0
 1908 0210 E20030FF 		and	r3, r0, #255
 1909              		.loc 4 173 0
 1910 0214 E3520053 		cmp	r2, #83
 172:main.c        **** 				buffer[3] = (unsigned char)io_i2c0_byte_transfer('r',device_id,cnt++,2,0x00);
 1911              		.loc 4 172 0
 1912 0218 E5CD300B 		strb	r3, [sp, #11]
 1913              		.loc 4 173 0
 1914 021c 0A00016D 		beq	.L599
 1915              	.L302:
 1916 0220 E59F2DCC 		ldr	r2, .L609+16
 174:main.c        **** 					buffer[0] = (unsigned char)io_i2c0_byte_transfer('r',device_id,cnt++,2,0x00);
 175:main.c        **** 					buffer[1] = (unsigned char)io_i2c0_byte_transfer('r',device_id,cnt++,2,0x00);
 176:main.c        **** 					buffer[2] = (unsigned char)io_i2c0_byte_transfer('r',device_id,cnt++,2,0x00);
 177:main.c        **** 					buffer[3] = (unsigned char)io_i2c0_byte_transfer('r',device_id,cnt++,2,0x00);
 178:main.c        **** 					adr_buffer = qbytes_to_long(buffer);
 179:main.c        **** 					data_pointer = 0;
 1917              		.loc 4 179 0
 1918 0224 E3A03020 		mov	r3, #32
 1919              	.LBB756:
 1920              	.LBB757:
 1921              	.LBB758:
 1922              	.LBB759:
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 1923              		.loc 1 183 0
 1924 0228 E3E01A0F 		mvn	r1, #61440
 1925              	.L314:
 1926 022c E5110FE3 		ldr	r0, [r1, #-4067]
 1927 0230 E3100001 		tst	r0, #1
 1928 0234 E3E00A0F 		mvn	r0, #61440
 1929 0238 0AFFFFFB 		beq	.L314
 184:../lib/io_driver.c **** 	UART0_DATA = (ch & 0x000000FF);
 1930              		.loc 1 184 0
 1931 023c E5003FE7 		str	r3, [r0, #-4071]
 1932              	.LVL226:
 1933              	.LBE759:
 1934              	.LBE758:
  10:../lib/uart.c **** 	while ((ch = *string)){
 1935              		.loc 2 10 0
 1936 0240 E5F23001 		ldrb	r3, [r2, #1]!	@ zero_extendqisi2
 1937              	.LVL227:
 1938 0244 E3530000 		cmp	r3, #0
 1939 0248 1AFFFFF7 		bne	.L314
 1940              	.LVL228:
 1941              	.LBE757:
 1942              	.LBE756:
 180:main.c        **** 					while((data_pointer != adr_buffer+4) && (data_pointer < IRAM_SIZE)){
 181:main.c        **** 						buffer[0] = (unsigned char)io_i2c0_byte_transfer('r',device_id,cnt++,2,0x00);
 182:main.c        **** 						buffer[1] = (unsigned char)io_i2c0_byte_transfer('r',device_id,cnt++,2,0x00);
 183:main.c        **** 						buffer[2] = (unsigned char)io_i2c0_byte_transfer('r',device_id,cnt++,2,0x00);
 184:main.c        **** 						buffer[3] = (unsigned char)io_i2c0_byte_transfer('r',device_id,cnt++,2,0x00);
 185:main.c        **** 						*data_pointer = qbytes_to_long(buffer); // store memory entry
 186:main.c        **** 						data_pointer = data_pointer + 1;
 187:main.c        **** 					}
 188:main.c        **** 					uart0_printf(" Upload complete\r\n");
 189:main.c        **** 					start_app = 1;
 190:main.c        **** 				}
 191:main.c        **** 				else
 192:main.c        **** 					uart0_printf(" Invalid boot device or file!\r\n\r\nSelect: ");
 193:main.c        **** 				break;
 194:main.c        **** 
 195:main.c        **** 			// program I2C EEPROM
 196:main.c        **** 			// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 197:main.c        **** 			case '4':
 198:main.c        **** 				io_uart0_send_byte((char)function_sel);
 199:main.c        **** 				uart0_printf("\r\n\r\nEnter device address (2x hex_chars, set LSB to '0'): ");
 200:main.c        **** 				uart0_scanf(buffer,2,1);
 201:main.c        **** 				device_id = (unsigned char)hex_string_to_long(buffer, 2);
 202:main.c        **** 				if(device_id == 0){
 203:main.c        **** 					uart0_printf("\r\nInvalid address!\r\n\r\nSelect: ");
 204:main.c        **** 					break;
 205:main.c        **** 				}
 206:main.c        **** 
 207:main.c        **** 				uart0_printf("\r\nData will overwrite RAM content!\r\n-> Waiting for 'storm_program.bin' in byt
 208:main.c        **** 				uart0_scanf(buffer,4,0);
 209:main.c        **** 				if((buffer[0]=='S') && (buffer[1]=='M') && (buffer[2]=='B') && (buffer[3]=='R')){
 210:main.c        **** 					char_pointer = 0; // beginning of RAM
 211:main.c        **** 					*char_pointer++ = 'S'; asm volatile ("NOP");
 212:main.c        **** 					*char_pointer++ = 'M'; asm volatile ("NOP");
 213:main.c        **** 					*char_pointer++ = 'B'; asm volatile ("NOP");
 214:main.c        **** 					*char_pointer++ = 'R'; asm volatile ("NOP");
 215:main.c        **** 					uart0_scanf(buffer,4,0);
 216:main.c        **** 					*char_pointer++ = buffer[0];
 217:main.c        **** 					*char_pointer++ = buffer[1];
 218:main.c        **** 					*char_pointer++ = buffer[2];
 219:main.c        **** 					*char_pointer++ = buffer[3];
 220:main.c        **** 					cnt = qbytes_to_long(buffer);
 221:main.c        **** 					if(cnt > 0xFFFC){
 222:main.c        **** 						uart0_printf(" ERROR! Program file too big!\r\n\r\n");
 223:main.c        **** 						break;
 224:main.c        **** 					}
 225:main.c        **** 
 226:main.c        **** 					for(i=0; i<cnt+4; i++){
 227:main.c        **** 						data = -1;
 228:main.c        **** 						while(data == -1)
 229:main.c        **** 							data = io_uart0_read_byte();
 230:main.c        **** 						*char_pointer++ = (unsigned char)data;
 231:main.c        **** 					}
 232:main.c        **** 					uart0_printf(" Download completed\r\n");
 233:main.c        **** 
 234:main.c        **** 					uart0_printf("Writing buffer to i2c EEPROM...");
 235:main.c        **** 					char_pointer = 0; // beginning of RAM
 236:main.c        **** 					for(i=0; i<cnt+12; i++){
 237:main.c        **** 						char_tmp = *char_pointer++;
 238:main.c        **** 						while(io_i2c0_byte_transfer('w', device_id, i, 2, char_tmp) != 0);
 239:main.c        **** 					}
 240:main.c        **** 					uart0_printf(" Completed\r\n\r\n");
 241:main.c        **** 				}
 242:main.c        **** 				else
 243:main.c        **** 					uart0_printf(" Invalid boot device or file!\r\n\r\n");
 244:main.c        **** 				uart0_printf("Select: ");
 245:main.c        **** 				break;
 246:main.c        **** 
 247:main.c        **** 			// show content of I2C EEPROM
 248:main.c        **** 			// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 249:main.c        **** 			case '5':
 250:main.c        **** 				io_uart0_send_byte((char)function_sel);
 251:main.c        **** 				uart0_printf("\r\n\r\nEnter device address (2 hex-chars, set LSB to '0'): ");
 252:main.c        **** 				uart0_scanf(buffer,2,1);
 253:main.c        **** 				device_id = (unsigned char)hex_string_to_long(buffer, 2);
 254:main.c        **** 				if(device_id == 0){
 255:main.c        **** 					uart0_printf(" Invalid address!\r\n\r\nSelect: ");
 256:main.c        **** 					break;
 257:main.c        **** 				}
 258:main.c        **** 				uart0_printf("\r\n\r\nAbort dumping by pressing any key. If no data is shown,\r\n");
 259:main.c        **** 				uart0_printf("the selected device is not responding. Press any key to continue.\r\n\r\n");
 260:main.c        **** 				while(io_uart0_read_byte() == -1);
 261:main.c        **** 				while(io_uart0_read_byte() != -1);
 262:main.c        **** 				for(i=0; i<0xFFFF; i++){
 263:main.c        **** 						data = -1;
 264:main.c        **** 						while(data < 0){
 265:main.c        **** 							data = io_i2c0_byte_transfer('r', device_id, i, 2, 0x00);
 266:main.c        **** 							if(io_uart0_read_byte() != -1){
 267:main.c        **** 								function_sel = 'X';
 268:main.c        **** 								break;
 269:main.c        **** 							}
 270:main.c        **** 						}
 271:main.c        **** 						if(function_sel == 'X'){
 272:main.c        **** 							uart0_printf("\r\n\r\nAborted!");
 273:main.c        **** 							break;
 274:main.c        **** 						}
 275:main.c        **** 						io_uart0_send_byte(data);
 276:main.c        **** 				}
 277:main.c        **** 				uart0_printf("\r\n\r\nDumping completed.\r\n\r\nSelect: ");
 278:main.c        **** 				break;
 279:main.c        **** 
 280:main.c        **** 			// Automatic boot configuration
 281:main.c        **** 			// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 282:main.c        **** 			case 'a':
 283:main.c        **** 				io_uart0_send_byte((char)function_sel);
 284:main.c        **** 				uart0_printf("\r\n\r\nAutomatic boot configuration for power-up:\r\n");
 285:main.c        **** 				uart0_printf("[3210] configuration DIP switch\r\n 0000 - Start bootloader console\r\n 0001 - Au
 286:main.c        **** 				uart0_printf(" 0010 - Automatic boot from I2C EEPROM (Address 0xA0)\r\n\r\nSelect: ");
 287:main.c        **** 				break;
 288:main.c        **** 
 289:main.c        **** 			// Help screen
 290:main.c        **** 			// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 291:main.c        **** 			case 'h':
 292:main.c        **** 				io_uart0_send_byte((char)function_sel);
 293:main.c        **** 				uart0_printf("\r\n\r\nSTORM SoC bootloader\r\n");
 294:main.c        **** 				uart0_printf("'0': Execute program in RAM.\r\n");
 295:main.c        **** 				uart0_printf("'1': Write 'storm_program.bin' to the core's RAM via UART.\r\n");
 296:main.c        **** 				uart0_printf("'2': Print current content of complete core RAM.\r\n");
 297:main.c        **** 				uart0_printf("'3': Load boot image from EEPROM and start application.\r\n");
 298:main.c        **** 				uart0_printf("'4': Write 'storm_program.bin' to I2C EEPROM via UART.\r\n");
 299:main.c        **** 				uart0_printf("'5': Print content of I2C EEPROM.\r\n");
 300:main.c        **** 				uart0_printf("'a': Show DIP switch configurations for automatic boot.\r\n");
 301:main.c        **** 				uart0_printf("'h': Show this screen.\r\n");
 302:main.c        **** 				uart0_printf("'r': Reset system.\r\n\r\n");
 303:main.c        **** 				uart0_printf("Boot EEPROM: 24xxnnn (like 24AA64), 7 bit address + dont-care bit,\r\n");
 304:main.c        **** 				uart0_printf("connected to I2C_CONTROLLER_0, operating frequency is 100kHz,\r\n");
 305:main.c        **** 				uart0_printf("maximum EEPROM size = 65536 byte => 16 bit addresses,\r\n");
 306:main.c        **** 				uart0_printf("fixed boot device address: 0xA0\r\n\r\n");
 307:main.c        **** 				uart0_printf("Terminal setup: 9600 baud, 8 data bits, no parity, 1 stop bit\r\n\r\n");
 308:main.c        **** 				uart0_printf("For more information see the STORM Core / STORM SoC datasheet\r\n");
 309:main.c        **** 				uart0_printf("http://opencores.org/project,storm_core\r\n");
 310:main.c        **** 				uart0_printf("http://opencores.org/project,storm_soc\r\n");
 311:main.c        **** 				uart0_printf("Contact: stnolting@googlemail.com\r\n");
 312:main.c        **** 				uart0_printf("(c) 2012 by Stephan Nolting\r\n\r\nSelect: ");
 313:main.c        **** 				break;
 314:main.c        **** 
 315:main.c        **** 			// back to the future
 316:main.c        **** 			// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 317:main.c        **** 			case 'f':
 318:main.c        **** 				io_uart0_send_byte((char)function_sel);
 319:main.c        **** 				uart0_printf("\r\n\r\nWe'll send you back - to the future!.\r\n\r\n");
 320:main.c        **** 				uart0_printf(" - Doctor Emmet L. Brown\r\n\r\nSelect: ");
 321:main.c        **** 				break;
 322:main.c        **** 
 323:main.c        **** 			// restart system
 324:main.c        **** 			// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 325:main.c        **** 			case 'r':
 326:main.c        **** 				io_uart0_send_byte((char)function_sel);
 327:main.c        **** 				asm volatile ("mov r0,     #0x0FF00000");
 328:main.c        **** 				asm volatile ("add pc, r0, #0xF0000000"); // jump to bootloader
 329:main.c        **** 				while(1);
 330:main.c        **** 				break;
 331:main.c        **** 
 332:main.c        **** 			// no input
 333:main.c        **** 			// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 334:main.c        **** 			case -1:
 335:main.c        **** 				break;
 336:main.c        **** 
 337:main.c        **** 			// invalid selection
 338:main.c        **** 			// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 339:main.c        **** 			default:
 340:main.c        **** 				io_uart0_send_byte((char)function_sel);
 341:main.c        **** 				uart0_printf(" Invalid operation!\r\nTry again: ");
 342:main.c        **** 				break;
 343:main.c        **** 
 344:main.c        **** 		}
 345:main.c        **** 
 346:main.c        **** 		// start application request
 347:main.c        **** 		if(start_app != 0)
 1943              		.loc 4 347 0
 1944 024c E3570000 		cmp	r7, #0
 1945 0250 0AFFFFBC 		beq	.L225
 1946              	.LVL229:
 1947              	.L512:
 1948 0254 E59F0D9C 		ldr	r0, .L609+20
 1949              	.LBB760:
 1950              	.LBB761:
  10:../lib/uart.c **** 	while ((ch = *string)){
 1951              		.loc 2 10 0
 1952 0258 E3A0100D 		mov	r1, #13
 1953              	.LBB762:
 1954              	.LBB763:
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 1955              		.loc 1 183 0
 1956 025c E3E02A0F 		mvn	r2, #61440
 1957              	.LVL230:
 1958              	.L514:
 1959 0260 E5123FE3 		ldr	r3, [r2, #-4067]
 1960 0264 E3130001 		tst	r3, #1
 1961 0268 E3E03A0F 		mvn	r3, #61440
 1962 026c 0AFFFFFB 		beq	.L514
 184:../lib/io_driver.c **** 	UART0_DATA = (ch & 0x000000FF);
 1963              		.loc 1 184 0
 1964 0270 E5031FE7 		str	r1, [r3, #-4071]
 1965              	.LVL231:
 1966              	.LBE763:
 1967              	.LBE762:
  10:../lib/uart.c **** 	while ((ch = *string)){
 1968              		.loc 2 10 0
 1969 0274 E5F01001 		ldrb	r1, [r0, #1]!	@ zero_extendqisi2
 1970              	.LVL232:
 1971 0278 E3510000 		cmp	r1, #0
 1972 027c 1AFFFFF7 		bne	.L514
 1973              	.LVL233:
 1974              	.LBE761:
 1975              	.LBE760:
 1976              	.LBB764:
 1977              	.LBB765:
 416:../lib/io_driver.c **** 		case SYS_IO:     asm volatile ("mcr p15,0,%0,c13,c13,0" : /* no outputs */ : "r" (_cp_val)); brea
 1978              		.loc 1 416 0
 1979              	@ 416 "../lib/io_driver.c" 1
 1980 0280 EE0D1F1D 		mcr p15,0,r1,c13,c13,0
 1981              	@ 0 "" 2
 1982              	.LVL234:
 1983              	.LBE765:
 1984              	.LBE764:
 1985              	.LBB766:
 1986              	.LBB767:
 382:../lib/io_driver.c **** 		case SYS_CTRL_0: asm volatile ("mrc p15,0,%0, c6, c6" : "=r" (_cp_val) : /* no inputs */  ); brea
 1987              		.loc 1 382 0
 1988              	@ 382 "../lib/io_driver.c" 1
 1989 0284 EE163F16 		mrc p15,0,r3, c6, c6
 1990              	@ 0 "" 2
 1991              	.LVL235:
 1992              	.LBE767:
 1993              	.LBE766:
 348:main.c        **** 			break;
 349:main.c        **** 
 350:main.c        **** 	}
 351:main.c        **** 
 352:main.c        **** 	// start application
 353:main.c        **** 	uart0_printf("\r\n\r\n-> Starting application...\r\n\r\n");
 354:main.c        **** 	set_syscpreg(0x00, SYS_IO);
 355:main.c        **** 
 356:main.c        **** 	// disable write-through strategy
 357:main.c        **** 	set_syscpreg(get_syscpreg(SYS_CTRL_0) & ~(1<<DC_WTHRU), SYS_CTRL_0);
 1994              		.loc 4 357 0
 1995 0288 E3C33008 		bic	r3, r3, #8
 1996              	.LVL236:
 1997              	.LBB768:
 1998              	.LBB769:
 409:../lib/io_driver.c **** 		case SYS_CTRL_0: asm volatile ("mcr p15,0,%0, c6, c6,0" : /* no outputs */ : "r" (_cp_val)); brea
 1999              		.loc 1 409 0
 2000              	@ 409 "../lib/io_driver.c" 1
 2001 028c EE063F16 		mcr p15,0,r3, c6, c6,0
 2002              	@ 0 "" 2
 2003              	.LBE769:
 2004              	.LBE768:
 358:main.c        **** 
 359:main.c        **** 	// jump to application
 360:main.c        **** 	asm volatile ("mov pc, #0");
 2005              		.loc 4 360 0
 2006              	@ 360 "main.c" 1
 2007 0290 E3A0F000 		mov pc, #0
 2008              	@ 0 "" 2
 2009              	.L516:
 2010 0294 EAFFFFFE 		b	.L516
 2011              	.LVL237:
 2012              	.L181:
  43:main.c        **** 	int function_sel, data, i, start_app = 0;
 2013              		.loc 4 43 0
 2014 0298 E3A07000 		mov	r7, #0
  60:main.c        **** 		case 1: function_sel = '0'; goto main_menu; break; // auto start application from RAM
 2015              		.loc 4 60 0
 2016 029c E3A03030 		mov	r3, #48
 2017              	.LVL238:
 2018 02a0 E28D5008 		add	r5, sp, #8
 2019 02a4 EAFFFF73 		b	.L182
 2020              	.LVL239:
 2021              	.L238:
  96:main.c        **** 		switch(function_sel){
 2022              		.loc 4 96 0
 2023 02a8 E3530068 		cmp	r3, #104
 2024 02ac 0A0001A1 		beq	.L241
 2025 02b0 E3530072 		cmp	r3, #114
 2026              	.LBB770:
 2027              	.LBB771:
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 2028              		.loc 1 183 0
 2029 02b4 03E02A0F 		mvneq	r2, #61440
 2030              	.LVL240:
 2031              	.LBE771:
 2032              	.LBE770:
  96:main.c        **** 		switch(function_sel){
 2033              		.loc 4 96 0
 2034 02b8 1A00028E 		bne	.L228
 2035              	.LVL241:
 2036              	.L505:
 2037              	.LBB773:
 2038              	.LBB772:
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 2039              		.loc 1 183 0
 2040 02bc E5123FE3 		ldr	r3, [r2, #-4067]
 2041 02c0 E3130001 		tst	r3, #1
 2042 02c4 E3E03A0F 		mvn	r3, #61440
 2043 02c8 0AFFFFFB 		beq	.L505
 184:../lib/io_driver.c **** 	UART0_DATA = (ch & 0x000000FF);
 2044              		.loc 1 184 0
 2045 02cc E3A02072 		mov	r2, #114
 2046 02d0 E5032FE7 		str	r2, [r3, #-4071]
 2047              	.LBE772:
 2048              	.LBE773:
 327:main.c        **** 				asm volatile ("mov r0,     #0x0FF00000");
 2049              		.loc 4 327 0
 2050              	@ 327 "main.c" 1
 2051 02d4 E3A006FF 		mov r0,     #0x0FF00000
 2052              	@ 0 "" 2
 328:main.c        **** 				asm volatile ("add pc, r0, #0xF0000000"); // jump to bootloader
 2053              		.loc 4 328 0
 2054              	@ 328 "main.c" 1
 2055 02d8 E280F20F 		add pc, r0, #0xF0000000
 2056              	@ 0 "" 2
 2057              	.L506:
 2058 02dc EAFFFFFE 		b	.L506
 2059              	.LVL242:
 2060              	.L596:
 2061 02e0 E59F0D14 		ldr	r0, .L609+24
 2062              	.LBB774:
 2063              	.LBB775:
  10:../lib/uart.c **** 	while ((ch = *string)){
 2064              		.loc 2 10 0
 2065 02e4 E3A0100D 		mov	r1, #13
 2066              	.LBB776:
 2067              	.LBB777:
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 2068              		.loc 1 183 0
 2069 02e8 E3E02A0F 		mvn	r2, #61440
 2070              	.LVL243:
 2071              	.L184:
 2072 02ec E5123FE3 		ldr	r3, [r2, #-4067]
 2073 02f0 E3130001 		tst	r3, #1
 2074 02f4 E3E03A0F 		mvn	r3, #61440
 2075 02f8 0AFFFFFB 		beq	.L184
 184:../lib/io_driver.c **** 	UART0_DATA = (ch & 0x000000FF);
 2076              		.loc 1 184 0
 2077 02fc E5031FE7 		str	r1, [r3, #-4071]
 2078              	.LVL244:
 2079              	.LBE777:
 2080              	.LBE776:
  10:../lib/uart.c **** 	while ((ch = *string)){
 2081              		.loc 2 10 0
 2082 0300 E5F01001 		ldrb	r1, [r0, #1]!	@ zero_extendqisi2
 2083              	.LVL245:
 2084 0304 E3510000 		cmp	r1, #0
 2085 0308 1AFFFFF7 		bne	.L184
 2086 030c E59F0CEC 		ldr	r0, .L609+28
 2087              	.LVL246:
 2088              	.LBE775:
 2089              	.LBE774:
 2090              	.LBB778:
 2091              	.LBB779:
 2092              	.LBB780:
 2093              	.LBB781:
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 2094              		.loc 1 183 0
 2095 0310 E1A02003 		mov	r2, r3
 2096              	.LBE781:
 2097              	.LBE780:
  10:../lib/uart.c **** 	while ((ch = *string)){
 2098              		.loc 2 10 0
 2099 0314 E3A0107C 		mov	r1, #124
 2100              	.LVL247:
 2101              	.L188:
 2102              	.LBB783:
 2103              	.LBB782:
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 2104              		.loc 1 183 0
 2105 0318 E5123FE3 		ldr	r3, [r2, #-4067]
 2106 031c E3130001 		tst	r3, #1
 2107 0320 E3E03A0F 		mvn	r3, #61440
 2108 0324 0AFFFFFB 		beq	.L188
 184:../lib/io_driver.c **** 	UART0_DATA = (ch & 0x000000FF);
 2109              		.loc 1 184 0
 2110 0328 E5031FE7 		str	r1, [r3, #-4071]
 2111              	.LVL248:
 2112              	.LBE782:
 2113              	.LBE783:
  10:../lib/uart.c **** 	while ((ch = *string)){
 2114              		.loc 2 10 0
 2115 032c E5F01001 		ldrb	r1, [r0, #1]!	@ zero_extendqisi2
 2116              	.LVL249:
 2117 0330 E3510000 		cmp	r1, #0
 2118 0334 1AFFFFF7 		bne	.L188
 2119 0338 E59F0CC4 		ldr	r0, .L609+32
 2120              	.LVL250:
 2121              	.LBE779:
 2122              	.LBE778:
 2123              	.LBB784:
 2124              	.LBB785:
 2125              	.LBB786:
 2126              	.LBB787:
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 2127              		.loc 1 183 0
 2128 033c E1A02003 		mov	r2, r3
 2129              	.LBE787:
 2130              	.LBE786:
  10:../lib/uart.c **** 	while ((ch = *string)){
 2131              		.loc 2 10 0
 2132 0340 E3A0102B 		mov	r1, #43
 2133              	.LVL251:
 2134              	.L192:
 2135              	.LBB789:
 2136              	.LBB788:
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 2137              		.loc 1 183 0
 2138 0344 E5123FE3 		ldr	r3, [r2, #-4067]
 2139 0348 E3130001 		tst	r3, #1
 2140 034c E3E03A0F 		mvn	r3, #61440
 2141 0350 0AFFFFFB 		beq	.L192
 184:../lib/io_driver.c **** 	UART0_DATA = (ch & 0x000000FF);
 2142              		.loc 1 184 0
 2143 0354 E5031FE7 		str	r1, [r3, #-4071]
 2144              	.LVL252:
 2145              	.LBE788:
 2146              	.LBE789:
  10:../lib/uart.c **** 	while ((ch = *string)){
 2147              		.loc 2 10 0
 2148 0358 E5F01001 		ldrb	r1, [r0, #1]!	@ zero_extendqisi2
 2149              	.LVL253:
 2150 035c E3510000 		cmp	r1, #0
 2151 0360 1AFFFFF7 		bne	.L192
 2152 0364 E59F0C9C 		ldr	r0, .L609+36
 2153              	.LVL254:
 2154              	.LBE785:
 2155              	.LBE784:
 2156              	.LBB790:
 2157              	.LBB791:
 2158              	.LBB792:
 2159              	.LBB793:
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 2160              		.loc 1 183 0
 2161 0368 E1A02003 		mov	r2, r3
 2162              	.LBE793:
 2163              	.LBE792:
  10:../lib/uart.c **** 	while ((ch = *string)){
 2164              		.loc 2 10 0
 2165 036c E3A0107C 		mov	r1, #124
 2166              	.LVL255:
 2167              	.L196:
 2168              	.LBB795:
 2169              	.LBB794:
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 2170              		.loc 1 183 0
 2171 0370 E5123FE3 		ldr	r3, [r2, #-4067]
 2172 0374 E3130001 		tst	r3, #1
 2173 0378 E3E03A0F 		mvn	r3, #61440
 2174 037c 0AFFFFFB 		beq	.L196
 184:../lib/io_driver.c **** 	UART0_DATA = (ch & 0x000000FF);
 2175              		.loc 1 184 0
 2176 0380 E5031FE7 		str	r1, [r3, #-4071]
 2177              	.LVL256:
 2178              	.LBE794:
 2179              	.LBE795:
  10:../lib/uart.c **** 	while ((ch = *string)){
 2180              		.loc 2 10 0
 2181 0384 E5F01001 		ldrb	r1, [r0, #1]!	@ zero_extendqisi2
 2182              	.LVL257:
 2183 0388 E3510000 		cmp	r1, #0
 2184 038c 1AFFFFF7 		bne	.L196
 2185 0390 E59F0C74 		ldr	r0, .L609+40
 2186              	.LVL258:
 2187              	.LBE791:
 2188              	.LBE790:
 2189              	.LBB796:
 2190              	.LBB797:
 2191              	.LBB798:
 2192              	.LBB799:
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 2193              		.loc 1 183 0
 2194 0394 E1A02003 		mov	r2, r3
 2195              	.LBE799:
 2196              	.LBE798:
  10:../lib/uart.c **** 	while ((ch = *string)){
 2197              		.loc 2 10 0
 2198 0398 E3A0107C 		mov	r1, #124
 2199              	.LVL259:
 2200              	.L200:
 2201              	.LBB801:
 2202              	.LBB800:
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 2203              		.loc 1 183 0
 2204 039c E5123FE3 		ldr	r3, [r2, #-4067]
 2205 03a0 E3130001 		tst	r3, #1
 2206 03a4 E3E03A0F 		mvn	r3, #61440
 2207 03a8 0AFFFFFB 		beq	.L200
 184:../lib/io_driver.c **** 	UART0_DATA = (ch & 0x000000FF);
 2208              		.loc 1 184 0
 2209 03ac E5031FE7 		str	r1, [r3, #-4071]
 2210              	.LVL260:
 2211              	.LBE800:
 2212              	.LBE801:
  10:../lib/uart.c **** 	while ((ch = *string)){
 2213              		.loc 2 10 0
 2214 03b0 E5F01001 		ldrb	r1, [r0, #1]!	@ zero_extendqisi2
 2215              	.LVL261:
 2216 03b4 E3510000 		cmp	r1, #0
 2217 03b8 1AFFFFF7 		bne	.L200
 2218 03bc E59F0C4C 		ldr	r0, .L609+44
 2219              	.LVL262:
 2220              	.LBE797:
 2221              	.LBE796:
 2222              	.LBB802:
 2223              	.LBB803:
 2224              	.LBB804:
 2225              	.LBB805:
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 2226              		.loc 1 183 0
 2227 03c0 E1A02003 		mov	r2, r3
 2228              	.LBE805:
 2229              	.LBE804:
  10:../lib/uart.c **** 	while ((ch = *string)){
 2230              		.loc 2 10 0
 2231 03c4 E3A0102B 		mov	r1, #43
 2232              	.LVL263:
 2233              	.L204:
 2234              	.LBB807:
 2235              	.LBB806:
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 2236              		.loc 1 183 0
 2237 03c8 E5123FE3 		ldr	r3, [r2, #-4067]
 2238 03cc E3130001 		tst	r3, #1
 2239 03d0 E3E03A0F 		mvn	r3, #61440
 2240 03d4 0AFFFFFB 		beq	.L204
 184:../lib/io_driver.c **** 	UART0_DATA = (ch & 0x000000FF);
 2241              		.loc 1 184 0
 2242 03d8 E5031FE7 		str	r1, [r3, #-4071]
 2243              	.LVL264:
 2244              	.LBE806:
 2245              	.LBE807:
  10:../lib/uart.c **** 	while ((ch = *string)){
 2246              		.loc 2 10 0
 2247 03dc E5F01001 		ldrb	r1, [r0, #1]!	@ zero_extendqisi2
 2248              	.LVL265:
 2249 03e0 E3510000 		cmp	r1, #0
 2250 03e4 1AFFFFF7 		bne	.L204
 2251 03e8 E59F0C24 		ldr	r0, .L609+48
 2252              	.LVL266:
 2253              	.LBE803:
 2254              	.LBE802:
 2255              	.LBB808:
 2256              	.LBB809:
 2257              	.LBB810:
 2258              	.LBB811:
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 2259              		.loc 1 183 0
 2260 03ec E1A02003 		mov	r2, r3
 2261              	.LBE811:
 2262              	.LBE810:
  10:../lib/uart.c **** 	while ((ch = *string)){
 2263              		.loc 2 10 0
 2264 03f0 E3A01020 		mov	r1, #32
 2265              	.LVL267:
 2266              	.L208:
 2267              	.LBB813:
 2268              	.LBB812:
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 2269              		.loc 1 183 0
 2270 03f4 E5123FE3 		ldr	r3, [r2, #-4067]
 2271 03f8 E3130001 		tst	r3, #1
 2272 03fc E3E03A0F 		mvn	r3, #61440
 2273 0400 0AFFFFFB 		beq	.L208
 184:../lib/io_driver.c **** 	UART0_DATA = (ch & 0x000000FF);
 2274              		.loc 1 184 0
 2275 0404 E5031FE7 		str	r1, [r3, #-4071]
 2276              	.LVL268:
 2277              	.LBE812:
 2278              	.LBE813:
  10:../lib/uart.c **** 	while ((ch = *string)){
 2279              		.loc 2 10 0
 2280 0408 E5F01001 		ldrb	r1, [r0, #1]!	@ zero_extendqisi2
 2281              	.LVL269:
 2282 040c E3510000 		cmp	r1, #0
 2283 0410 1AFFFFF7 		bne	.L208
 2284 0414 E59F0BFC 		ldr	r0, .L609+52
 2285              	.LVL270:
 2286              	.LBE809:
 2287              	.LBE808:
 2288              	.LBB814:
 2289              	.LBB815:
 2290              	.LBB816:
 2291              	.LBB817:
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 2292              		.loc 1 183 0
 2293 0418 E1A02003 		mov	r2, r3
 2294              	.LBE817:
 2295              	.LBE816:
  10:../lib/uart.c **** 	while ((ch = *string)){
 2296              		.loc 2 10 0
 2297 041c E3A01020 		mov	r1, #32
 2298              	.LVL271:
 2299              	.L212:
 2300              	.LBB819:
 2301              	.LBB818:
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 2302              		.loc 1 183 0
 2303 0420 E5123FE3 		ldr	r3, [r2, #-4067]
 2304 0424 E3130001 		tst	r3, #1
 2305 0428 E3E03A0F 		mvn	r3, #61440
 2306 042c 0AFFFFFB 		beq	.L212
 184:../lib/io_driver.c **** 	UART0_DATA = (ch & 0x000000FF);
 2307              		.loc 1 184 0
 2308 0430 E5031FE7 		str	r1, [r3, #-4071]
 2309              	.LVL272:
 2310              	.LBE818:
 2311              	.LBE819:
  10:../lib/uart.c **** 	while ((ch = *string)){
 2312              		.loc 2 10 0
 2313 0434 E5F01001 		ldrb	r1, [r0, #1]!	@ zero_extendqisi2
 2314              	.LVL273:
 2315 0438 E3510000 		cmp	r1, #0
 2316 043c 1AFFFFF7 		bne	.L212
 2317 0440 E59F0BD4 		ldr	r0, .L609+56
 2318              	.LVL274:
 2319              	.LBE815:
 2320              	.LBE814:
 2321              	.LBB820:
 2322              	.LBB821:
 2323              	.LBB822:
 2324              	.LBB823:
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 2325              		.loc 1 183 0
 2326 0444 E1A02003 		mov	r2, r3
 2327              	.LBE823:
 2328              	.LBE822:
  10:../lib/uart.c **** 	while ((ch = *string)){
 2329              		.loc 2 10 0
 2330 0448 E3A01020 		mov	r1, #32
 2331              	.LVL275:
 2332              	.L216:
 2333              	.LBB825:
 2334              	.LBB824:
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 2335              		.loc 1 183 0
 2336 044c E5123FE3 		ldr	r3, [r2, #-4067]
 2337 0450 E3130001 		tst	r3, #1
 2338 0454 E3E03A0F 		mvn	r3, #61440
 2339 0458 0AFFFFFB 		beq	.L216
 184:../lib/io_driver.c **** 	UART0_DATA = (ch & 0x000000FF);
 2340              		.loc 1 184 0
 2341 045c E5031FE7 		str	r1, [r3, #-4071]
 2342              	.LVL276:
 2343              	.LBE824:
 2344              	.LBE825:
  10:../lib/uart.c **** 	while ((ch = *string)){
 2345              		.loc 2 10 0
 2346 0460 E5F01001 		ldrb	r1, [r0, #1]!	@ zero_extendqisi2
 2347              	.LVL277:
 2348 0464 E3510000 		cmp	r1, #0
 2349 0468 1AFFFFF7 		bne	.L216
 2350 046c E59F0BAC 		ldr	r0, .L609+60
 2351              	.LVL278:
 2352              	.LBE821:
 2353              	.LBE820:
 2354              	.LBB826:
 2355              	.LBB827:
 2356              	.LBB828:
 2357              	.LBB829:
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 2358              		.loc 1 183 0
 2359 0470 E1A02003 		mov	r2, r3
 2360              	.LBE829:
 2361              	.LBE828:
  10:../lib/uart.c **** 	while ((ch = *string)){
 2362              		.loc 2 10 0
 2363 0474 E3A01020 		mov	r1, #32
 2364              	.LVL279:
 2365              	.L220:
 2366              	.LBB831:
 2367              	.LBB830:
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 2368              		.loc 1 183 0
 2369 0478 E5123FE3 		ldr	r3, [r2, #-4067]
 2370 047c E3130001 		tst	r3, #1
 2371 0480 E3E03A0F 		mvn	r3, #61440
 2372 0484 0AFFFFFB 		beq	.L220
 184:../lib/io_driver.c **** 	UART0_DATA = (ch & 0x000000FF);
 2373              		.loc 1 184 0
 2374 0488 E5031FE7 		str	r1, [r3, #-4071]
 2375              	.LVL280:
 2376              	.LBE830:
 2377              	.LBE831:
  10:../lib/uart.c **** 	while ((ch = *string)){
 2378              		.loc 2 10 0
 2379 048c E5F01001 		ldrb	r1, [r0, #1]!	@ zero_extendqisi2
 2380              	.LVL281:
 2381 0490 E3510000 		cmp	r1, #0
 2382 0494 1AFFFFF7 		bne	.L220
 2383 0498 E59F1B84 		ldr	r1, .L609+64
 2384              	.LBE827:
 2385              	.LBE826:
 2386              	.LBB832:
 2387              	.LBB833:
 2388              	.LBB834:
 2389              	.LBB835:
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 2390              		.loc 1 183 0
 2391 049c E1A02003 		mov	r2, r3
 2392              	.LBE835:
 2393              	.LBE834:
  10:../lib/uart.c **** 	while ((ch = *string)){
 2394              		.loc 2 10 0
 2395 04a0 E3A07020 		mov	r7, #32
 2396              	.LVL282:
 2397              	.L224:
 2398              	.LBB837:
 2399              	.LBB836:
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 2400              		.loc 1 183 0
 2401 04a4 E5123FE3 		ldr	r3, [r2, #-4067]
 2402 04a8 E3130001 		tst	r3, #1
 2403 04ac E3E03A0F 		mvn	r3, #61440
 2404 04b0 0AFFFFFB 		beq	.L224
 184:../lib/io_driver.c **** 	UART0_DATA = (ch & 0x000000FF);
 2405              		.loc 1 184 0
 2406 04b4 E5037FE7 		str	r7, [r3, #-4071]
 2407              	.LVL283:
 2408              	.LBE836:
 2409              	.LBE837:
  10:../lib/uart.c **** 	while ((ch = *string)){
 2410              		.loc 2 10 0
 2411 04b8 E5F17001 		ldrb	r7, [r1, #1]!	@ zero_extendqisi2
 2412              	.LVL284:
 2413 04bc E3570000 		cmp	r7, #0
 2414 04c0 1AFFFFF7 		bne	.L224
 2415 04c4 E28D5008 		add	r5, sp, #8
 2416 04c8 EAFFFF1E 		b	.L225
 2417              	.LVL285:
 2418              	.L229:
 2419              	.LBE833:
 2420              	.LBE832:
 2421              	.LBB838:
 2422              	.LBB839:
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 2423              		.loc 1 183 0
 2424 04cc E3E03A0F 		mvn	r3, #61440
 2425              	.LVL286:
 2426              	.L316:
 2427 04d0 E5132FE3 		ldr	r2, [r3, #-4067]
 2428 04d4 E3120001 		tst	r2, #1
 2429 04d8 E3E01A0F 		mvn	r1, #61440
 2430 04dc 0AFFFFFB 		beq	.L316
 184:../lib/io_driver.c **** 	UART0_DATA = (ch & 0x000000FF);
 2431              		.loc 1 184 0
 2432 04e0 E3A03034 		mov	r3, #52
 2433 04e4 E59F0BE8 		ldr	r0, .L609+240
 2434 04e8 E5013FE7 		str	r3, [r1, #-4071]
 2435              	.LVL287:
 2436              	.LBE839:
 2437              	.LBE838:
 2438              	.LBB840:
 2439              	.LBB841:
  10:../lib/uart.c **** 	while ((ch = *string)){
 2440              		.loc 2 10 0
 2441 04ec E3A0300D 		mov	r3, #13
 2442              	.LVL288:
 2443              	.L318:
 2444              	.LBB842:
 2445              	.LBB843:
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 2446              		.loc 1 183 0
 2447 04f0 E5112FE3 		ldr	r2, [r1, #-4067]
 2448 04f4 E3120001 		tst	r2, #1
 2449 04f8 E3E06A0F 		mvn	r6, #61440
 2450 04fc 0AFFFFFB 		beq	.L318
 184:../lib/io_driver.c **** 	UART0_DATA = (ch & 0x000000FF);
 2451              		.loc 1 184 0
 2452 0500 E5063FE7 		str	r3, [r6, #-4071]
 2453              	.LVL289:
 2454              	.LBE843:
 2455              	.LBE842:
  10:../lib/uart.c **** 	while ((ch = *string)){
 2456              		.loc 2 10 0
 2457 0504 E5F03001 		ldrb	r3, [r0, #1]!	@ zero_extendqisi2
 2458              	.LVL290:
 2459 0508 E3530000 		cmp	r3, #0
 2460 050c 1AFFFFF7 		bne	.L318
 2461              	.LBE841:
 2462              	.LBE840:
 200:main.c        **** 				uart0_scanf(buffer,2,1);
 2463              		.loc 4 200 0
 2464 0510 E1A00005 		mov	r0, r5
 2465              	.LVL291:
 2466 0514 E3A01002 		mov	r1, #2
 2467 0518 E3A02001 		mov	r2, #1
 2468 051c EBFFFFFE 		bl	uart0_scanf
 2469              	.LVL292:
 201:main.c        **** 				device_id = (unsigned char)hex_string_to_long(buffer, 2);
 2470              		.loc 4 201 0
 2471 0520 E1A00005 		mov	r0, r5
 2472 0524 E3A01002 		mov	r1, #2
 2473 0528 EBFFFFFE 		bl	hex_string_to_long
 2474              	.LVL293:
 202:main.c        **** 				if(device_id == 0){
 2475              		.loc 4 202 0
 2476 052c E21040FF 		ands	r4, r0, #255
 2477              	.LVL294:
 2478 0530 1A00000A 		bne	.L321
 2479 0534 E59F2AEC 		ldr	r2, .L609+68
 2480              	.LBB844:
 2481              	.LBB845:
  10:../lib/uart.c **** 	while ((ch = *string)){
 2482              		.loc 2 10 0
 2483 0538 E3A0300D 		mov	r3, #13
 2484              	.L323:
 2485              	.LBB846:
 2486              	.LBB847:
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 2487              		.loc 1 183 0
 2488 053c E5161FE3 		ldr	r1, [r6, #-4067]
 2489 0540 E3110001 		tst	r1, #1
 2490 0544 E3E01A0F 		mvn	r1, #61440
 2491 0548 0AFFFFFB 		beq	.L323
 184:../lib/io_driver.c **** 	UART0_DATA = (ch & 0x000000FF);
 2492              		.loc 1 184 0
 2493 054c E5013FE7 		str	r3, [r1, #-4071]
 2494              	.LVL295:
 2495              	.LBE847:
 2496              	.LBE846:
  10:../lib/uart.c **** 	while ((ch = *string)){
 2497              		.loc 2 10 0
 2498 0550 E5F23001 		ldrb	r3, [r2, #1]!	@ zero_extendqisi2
 2499              	.LVL296:
 2500 0554 E3530000 		cmp	r3, #0
 2501 0558 1AFFFFF7 		bne	.L323
 2502 055c EAFFFEF9 		b	.L225
 2503              	.LVL297:
 2504              	.L321:
 2505 0560 E59F3AC4 		ldr	r3, .L609+72
 2506              	.LBE845:
 2507              	.LBE844:
 2508              	.LBB848:
 2509              	.LBB849:
 2510              	.LBB850:
 2511              	.LBB851:
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 2512              		.loc 1 183 0
 2513 0564 E1A02006 		mov	r2, r6
 2514              	.LBE851:
 2515              	.LBE850:
  10:../lib/uart.c **** 	while ((ch = *string)){
 2516              		.loc 2 10 0
 2517 0568 E3A0600D 		mov	r6, #13
 2518              	.L326:
 2519              	.LBB853:
 2520              	.LBB852:
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 2521              		.loc 1 183 0
 2522 056c E5121FE3 		ldr	r1, [r2, #-4067]
 2523 0570 E3110001 		tst	r1, #1
 2524 0574 E3E01A0F 		mvn	r1, #61440
 2525 0578 0AFFFFFB 		beq	.L326
 184:../lib/io_driver.c **** 	UART0_DATA = (ch & 0x000000FF);
 2526              		.loc 1 184 0
 2527 057c E5016FE7 		str	r6, [r1, #-4071]
 2528              	.LVL298:
 2529              	.LBE852:
 2530              	.LBE853:
  10:../lib/uart.c **** 	while ((ch = *string)){
 2531              		.loc 2 10 0
 2532 0580 E5F36001 		ldrb	r6, [r3, #1]!	@ zero_extendqisi2
 2533              	.LVL299:
 2534 0584 E3560000 		cmp	r6, #0
 2535 0588 1AFFFFF7 		bne	.L326
 2536              	.LBE849:
 2537              	.LBE848:
 208:main.c        **** 				uart0_scanf(buffer,4,0);
 2538              		.loc 4 208 0
 2539 058c E1A00005 		mov	r0, r5
 2540 0590 E3A01004 		mov	r1, #4
 2541 0594 E1A02006 		mov	r2, r6
 2542 0598 EBFFFFFE 		bl	uart0_scanf
 2543              	.LVL300:
 209:main.c        **** 				if((buffer[0]=='S') && (buffer[1]=='M') && (buffer[2]=='B') && (buffer[3]=='R')){
 2544              		.loc 4 209 0
 2545 059c E5DD3008 		ldrb	r3, [sp, #8]	@ zero_extendqisi2
 2546 05a0 E3530053 		cmp	r3, #83
 2547 05a4 0A000016 		beq	.L600
 2548              	.L329:
 2549 05a8 E59F2A80 		ldr	r2, .L609+76
 2550              	.LBB854:
 2551              	.LBB855:
  10:../lib/uart.c **** 	while ((ch = *string)){
 2552              		.loc 2 10 0
 2553 05ac E3A03020 		mov	r3, #32
 2554              	.LBE855:
 2555              	.LBE854:
 2556              	.LBB861:
 2557              	.LBB862:
 2558              	.LBB863:
 2559              	.LBB864:
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 2560              		.loc 1 183 0
 2561 05b0 E3E01A0F 		mvn	r1, #61440
 2562              	.L360:
 2563 05b4 E5110FE3 		ldr	r0, [r1, #-4067]
 2564 05b8 E3100001 		tst	r0, #1
 2565 05bc E3E00A0F 		mvn	r0, #61440
 2566 05c0 0AFFFFFB 		beq	.L360
 184:../lib/io_driver.c **** 	UART0_DATA = (ch & 0x000000FF);
 2567              		.loc 1 184 0
 2568 05c4 E5003FE7 		str	r3, [r0, #-4071]
 2569              	.LVL301:
 2570              	.LBE864:
 2571              	.LBE863:
  10:../lib/uart.c **** 	while ((ch = *string)){
 2572              		.loc 2 10 0
 2573 05c8 E5F23001 		ldrb	r3, [r2, #1]!	@ zero_extendqisi2
 2574              	.LVL302:
 2575 05cc E3530000 		cmp	r3, #0
 2576 05d0 1AFFFFF7 		bne	.L360
 2577              	.LVL303:
 2578              	.L358:
 2579 05d4 E59F2A58 		ldr	r2, .L609+80
 2580              	.LBE862:
 2581              	.LBE861:
 2582              	.LBB865:
 2583              	.LBB866:
 2584 05d8 E3A03053 		mov	r3, #83
 2585              	.LBB867:
 2586              	.LBB868:
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 2587              		.loc 1 183 0
 2588 05dc E3E01A0F 		mvn	r1, #61440
 2589              	.LVL304:
 2590              	.L362:
 2591 05e0 E5110FE3 		ldr	r0, [r1, #-4067]
 2592 05e4 E3100001 		tst	r0, #1
 2593 05e8 E3E00A0F 		mvn	r0, #61440
 2594 05ec 0AFFFFFB 		beq	.L362
 184:../lib/io_driver.c **** 	UART0_DATA = (ch & 0x000000FF);
 2595              		.loc 1 184 0
 2596 05f0 E5003FE7 		str	r3, [r0, #-4071]
 2597              	.LVL305:
 2598              	.LBE868:
 2599              	.LBE867:
  10:../lib/uart.c **** 	while ((ch = *string)){
 2600              		.loc 2 10 0
 2601 05f4 E5F23001 		ldrb	r3, [r2, #1]!	@ zero_extendqisi2
 2602              	.LVL306:
 2603 05f8 E3530000 		cmp	r3, #0
 2604 05fc 1AFFFFF7 		bne	.L362
 2605 0600 EAFFFED0 		b	.L225
 2606              	.LVL307:
 2607              	.L600:
 2608              	.LBE866:
 2609              	.LBE865:
 209:main.c        **** 				if((buffer[0]=='S') && (buffer[1]=='M') && (buffer[2]=='B') && (buffer[3]=='R')){
 2610              		.loc 4 209 0 discriminator 1
 2611 0604 E5DD2009 		ldrb	r2, [sp, #9]	@ zero_extendqisi2
 2612 0608 E352004D 		cmp	r2, #77
 2613 060c 1AFFFFE5 		bne	.L329
 2614 0610 E5DD200A 		ldrb	r2, [sp, #10]	@ zero_extendqisi2
 2615 0614 E3520042 		cmp	r2, #66
 2616 0618 1AFFFFE2 		bne	.L329
 2617 061c E5DD200B 		ldrb	r2, [sp, #11]	@ zero_extendqisi2
 2618 0620 E3520052 		cmp	r2, #82
 2619 0624 1AFFFFDF 		bne	.L329
 2620              	.LVL308:
 211:main.c        **** 					*char_pointer++ = 'S'; asm volatile ("NOP");
 2621              		.loc 4 211 0
 2622 0628 E5C63000 		strb	r3, [r6]
 2623              	@ 211 "main.c" 1
 2624 062c E1A00000 		NOP
 2625              	@ 0 "" 2
 2626              	.LVL309:
 212:main.c        **** 					*char_pointer++ = 'M'; asm volatile ("NOP");
 2627              		.loc 4 212 0
 2628 0630 E3A03000 		mov	r3, #0
 2629 0634 E3A0204D 		mov	r2, #77
 2630 0638 E5C32001 		strb	r2, [r3, #1]
 2631              	@ 212 "main.c" 1
 2632 063c E1A00000 		NOP
 2633              	@ 0 "" 2
 2634              	.LVL310:
 213:main.c        **** 					*char_pointer++ = 'B'; asm volatile ("NOP");
 2635              		.loc 4 213 0
 2636 0640 E3A02042 		mov	r2, #66
 2637 0644 E5C32002 		strb	r2, [r3, #2]
 2638              	@ 213 "main.c" 1
 2639 0648 E1A00000 		NOP
 2640              	@ 0 "" 2
 2641              	.LVL311:
 214:main.c        **** 					*char_pointer++ = 'R'; asm volatile ("NOP");
 2642              		.loc 4 214 0
 2643 064c E3A02052 		mov	r2, #82
 2644 0650 E5C32003 		strb	r2, [r3, #3]
 2645              	@ 214 "main.c" 1
 2646 0654 E1A00000 		NOP
 2647              	@ 0 "" 2
 215:main.c        **** 					uart0_scanf(buffer,4,0);
 2648              		.loc 4 215 0
 2649 0658 E3A01004 		mov	r1, #4
 2650 065c E1A00005 		mov	r0, r5
 2651 0660 E3A02000 		mov	r2, #0
 2652 0664 EBFFFFFE 		bl	uart0_scanf
 2653              	.LVL312:
 216:main.c        **** 					*char_pointer++ = buffer[0];
 2654              		.loc 4 216 0
 2655 0668 E5DD2008 		ldrb	r2, [sp, #8]	@ zero_extendqisi2
 2656 066c E3A03000 		mov	r3, #0
 2657 0670 E5C32004 		strb	r2, [r3, #4]
 2658              	.LVL313:
 217:main.c        **** 					*char_pointer++ = buffer[1];
 2659              		.loc 4 217 0
 2660 0674 E5DD2009 		ldrb	r2, [sp, #9]	@ zero_extendqisi2
 2661 0678 E5C32005 		strb	r2, [r3, #5]
 2662              	.LVL314:
 218:main.c        **** 					*char_pointer++ = buffer[2];
 2663              		.loc 4 218 0
 2664 067c E5DD200A 		ldrb	r2, [sp, #10]	@ zero_extendqisi2
 2665 0680 E5C32006 		strb	r2, [r3, #6]
 2666              	.LVL315:
 219:main.c        **** 					*char_pointer++ = buffer[3];
 2667              		.loc 4 219 0
 2668 0684 E5DD200B 		ldrb	r2, [sp, #11]	@ zero_extendqisi2
 2669 0688 E5C32007 		strb	r2, [r3, #7]
 2670              	.LVL316:
 2671              	.LBB869:
 2672              	.LBB870:
  34:main.c        **** 	n = a|(b<<8)|(c<<16)|(d<<24);
 2673              		.loc 4 34 0
 2674 068c E5DD1009 		ldrb	r1, [sp, #9]	@ zero_extendqisi2
 2675 0690 E5DD000A 		ldrb	r0, [sp, #10]	@ zero_extendqisi2
 2676 0694 E1A01801 		mov	r1, r1, asl #16
 2677 0698 E5DD200B 		ldrb	r2, [sp, #11]	@ zero_extendqisi2
 2678 069c E1811400 		orr	r1, r1, r0, asl #8
 2679 06a0 E5DD0008 		ldrb	r0, [sp, #8]	@ zero_extendqisi2
 2680 06a4 E1812002 		orr	r2, r1, r2
 2681              	.LBE870:
 2682              	.LBE869:
 221:main.c        **** 					if(cnt > 0xFFFC){
 2683              		.loc 4 221 0
 2684 06a8 E59F1988 		ldr	r1, .L609+84
 2685              	.LBB872:
 2686              	.LBB871:
  34:main.c        **** 	n = a|(b<<8)|(c<<16)|(d<<24);
 2687              		.loc 4 34 0
 2688 06ac E1822C00 		orr	r2, r2, r0, asl #24
 2689              	.LVL317:
 2690              	.LBE871:
 2691              	.LBE872:
 221:main.c        **** 					if(cnt > 0xFFFC){
 2692              		.loc 4 221 0
 2693 06b0 E1520001 		cmp	r2, r1
 2694 06b4 8A000018 		bhi	.L332
 2695              	.LBB873:
 2696              	.LBB874:
 166:../lib/io_driver.c **** 	if ((UART0_SREG & (1<<CUART_RXD)) != 0) // byte available?
 2697              		.loc 1 166 0
 2698 06b8 E3E01A0F 		mvn	r1, #61440
 2699 06bc E1A0E001 		mov	lr, r1
 2700 06c0 E282C004 		add	ip, r2, #4
 2701              	.LVL318:
 2702              	.L333:
 2703              	.LBE874:
 2704              	.LBE873:
 226:main.c        **** 					for(i=0; i<cnt+4; i++){
 2705              		.loc 4 226 0 discriminator 1
 2706 06c4 E15C0003 		cmp	ip, r3
 2707 06c8 9A000008 		bls	.L601
 2708              	.L339:
 2709              	.LVL319:
 2710              	.LBB876:
 2711              	.LBB875:
 166:../lib/io_driver.c **** 	if ((UART0_SREG & (1<<CUART_RXD)) != 0) // byte available?
 2712              		.loc 1 166 0
 2713 06cc E5110FE3 		ldr	r0, [r1, #-4067]
 2714 06d0 E3100002 		tst	r0, #2
 2715 06d4 0AFFFFFC 		beq	.L339
 167:../lib/io_driver.c **** 		temp = UART0_DATA;
 2716              		.loc 1 167 0
 2717 06d8 E51E0FE7 		ldr	r0, [lr, #-4071]
 2718              	.LVL320:
 2719              	.LBE875:
 2720              	.LBE876:
 228:main.c        **** 						while(data == -1)
 2721              		.loc 4 228 0
 2722 06dc E3700001 		cmn	r0, #1
 2723 06e0 0AFFFFF9 		beq	.L339
 2724              	.LVL321:
 230:main.c        **** 						*char_pointer++ = (unsigned char)data;
 2725              		.loc 4 230 0
 2726 06e4 E5C30008 		strb	r0, [r3, #8]
 226:main.c        **** 					for(i=0; i<cnt+4; i++){
 2727              		.loc 4 226 0
 2728 06e8 E2833001 		add	r3, r3, #1
 2729              	.LVL322:
 2730 06ec EAFFFFF4 		b	.L333
 2731              	.LVL323:
 2732              	.L601:
 2733              	.LBB877:
 2734              	.LBB878:
 2735              	.LBB879:
 2736              	.LBB880:
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 2737              		.loc 1 183 0
 2738 06f0 E3E01A0F 		mvn	r1, #61440
 2739 06f4 E59F3940 		ldr	r3, .L609+88
 2740              	.LVL324:
 2741 06f8 E1A0C001 		mov	ip, r1
 2742              	.L342:
 2743              	.LVL325:
 2744              	.LBE880:
 2745              	.LBE879:
  10:../lib/uart.c **** 	while ((ch = *string)){
 2746              		.loc 2 10 0
 2747 06fc E5F30001 		ldrb	r0, [r3, #1]!	@ zero_extendqisi2
 2748              	.LVL326:
 2749 0700 E3500000 		cmp	r0, #0
 2750 0704 0A00000F 		beq	.L602
 2751              	.L344:
 2752              	.LBB882:
 2753              	.LBB881:
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 2754              		.loc 1 183 0
 2755 0708 E511EFE3 		ldr	lr, [r1, #-4067]
 2756 070c E31E0001 		tst	lr, #1
 2757 0710 0AFFFFFC 		beq	.L344
 184:../lib/io_driver.c **** 	UART0_DATA = (ch & 0x000000FF);
 2758              		.loc 1 184 0
 2759 0714 E50C0FE7 		str	r0, [ip, #-4071]
 2760              	.LVL327:
 2761 0718 EAFFFFF7 		b	.L342
 2762              	.LVL328:
 2763              	.L332:
 2764              	.LBE881:
 2765              	.LBE882:
 2766              	.LBE878:
 2767              	.LBE877:
 2768              	.LBB883:
 2769              	.LBB884:
 2770              	.LBB885:
 2771              	.LBB886:
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 2772              		.loc 1 183 0
 2773 071c E3E02A0F 		mvn	r2, #61440
 2774              	.LVL329:
 2775 0720 E59F39B8 		ldr	r3, .L609+252
 2776 0724 E1A00002 		mov	r0, r2
 2777              	.LVL330:
 2778              	.L334:
 2779              	.LBE886:
 2780              	.LBE885:
  10:../lib/uart.c **** 	while ((ch = *string)){
 2781              		.loc 2 10 0
 2782 0728 E5F31001 		ldrb	r1, [r3, #1]!	@ zero_extendqisi2
 2783              	.LVL331:
 2784 072c E3510000 		cmp	r1, #0
 2785 0730 0AFFFE84 		beq	.L225
 2786              	.L336:
 2787              	.LBB888:
 2788              	.LBB887:
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 2789              		.loc 1 183 0
 2790 0734 E512CFE3 		ldr	ip, [r2, #-4067]
 2791 0738 E31C0001 		tst	ip, #1
 2792 073c 0AFFFFFC 		beq	.L336
 184:../lib/io_driver.c **** 	UART0_DATA = (ch & 0x000000FF);
 2793              		.loc 1 184 0
 2794 0740 E5001FE7 		str	r1, [r0, #-4071]
 2795              	.LVL332:
 2796 0744 EAFFFFF7 		b	.L334
 2797              	.LVL333:
 2798              	.L602:
 2799              	.LBE887:
 2800              	.LBE888:
 2801              	.LBE884:
 2802              	.LBE883:
 2803              	.LBB889:
 2804              	.LBB860:
 2805              	.LBB856:
 2806              	.LBB857:
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 2807              		.loc 1 183 0
 2808 0748 E3E01A0F 		mvn	r1, #61440
 2809 074c E59F38EC 		ldr	r3, .L609+92
 2810              	.LVL334:
 2811 0750 E1A00001 		mov	r0, r1
 2812              	.LVL335:
 2813              	.L346:
 2814              	.LBE857:
 2815              	.LBE856:
  10:../lib/uart.c **** 	while ((ch = *string)){
 2816              		.loc 2 10 0
 2817 0754 E5F36001 		ldrb	r6, [r3, #1]!	@ zero_extendqisi2
 2818              	.LVL336:
 2819 0758 E3560000 		cmp	r6, #0
 2820 075c 0A000004 		beq	.L603
 2821              	.L348:
 2822              	.LBB859:
 2823              	.LBB858:
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 2824              		.loc 1 183 0
 2825 0760 E511CFE3 		ldr	ip, [r1, #-4067]
 2826 0764 E31C0001 		tst	ip, #1
 2827 0768 0AFFFFFC 		beq	.L348
 184:../lib/io_driver.c **** 	UART0_DATA = (ch & 0x000000FF);
 2828              		.loc 1 184 0
 2829 076c E5006FE7 		str	r6, [r0, #-4071]
 2830              	.LVL337:
 2831 0770 EAFFFFF7 		b	.L346
 2832              	.LVL338:
 2833              	.L603:
 2834 0774 E282800C 		add	r8, r2, #12
 2835              	.LVL339:
 2836              	.L350:
 2837              	.LBE858:
 2838              	.LBE859:
 2839              	.LBE860:
 2840              	.LBE889:
 236:main.c        **** 					for(i=0; i<cnt+12; i++){
 2841              		.loc 4 236 0 discriminator 1
 2842 0778 E1560008 		cmp	r6, r8
 2843 077c E1A09006 		mov	r9, r6
 2844 0780 2A000009 		bcs	.L604
 237:main.c        **** 						char_tmp = *char_pointer++;
 2845              		.loc 4 237 0
 2846 0784 E4D6A001 		ldrb	r10, [r6], #1	@ zero_extendqisi2
 2847              	.LVL340:
 2848              	.L352:
 238:main.c        **** 						while(io_i2c0_byte_transfer('w', device_id, i, 2, char_tmp) != 0);
 2849              		.loc 4 238 0 discriminator 1
 2850 0788 E58DA000 		str	r10, [sp]
 2851 078c E3A00077 		mov	r0, #119
 2852 0790 E1A01004 		mov	r1, r4
 2853 0794 E1A02009 		mov	r2, r9
 2854 0798 E3A03002 		mov	r3, #2
 2855 079c EBFFFFFE 		bl	io_i2c0_byte_transfer
 2856              	.LVL341:
 2857 07a0 E3500000 		cmp	r0, #0
 2858 07a4 1AFFFFF7 		bne	.L352
 2859 07a8 EAFFFFF2 		b	.L350
 2860              	.LVL342:
 2861              	.L604:
 2862              	.LBB890:
 2863              	.LBB891:
 2864              	.LBB892:
 2865              	.LBB893:
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 2866              		.loc 1 183 0
 2867 07ac E3E02A0F 		mvn	r2, #61440
 2868 07b0 E59F388C 		ldr	r3, .L609+96
 2869 07b4 E1A00002 		mov	r0, r2
 2870              	.L354:
 2871              	.LVL343:
 2872              	.LBE893:
 2873              	.LBE892:
  10:../lib/uart.c **** 	while ((ch = *string)){
 2874              		.loc 2 10 0
 2875 07b8 E5F31001 		ldrb	r1, [r3, #1]!	@ zero_extendqisi2
 2876              	.LVL344:
 2877 07bc E3510000 		cmp	r1, #0
 2878 07c0 0AFFFF83 		beq	.L358
 2879              	.L356:
 2880              	.LBB895:
 2881              	.LBB894:
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 2882              		.loc 1 183 0
 2883 07c4 E512CFE3 		ldr	ip, [r2, #-4067]
 2884 07c8 E31C0001 		tst	ip, #1
 2885 07cc 0AFFFFFC 		beq	.L356
 184:../lib/io_driver.c **** 	UART0_DATA = (ch & 0x000000FF);
 2886              		.loc 1 184 0
 2887 07d0 E5001FE7 		str	r1, [r0, #-4071]
 2888              	.LVL345:
 2889 07d4 EAFFFFF7 		b	.L354
 2890              	.LVL346:
 2891              	.L599:
 2892              	.LBE894:
 2893              	.LBE895:
 2894              	.LBE891:
 2895              	.LBE890:
 173:main.c        **** 				if((buffer[0] == 'S') && (buffer[1] == 'M') && (buffer[2] == 'B') && (buffer[3] == 'R')){
 2896              		.loc 4 173 0 discriminator 1
 2897 07d8 E5DD2009 		ldrb	r2, [sp, #9]	@ zero_extendqisi2
 2898 07dc E352004D 		cmp	r2, #77
 2899 07e0 1AFFFE8E 		bne	.L302
 2900 07e4 E5DD200A 		ldrb	r2, [sp, #10]	@ zero_extendqisi2
 2901 07e8 E3520042 		cmp	r2, #66
 2902 07ec 1AFFFE8B 		bne	.L302
 2903 07f0 E3530052 		cmp	r3, #82
 2904 07f4 1AFFFE89 		bne	.L302
 2905              	.LVL347:
 174:main.c        **** 					buffer[0] = (unsigned char)io_i2c0_byte_transfer('r',device_id,cnt++,2,0x00);
 2906              		.loc 4 174 0
 2907 07f8 E1A01004 		mov	r1, r4
 2908 07fc E3A02004 		mov	r2, #4
 2909 0800 E3A03002 		mov	r3, #2
 2910 0804 E58D6000 		str	r6, [sp]
 2911 0808 E3A00072 		mov	r0, #114
 2912 080c EBFFFFFE 		bl	io_i2c0_byte_transfer
 2913              	.LVL348:
 175:main.c        **** 					buffer[1] = (unsigned char)io_i2c0_byte_transfer('r',device_id,cnt++,2,0x00);
 2914              		.loc 4 175 0
 2915 0810 E1A01004 		mov	r1, r4
 174:main.c        **** 					buffer[0] = (unsigned char)io_i2c0_byte_transfer('r',device_id,cnt++,2,0x00);
 2916              		.loc 4 174 0
 2917 0814 E5CD0008 		strb	r0, [sp, #8]
 2918              	.LVL349:
 175:main.c        **** 					buffer[1] = (unsigned char)io_i2c0_byte_transfer('r',device_id,cnt++,2,0x00);
 2919              		.loc 4 175 0
 2920 0818 E3A02005 		mov	r2, #5
 2921 081c E3A03002 		mov	r3, #2
 2922 0820 E58D6000 		str	r6, [sp]
 2923 0824 E3A00072 		mov	r0, #114
 2924 0828 EBFFFFFE 		bl	io_i2c0_byte_transfer
 2925              	.LVL350:
 176:main.c        **** 					buffer[2] = (unsigned char)io_i2c0_byte_transfer('r',device_id,cnt++,2,0x00);
 2926              		.loc 4 176 0
 2927 082c E1A01004 		mov	r1, r4
 175:main.c        **** 					buffer[1] = (unsigned char)io_i2c0_byte_transfer('r',device_id,cnt++,2,0x00);
 2928              		.loc 4 175 0
 2929 0830 E5CD0009 		strb	r0, [sp, #9]
 2930              	.LVL351:
 176:main.c        **** 					buffer[2] = (unsigned char)io_i2c0_byte_transfer('r',device_id,cnt++,2,0x00);
 2931              		.loc 4 176 0
 2932 0834 E3A02006 		mov	r2, #6
 2933 0838 E3A03002 		mov	r3, #2
 2934 083c E58D6000 		str	r6, [sp]
 2935 0840 E3A00072 		mov	r0, #114
 2936 0844 EBFFFFFE 		bl	io_i2c0_byte_transfer
 2937              	.LVL352:
 177:main.c        **** 					buffer[3] = (unsigned char)io_i2c0_byte_transfer('r',device_id,cnt++,2,0x00);
 2938              		.loc 4 177 0
 2939 0848 E3A02007 		mov	r2, #7
 176:main.c        **** 					buffer[2] = (unsigned char)io_i2c0_byte_transfer('r',device_id,cnt++,2,0x00);
 2940              		.loc 4 176 0
 2941 084c E5CD000A 		strb	r0, [sp, #10]
 2942              	.LVL353:
 177:main.c        **** 					buffer[3] = (unsigned char)io_i2c0_byte_transfer('r',device_id,cnt++,2,0x00);
 2943              		.loc 4 177 0
 2944 0850 E3A03002 		mov	r3, #2
 2945 0854 E58D6000 		str	r6, [sp]
 2946 0858 E1A01004 		mov	r1, r4
 2947 085c E3A00072 		mov	r0, #114
 2948 0860 EBFFFFFE 		bl	io_i2c0_byte_transfer
 2949              	.LVL354:
 2950              	.LBB896:
 2951              	.LBB897:
  34:main.c        **** 	n = a|(b<<8)|(c<<16)|(d<<24);
 2952              		.loc 4 34 0
 2953 0864 E5DD300A 		ldrb	r3, [sp, #10]	@ zero_extendqisi2
 2954 0868 E5DD2009 		ldrb	r2, [sp, #9]	@ zero_extendqisi2
 2955 086c E1A03403 		mov	r3, r3, asl #8
 2956 0870 E5DD7008 		ldrb	r7, [sp, #8]	@ zero_extendqisi2
 2957 0874 E1832802 		orr	r2, r3, r2, asl #16
 2958 0878 E1827C07 		orr	r7, r2, r7, asl #24
 2959 087c E20030FF 		and	r3, r0, #255
 2960 0880 E1877003 		orr	r7, r7, r3
 2961              	.LBE897:
 2962              	.LBE896:
 177:main.c        **** 					buffer[3] = (unsigned char)io_i2c0_byte_transfer('r',device_id,cnt++,2,0x00);
 2963              		.loc 4 177 0
 2964 0884 E5CD000B 		strb	r0, [sp, #11]
 2965              	.LVL355:
 2966 0888 E2877004 		add	r7, r7, #4
 2967              	.LVL356:
 181:main.c        **** 						buffer[0] = (unsigned char)io_i2c0_byte_transfer('r',device_id,cnt++,2,0x00);
 2968              		.loc 4 181 0
 2969 088c E1A05006 		mov	r5, r6
 2970              	.LVL357:
 2971              	.L305:
 180:main.c        **** 					while((data_pointer != adr_buffer+4) && (data_pointer < IRAM_SIZE)){
 2972              		.loc 4 180 0 discriminator 1
 2973 0890 E1560007 		cmp	r6, r7
 181:main.c        **** 						buffer[0] = (unsigned char)io_i2c0_byte_transfer('r',device_id,cnt++,2,0x00);
 2974              		.loc 4 181 0 discriminator 1
 2975 0894 E1A01004 		mov	r1, r4
 2976 0898 E3A03002 		mov	r3, #2
 2977 089c E3A00072 		mov	r0, #114
 2978 08a0 E2862008 		add	r2, r6, #8
 2979              	.LVL358:
 180:main.c        **** 					while((data_pointer != adr_buffer+4) && (data_pointer < IRAM_SIZE)){
 2980              		.loc 4 180 0 discriminator 1
 2981 08a4 0A000106 		beq	.L309
 180:main.c        **** 					while((data_pointer != adr_buffer+4) && (data_pointer < IRAM_SIZE)){
 2982              		.loc 4 180 0 is_stmt 0 discriminator 2
 2983 08a8 E3560902 		cmp	r6, #32768
 2984 08ac 0A000104 		beq	.L309
 181:main.c        **** 						buffer[0] = (unsigned char)io_i2c0_byte_transfer('r',device_id,cnt++,2,0x00);
 2985              		.loc 4 181 0 is_stmt 1
 2986 08b0 E58D5000 		str	r5, [sp]
 2987 08b4 EBFFFFFE 		bl	io_i2c0_byte_transfer
 2988              	.LVL359:
 182:main.c        **** 						buffer[1] = (unsigned char)io_i2c0_byte_transfer('r',device_id,cnt++,2,0x00);
 2989              		.loc 4 182 0
 2990 08b8 E2862009 		add	r2, r6, #9
 181:main.c        **** 						buffer[0] = (unsigned char)io_i2c0_byte_transfer('r',device_id,cnt++,2,0x00);
 2991              		.loc 4 181 0
 2992 08bc E5CD0008 		strb	r0, [sp, #8]
 2993              	.LVL360:
 182:main.c        **** 						buffer[1] = (unsigned char)io_i2c0_byte_transfer('r',device_id,cnt++,2,0x00);
 2994              		.loc 4 182 0
 2995 08c0 E1A01004 		mov	r1, r4
 2996 08c4 E3A03002 		mov	r3, #2
 2997 08c8 E58D5000 		str	r5, [sp]
 2998 08cc E3A00072 		mov	r0, #114
 2999 08d0 EBFFFFFE 		bl	io_i2c0_byte_transfer
 3000              	.LVL361:
 183:main.c        **** 						buffer[2] = (unsigned char)io_i2c0_byte_transfer('r',device_id,cnt++,2,0x00);
 3001              		.loc 4 183 0
 3002 08d4 E286200A 		add	r2, r6, #10
 3003              	.LVL362:
 182:main.c        **** 						buffer[1] = (unsigned char)io_i2c0_byte_transfer('r',device_id,cnt++,2,0x00);
 3004              		.loc 4 182 0
 3005 08d8 E5CD0009 		strb	r0, [sp, #9]
 3006              	.LVL363:
 183:main.c        **** 						buffer[2] = (unsigned char)io_i2c0_byte_transfer('r',device_id,cnt++,2,0x00);
 3007              		.loc 4 183 0
 3008 08dc E1A01004 		mov	r1, r4
 3009 08e0 E3A03002 		mov	r3, #2
 3010 08e4 E58D5000 		str	r5, [sp]
 3011 08e8 E3A00072 		mov	r0, #114
 3012 08ec EBFFFFFE 		bl	io_i2c0_byte_transfer
 3013              	.LVL364:
 184:main.c        **** 						buffer[3] = (unsigned char)io_i2c0_byte_transfer('r',device_id,cnt++,2,0x00);
 3014              		.loc 4 184 0
 3015 08f0 E286200B 		add	r2, r6, #11
 3016              	.LVL365:
 183:main.c        **** 						buffer[2] = (unsigned char)io_i2c0_byte_transfer('r',device_id,cnt++,2,0x00);
 3017              		.loc 4 183 0
 3018 08f4 E5CD000A 		strb	r0, [sp, #10]
 3019              	.LVL366:
 184:main.c        **** 						buffer[3] = (unsigned char)io_i2c0_byte_transfer('r',device_id,cnt++,2,0x00);
 3020              		.loc 4 184 0
 3021 08f8 E1A01004 		mov	r1, r4
 3022 08fc E3A03002 		mov	r3, #2
 3023 0900 E58D5000 		str	r5, [sp]
 3024 0904 E3A00072 		mov	r0, #114
 3025 0908 EBFFFFFE 		bl	io_i2c0_byte_transfer
 3026              	.LVL367:
 3027              	.LBB898:
 3028              	.LBB899:
  34:main.c        **** 	n = a|(b<<8)|(c<<16)|(d<<24);
 3029              		.loc 4 34 0
 3030 090c E5DD300A 		ldrb	r3, [sp, #10]	@ zero_extendqisi2
 3031 0910 E5DD2009 		ldrb	r2, [sp, #9]	@ zero_extendqisi2
 3032 0914 E1A03403 		mov	r3, r3, asl #8
 3033 0918 E5DD1008 		ldrb	r1, [sp, #8]	@ zero_extendqisi2
 3034 091c E1832802 		orr	r2, r3, r2, asl #16
 3035 0920 E1822C01 		orr	r2, r2, r1, asl #24
 3036 0924 E20030FF 		and	r3, r0, #255
 3037 0928 E1823003 		orr	r3, r2, r3
 3038              	.LBE899:
 3039              	.LBE898:
 184:main.c        **** 						buffer[3] = (unsigned char)io_i2c0_byte_transfer('r',device_id,cnt++,2,0x00);
 3040              		.loc 4 184 0
 3041 092c E5CD000B 		strb	r0, [sp, #11]
 3042              	.LVL368:
 185:main.c        **** 						*data_pointer = qbytes_to_long(buffer); // store memory entry
 3043              		.loc 4 185 0
 3044 0930 E4863004 		str	r3, [r6], #4
 3045              	.LVL369:
 3046 0934 EAFFFFD5 		b	.L305
 3047              	.LVL370:
 3048              	.L241:
 3049              	.LBB900:
 3050              	.LBB901:
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 3051              		.loc 1 183 0
 3052 0938 E3E03A0F 		mvn	r3, #61440
 3053              	.LVL371:
 3054              	.L415:
 3055 093c E5132FE3 		ldr	r2, [r3, #-4067]
 3056 0940 E3120001 		tst	r2, #1
 3057 0944 E3E01A0F 		mvn	r1, #61440
 3058 0948 0AFFFFFB 		beq	.L415
 184:../lib/io_driver.c **** 	UART0_DATA = (ch & 0x000000FF);
 3059              		.loc 1 184 0
 3060 094c E3A03068 		mov	r3, #104
 3061 0950 E5013FE7 		str	r3, [r1, #-4071]
 3062              	.LVL372:
 3063 0954 E59F06EC 		ldr	r0, .L609+100
 3064              	.LBE901:
 3065              	.LBE900:
 3066              	.LBB902:
 3067              	.LBB903:
  10:../lib/uart.c **** 	while ((ch = *string)){
 3068              		.loc 2 10 0
 3069 0958 E3A0200D 		mov	r2, #13
 3070              	.LVL373:
 3071              	.L417:
 3072              	.LBB904:
 3073              	.LBB905:
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 3074              		.loc 1 183 0
 3075 095c E5113FE3 		ldr	r3, [r1, #-4067]
 3076 0960 E3130001 		tst	r3, #1
 3077 0964 E3E03A0F 		mvn	r3, #61440
 3078 0968 0AFFFFFB 		beq	.L417
 184:../lib/io_driver.c **** 	UART0_DATA = (ch & 0x000000FF);
 3079              		.loc 1 184 0
 3080 096c E5032FE7 		str	r2, [r3, #-4071]
 3081              	.LVL374:
 3082              	.LBE905:
 3083              	.LBE904:
  10:../lib/uart.c **** 	while ((ch = *string)){
 3084              		.loc 2 10 0
 3085 0970 E5F02001 		ldrb	r2, [r0, #1]!	@ zero_extendqisi2
 3086              	.LVL375:
 3087 0974 E3520000 		cmp	r2, #0
 3088 0978 1AFFFFF7 		bne	.L417
 3089 097c E59FC6C8 		ldr	ip, .L609+104
 3090              	.LBE903:
 3091              	.LBE902:
 3092              	.LBB906:
 3093              	.LBB907:
 3094              	.LBB908:
 3095              	.LBB909:
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 3096              		.loc 1 183 0
 3097 0980 E1A00003 		mov	r0, r3
 3098              	.LVL376:
 3099              	.LBE909:
 3100              	.LBE908:
  10:../lib/uart.c **** 	while ((ch = *string)){
 3101              		.loc 2 10 0
 3102 0984 E3A02027 		mov	r2, #39
 3103              	.LVL377:
 3104              	.L421:
 3105              	.LBB911:
 3106              	.LBB910:
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 3107              		.loc 1 183 0
 3108 0988 E5101FE3 		ldr	r1, [r0, #-4067]
 3109 098c E3110001 		tst	r1, #1
 3110 0990 E3E03A0F 		mvn	r3, #61440
 3111 0994 0AFFFFFB 		beq	.L421
 184:../lib/io_driver.c **** 	UART0_DATA = (ch & 0x000000FF);
 3112              		.loc 1 184 0
 3113 0998 E5032FE7 		str	r2, [r3, #-4071]
 3114              	.LVL378:
 3115              	.LBE910:
 3116              	.LBE911:
  10:../lib/uart.c **** 	while ((ch = *string)){
 3117              		.loc 2 10 0
 3118 099c E5FC2001 		ldrb	r2, [ip, #1]!	@ zero_extendqisi2
 3119              	.LVL379:
 3120 09a0 E3520000 		cmp	r2, #0
 3121 09a4 1AFFFFF7 		bne	.L421
 3122 09a8 E59FC6A0 		ldr	ip, .L609+108
 3123              	.LVL380:
 3124              	.LBE907:
 3125              	.LBE906:
 3126              	.LBB912:
 3127              	.LBB913:
 3128              	.LBB914:
 3129              	.LBB915:
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 3130              		.loc 1 183 0
 3131 09ac E1A00003 		mov	r0, r3
 3132              	.LBE915:
 3133              	.LBE914:
  10:../lib/uart.c **** 	while ((ch = *string)){
 3134              		.loc 2 10 0
 3135 09b0 E3A02027 		mov	r2, #39
 3136              	.LVL381:
 3137              	.L425:
 3138              	.LBB917:
 3139              	.LBB916:
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 3140              		.loc 1 183 0
 3141 09b4 E5101FE3 		ldr	r1, [r0, #-4067]
 3142 09b8 E3110001 		tst	r1, #1
 3143 09bc E3E03A0F 		mvn	r3, #61440
 3144 09c0 0AFFFFFB 		beq	.L425
 184:../lib/io_driver.c **** 	UART0_DATA = (ch & 0x000000FF);
 3145              		.loc 1 184 0
 3146 09c4 E5032FE7 		str	r2, [r3, #-4071]
 3147              	.LVL382:
 3148              	.LBE916:
 3149              	.LBE917:
  10:../lib/uart.c **** 	while ((ch = *string)){
 3150              		.loc 2 10 0
 3151 09c8 E5FC2001 		ldrb	r2, [ip, #1]!	@ zero_extendqisi2
 3152              	.LVL383:
 3153 09cc E3520000 		cmp	r2, #0
 3154 09d0 1AFFFFF7 		bne	.L425
 3155 09d4 E59FC678 		ldr	ip, .L609+112
 3156              	.LVL384:
 3157              	.LBE913:
 3158              	.LBE912:
 3159              	.LBB918:
 3160              	.LBB919:
 3161              	.LBB920:
 3162              	.LBB921:
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 3163              		.loc 1 183 0
 3164 09d8 E1A00003 		mov	r0, r3
 3165              	.LBE921:
 3166              	.LBE920:
  10:../lib/uart.c **** 	while ((ch = *string)){
 3167              		.loc 2 10 0
 3168 09dc E3A02027 		mov	r2, #39
 3169              	.LVL385:
 3170              	.L429:
 3171              	.LBB923:
 3172              	.LBB922:
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 3173              		.loc 1 183 0
 3174 09e0 E5101FE3 		ldr	r1, [r0, #-4067]
 3175 09e4 E3110001 		tst	r1, #1
 3176 09e8 E3E03A0F 		mvn	r3, #61440
 3177 09ec 0AFFFFFB 		beq	.L429
 184:../lib/io_driver.c **** 	UART0_DATA = (ch & 0x000000FF);
 3178              		.loc 1 184 0
 3179 09f0 E5032FE7 		str	r2, [r3, #-4071]
 3180              	.LVL386:
 3181              	.LBE922:
 3182              	.LBE923:
  10:../lib/uart.c **** 	while ((ch = *string)){
 3183              		.loc 2 10 0
 3184 09f4 E5FC2001 		ldrb	r2, [ip, #1]!	@ zero_extendqisi2
 3185              	.LVL387:
 3186 09f8 E3520000 		cmp	r2, #0
 3187 09fc 1AFFFFF7 		bne	.L429
 3188 0a00 E59FC650 		ldr	ip, .L609+116
 3189              	.LVL388:
 3190              	.LBE919:
 3191              	.LBE918:
 3192              	.LBB924:
 3193              	.LBB925:
 3194              	.LBB926:
 3195              	.LBB927:
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 3196              		.loc 1 183 0
 3197 0a04 E1A00003 		mov	r0, r3
 3198              	.LBE927:
 3199              	.LBE926:
  10:../lib/uart.c **** 	while ((ch = *string)){
 3200              		.loc 2 10 0
 3201 0a08 E3A02027 		mov	r2, #39
 3202              	.LVL389:
 3203              	.L433:
 3204              	.LBB929:
 3205              	.LBB928:
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 3206              		.loc 1 183 0
 3207 0a0c E5101FE3 		ldr	r1, [r0, #-4067]
 3208 0a10 E3110001 		tst	r1, #1
 3209 0a14 E3E03A0F 		mvn	r3, #61440
 3210 0a18 0AFFFFFB 		beq	.L433
 184:../lib/io_driver.c **** 	UART0_DATA = (ch & 0x000000FF);
 3211              		.loc 1 184 0
 3212 0a1c E5032FE7 		str	r2, [r3, #-4071]
 3213              	.LVL390:
 3214              	.LBE928:
 3215              	.LBE929:
  10:../lib/uart.c **** 	while ((ch = *string)){
 3216              		.loc 2 10 0
 3217 0a20 E5FC2001 		ldrb	r2, [ip, #1]!	@ zero_extendqisi2
 3218              	.LVL391:
 3219 0a24 E3520000 		cmp	r2, #0
 3220 0a28 1AFFFFF7 		bne	.L433
 3221 0a2c E59FC628 		ldr	ip, .L609+120
 3222              	.LVL392:
 3223              	.LBE925:
 3224              	.LBE924:
 3225              	.LBB930:
 3226              	.LBB931:
 3227              	.LBB932:
 3228              	.LBB933:
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 3229              		.loc 1 183 0
 3230 0a30 E1A00003 		mov	r0, r3
 3231              	.LBE933:
 3232              	.LBE932:
  10:../lib/uart.c **** 	while ((ch = *string)){
 3233              		.loc 2 10 0
 3234 0a34 E3A02027 		mov	r2, #39
 3235              	.LVL393:
 3236              	.L437:
 3237              	.LBB935:
 3238              	.LBB934:
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 3239              		.loc 1 183 0
 3240 0a38 E5101FE3 		ldr	r1, [r0, #-4067]
 3241 0a3c E3110001 		tst	r1, #1
 3242 0a40 E3E03A0F 		mvn	r3, #61440
 3243 0a44 0AFFFFFB 		beq	.L437
 184:../lib/io_driver.c **** 	UART0_DATA = (ch & 0x000000FF);
 3244              		.loc 1 184 0
 3245 0a48 E5032FE7 		str	r2, [r3, #-4071]
 3246              	.LVL394:
 3247              	.LBE934:
 3248              	.LBE935:
  10:../lib/uart.c **** 	while ((ch = *string)){
 3249              		.loc 2 10 0
 3250 0a4c E5FC2001 		ldrb	r2, [ip, #1]!	@ zero_extendqisi2
 3251              	.LVL395:
 3252 0a50 E3520000 		cmp	r2, #0
 3253 0a54 1AFFFFF7 		bne	.L437
 3254 0a58 E59FC600 		ldr	ip, .L609+124
 3255              	.LVL396:
 3256              	.LBE931:
 3257              	.LBE930:
 3258              	.LBB936:
 3259              	.LBB937:
 3260              	.LBB938:
 3261              	.LBB939:
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 3262              		.loc 1 183 0
 3263 0a5c E1A00003 		mov	r0, r3
 3264              	.LBE939:
 3265              	.LBE938:
  10:../lib/uart.c **** 	while ((ch = *string)){
 3266              		.loc 2 10 0
 3267 0a60 E3A02027 		mov	r2, #39
 3268              	.LVL397:
 3269              	.L441:
 3270              	.LBB941:
 3271              	.LBB940:
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 3272              		.loc 1 183 0
 3273 0a64 E5101FE3 		ldr	r1, [r0, #-4067]
 3274 0a68 E3110001 		tst	r1, #1
 3275 0a6c E3E03A0F 		mvn	r3, #61440
 3276 0a70 0AFFFFFB 		beq	.L441
 184:../lib/io_driver.c **** 	UART0_DATA = (ch & 0x000000FF);
 3277              		.loc 1 184 0
 3278 0a74 E5032FE7 		str	r2, [r3, #-4071]
 3279              	.LVL398:
 3280              	.LBE940:
 3281              	.LBE941:
  10:../lib/uart.c **** 	while ((ch = *string)){
 3282              		.loc 2 10 0
 3283 0a78 E5FC2001 		ldrb	r2, [ip, #1]!	@ zero_extendqisi2
 3284              	.LVL399:
 3285 0a7c E3520000 		cmp	r2, #0
 3286 0a80 1AFFFFF7 		bne	.L441
 3287 0a84 E59FC5D8 		ldr	ip, .L609+128
 3288              	.LVL400:
 3289              	.LBE937:
 3290              	.LBE936:
 3291              	.LBB942:
 3292              	.LBB943:
 3293              	.LBB944:
 3294              	.LBB945:
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 3295              		.loc 1 183 0
 3296 0a88 E1A00003 		mov	r0, r3
 3297              	.LBE945:
 3298              	.LBE944:
  10:../lib/uart.c **** 	while ((ch = *string)){
 3299              		.loc 2 10 0
 3300 0a8c E3A02027 		mov	r2, #39
 3301              	.LVL401:
 3302              	.L445:
 3303              	.LBB947:
 3304              	.LBB946:
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 3305              		.loc 1 183 0
 3306 0a90 E5101FE3 		ldr	r1, [r0, #-4067]
 3307 0a94 E3110001 		tst	r1, #1
 3308 0a98 E3E03A0F 		mvn	r3, #61440
 3309 0a9c 0AFFFFFB 		beq	.L445
 184:../lib/io_driver.c **** 	UART0_DATA = (ch & 0x000000FF);
 3310              		.loc 1 184 0
 3311 0aa0 E5032FE7 		str	r2, [r3, #-4071]
 3312              	.LVL402:
 3313              	.LBE946:
 3314              	.LBE947:
  10:../lib/uart.c **** 	while ((ch = *string)){
 3315              		.loc 2 10 0
 3316 0aa4 E5FC2001 		ldrb	r2, [ip, #1]!	@ zero_extendqisi2
 3317              	.LVL403:
 3318 0aa8 E3520000 		cmp	r2, #0
 3319 0aac 1AFFFFF7 		bne	.L445
 3320 0ab0 E59FC5B0 		ldr	ip, .L609+132
 3321              	.LVL404:
 3322              	.LBE943:
 3323              	.LBE942:
 3324              	.LBB948:
 3325              	.LBB949:
 3326              	.LBB950:
 3327              	.LBB951:
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 3328              		.loc 1 183 0
 3329 0ab4 E1A00003 		mov	r0, r3
 3330              	.LBE951:
 3331              	.LBE950:
  10:../lib/uart.c **** 	while ((ch = *string)){
 3332              		.loc 2 10 0
 3333 0ab8 E3A02027 		mov	r2, #39
 3334              	.LVL405:
 3335              	.L449:
 3336              	.LBB953:
 3337              	.LBB952:
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 3338              		.loc 1 183 0
 3339 0abc E5101FE3 		ldr	r1, [r0, #-4067]
 3340 0ac0 E3110001 		tst	r1, #1
 3341 0ac4 E3E03A0F 		mvn	r3, #61440
 3342 0ac8 0AFFFFFB 		beq	.L449
 184:../lib/io_driver.c **** 	UART0_DATA = (ch & 0x000000FF);
 3343              		.loc 1 184 0
 3344 0acc E5032FE7 		str	r2, [r3, #-4071]
 3345              	.LVL406:
 3346              	.LBE952:
 3347              	.LBE953:
  10:../lib/uart.c **** 	while ((ch = *string)){
 3348              		.loc 2 10 0
 3349 0ad0 E5FC2001 		ldrb	r2, [ip, #1]!	@ zero_extendqisi2
 3350              	.LVL407:
 3351 0ad4 E3520000 		cmp	r2, #0
 3352 0ad8 1AFFFFF7 		bne	.L449
 3353 0adc E59FC588 		ldr	ip, .L609+136
 3354              	.LVL408:
 3355              	.LBE949:
 3356              	.LBE948:
 3357              	.LBB954:
 3358              	.LBB955:
 3359              	.LBB956:
 3360              	.LBB957:
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 3361              		.loc 1 183 0
 3362 0ae0 E1A00003 		mov	r0, r3
 3363              	.LBE957:
 3364              	.LBE956:
  10:../lib/uart.c **** 	while ((ch = *string)){
 3365              		.loc 2 10 0
 3366 0ae4 E3A02027 		mov	r2, #39
 3367              	.LVL409:
 3368              	.L453:
 3369              	.LBB959:
 3370              	.LBB958:
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 3371              		.loc 1 183 0
 3372 0ae8 E5101FE3 		ldr	r1, [r0, #-4067]
 3373 0aec E3110001 		tst	r1, #1
 3374 0af0 E3E03A0F 		mvn	r3, #61440
 3375 0af4 0AFFFFFB 		beq	.L453
 184:../lib/io_driver.c **** 	UART0_DATA = (ch & 0x000000FF);
 3376              		.loc 1 184 0
 3377 0af8 E5032FE7 		str	r2, [r3, #-4071]
 3378              	.LVL410:
 3379              	.LBE958:
 3380              	.LBE959:
  10:../lib/uart.c **** 	while ((ch = *string)){
 3381              		.loc 2 10 0
 3382 0afc E5FC2001 		ldrb	r2, [ip, #1]!	@ zero_extendqisi2
 3383              	.LVL411:
 3384 0b00 E3520000 		cmp	r2, #0
 3385 0b04 1AFFFFF7 		bne	.L453
 3386 0b08 E59FC560 		ldr	ip, .L609+140
 3387              	.LVL412:
 3388              	.LBE955:
 3389              	.LBE954:
 3390              	.LBB960:
 3391              	.LBB961:
 3392              	.LBB962:
 3393              	.LBB963:
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 3394              		.loc 1 183 0
 3395 0b0c E1A00003 		mov	r0, r3
 3396              	.LBE963:
 3397              	.LBE962:
  10:../lib/uart.c **** 	while ((ch = *string)){
 3398              		.loc 2 10 0
 3399 0b10 E3A02042 		mov	r2, #66
 3400              	.LVL413:
 3401              	.L457:
 3402              	.LBB965:
 3403              	.LBB964:
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 3404              		.loc 1 183 0
 3405 0b14 E5101FE3 		ldr	r1, [r0, #-4067]
 3406 0b18 E3110001 		tst	r1, #1
 3407 0b1c E3E03A0F 		mvn	r3, #61440
 3408 0b20 0AFFFFFB 		beq	.L457
 184:../lib/io_driver.c **** 	UART0_DATA = (ch & 0x000000FF);
 3409              		.loc 1 184 0
 3410 0b24 E5032FE7 		str	r2, [r3, #-4071]
 3411              	.LVL414:
 3412              	.LBE964:
 3413              	.LBE965:
  10:../lib/uart.c **** 	while ((ch = *string)){
 3414              		.loc 2 10 0
 3415 0b28 E5FC2001 		ldrb	r2, [ip, #1]!	@ zero_extendqisi2
 3416              	.LVL415:
 3417 0b2c E3520000 		cmp	r2, #0
 3418 0b30 1AFFFFF7 		bne	.L457
 3419 0b34 E59FC538 		ldr	ip, .L609+144
 3420              	.LVL416:
 3421              	.LBE961:
 3422              	.LBE960:
 3423              	.LBB966:
 3424              	.LBB967:
 3425              	.LBB968:
 3426              	.LBB969:
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 3427              		.loc 1 183 0
 3428 0b38 E1A00003 		mov	r0, r3
 3429              	.LBE969:
 3430              	.LBE968:
  10:../lib/uart.c **** 	while ((ch = *string)){
 3431              		.loc 2 10 0
 3432 0b3c E3A02063 		mov	r2, #99
 3433              	.LVL417:
 3434              	.L461:
 3435              	.LBB971:
 3436              	.LBB970:
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 3437              		.loc 1 183 0
 3438 0b40 E5101FE3 		ldr	r1, [r0, #-4067]
 3439 0b44 E3110001 		tst	r1, #1
 3440 0b48 E3E03A0F 		mvn	r3, #61440
 3441 0b4c 0AFFFFFB 		beq	.L461
 184:../lib/io_driver.c **** 	UART0_DATA = (ch & 0x000000FF);
 3442              		.loc 1 184 0
 3443 0b50 E5032FE7 		str	r2, [r3, #-4071]
 3444              	.LVL418:
 3445              	.LBE970:
 3446              	.LBE971:
  10:../lib/uart.c **** 	while ((ch = *string)){
 3447              		.loc 2 10 0
 3448 0b54 E5FC2001 		ldrb	r2, [ip, #1]!	@ zero_extendqisi2
 3449              	.LVL419:
 3450 0b58 E3520000 		cmp	r2, #0
 3451 0b5c 1AFFFFF7 		bne	.L461
 3452 0b60 E59FC510 		ldr	ip, .L609+148
 3453              	.LVL420:
 3454              	.LBE967:
 3455              	.LBE966:
 3456              	.LBB972:
 3457              	.LBB973:
 3458              	.LBB974:
 3459              	.LBB975:
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 3460              		.loc 1 183 0
 3461 0b64 E1A00003 		mov	r0, r3
 3462              	.LBE975:
 3463              	.LBE974:
  10:../lib/uart.c **** 	while ((ch = *string)){
 3464              		.loc 2 10 0
 3465 0b68 E3A0206D 		mov	r2, #109
 3466              	.LVL421:
 3467              	.L465:
 3468              	.LBB977:
 3469              	.LBB976:
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 3470              		.loc 1 183 0
 3471 0b6c E5101FE3 		ldr	r1, [r0, #-4067]
 3472 0b70 E3110001 		tst	r1, #1
 3473 0b74 E3E03A0F 		mvn	r3, #61440
 3474 0b78 0AFFFFFB 		beq	.L465
 184:../lib/io_driver.c **** 	UART0_DATA = (ch & 0x000000FF);
 3475              		.loc 1 184 0
 3476 0b7c E5032FE7 		str	r2, [r3, #-4071]
 3477              	.LVL422:
 3478              	.LBE976:
 3479              	.LBE977:
  10:../lib/uart.c **** 	while ((ch = *string)){
 3480              		.loc 2 10 0
 3481 0b80 E5FC2001 		ldrb	r2, [ip, #1]!	@ zero_extendqisi2
 3482              	.LVL423:
 3483 0b84 E3520000 		cmp	r2, #0
 3484 0b88 1AFFFFF7 		bne	.L465
 3485 0b8c E59FC4E8 		ldr	ip, .L609+152
 3486              	.LVL424:
 3487              	.LBE973:
 3488              	.LBE972:
 3489              	.LBB978:
 3490              	.LBB979:
 3491              	.LBB980:
 3492              	.LBB981:
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 3493              		.loc 1 183 0
 3494 0b90 E1A00003 		mov	r0, r3
 3495              	.LBE981:
 3496              	.LBE980:
  10:../lib/uart.c **** 	while ((ch = *string)){
 3497              		.loc 2 10 0
 3498 0b94 E3A02066 		mov	r2, #102
 3499              	.LVL425:
 3500              	.L469:
 3501              	.LBB983:
 3502              	.LBB982:
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 3503              		.loc 1 183 0
 3504 0b98 E5101FE3 		ldr	r1, [r0, #-4067]
 3505 0b9c E3110001 		tst	r1, #1
 3506 0ba0 E3E03A0F 		mvn	r3, #61440
 3507 0ba4 0AFFFFFB 		beq	.L469
 184:../lib/io_driver.c **** 	UART0_DATA = (ch & 0x000000FF);
 3508              		.loc 1 184 0
 3509 0ba8 E5032FE7 		str	r2, [r3, #-4071]
 3510              	.LVL426:
 3511              	.LBE982:
 3512              	.LBE983:
  10:../lib/uart.c **** 	while ((ch = *string)){
 3513              		.loc 2 10 0
 3514 0bac E5FC2001 		ldrb	r2, [ip, #1]!	@ zero_extendqisi2
 3515              	.LVL427:
 3516 0bb0 E3520000 		cmp	r2, #0
 3517 0bb4 1AFFFFF7 		bne	.L469
 3518 0bb8 E59FC4C0 		ldr	ip, .L609+156
 3519              	.LVL428:
 3520              	.LBE979:
 3521              	.LBE978:
 3522              	.LBB984:
 3523              	.LBB985:
 3524              	.LBB986:
 3525              	.LBB987:
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 3526              		.loc 1 183 0
 3527 0bbc E1A00003 		mov	r0, r3
 3528              	.LBE987:
 3529              	.LBE986:
  10:../lib/uart.c **** 	while ((ch = *string)){
 3530              		.loc 2 10 0
 3531 0bc0 E3A02054 		mov	r2, #84
 3532              	.LVL429:
 3533              	.L473:
 3534              	.LBB989:
 3535              	.LBB988:
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 3536              		.loc 1 183 0
 3537 0bc4 E5101FE3 		ldr	r1, [r0, #-4067]
 3538 0bc8 E3110001 		tst	r1, #1
 3539 0bcc E3E03A0F 		mvn	r3, #61440
 3540 0bd0 0AFFFFFB 		beq	.L473
 184:../lib/io_driver.c **** 	UART0_DATA = (ch & 0x000000FF);
 3541              		.loc 1 184 0
 3542 0bd4 E5032FE7 		str	r2, [r3, #-4071]
 3543              	.LVL430:
 3544              	.LBE988:
 3545              	.LBE989:
  10:../lib/uart.c **** 	while ((ch = *string)){
 3546              		.loc 2 10 0
 3547 0bd8 E5FC2001 		ldrb	r2, [ip, #1]!	@ zero_extendqisi2
 3548              	.LVL431:
 3549 0bdc E3520000 		cmp	r2, #0
 3550 0be0 1AFFFFF7 		bne	.L473
 3551 0be4 E59FC498 		ldr	ip, .L609+160
 3552              	.LVL432:
 3553              	.LBE985:
 3554              	.LBE984:
 3555              	.LBB990:
 3556              	.LBB991:
 3557              	.LBB992:
 3558              	.LBB993:
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 3559              		.loc 1 183 0
 3560 0be8 E1A00003 		mov	r0, r3
 3561              	.LBE993:
 3562              	.LBE992:
  10:../lib/uart.c **** 	while ((ch = *string)){
 3563              		.loc 2 10 0
 3564 0bec E3A02046 		mov	r2, #70
 3565              	.LVL433:
 3566              	.L477:
 3567              	.LBB995:
 3568              	.LBB994:
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 3569              		.loc 1 183 0
 3570 0bf0 E5101FE3 		ldr	r1, [r0, #-4067]
 3571 0bf4 E3110001 		tst	r1, #1
 3572 0bf8 E3E03A0F 		mvn	r3, #61440
 3573 0bfc 0AFFFFFB 		beq	.L477
 184:../lib/io_driver.c **** 	UART0_DATA = (ch & 0x000000FF);
 3574              		.loc 1 184 0
 3575 0c00 E5032FE7 		str	r2, [r3, #-4071]
 3576              	.LVL434:
 3577              	.LBE994:
 3578              	.LBE995:
  10:../lib/uart.c **** 	while ((ch = *string)){
 3579              		.loc 2 10 0
 3580 0c04 E5FC2001 		ldrb	r2, [ip, #1]!	@ zero_extendqisi2
 3581              	.LVL435:
 3582 0c08 E3520000 		cmp	r2, #0
 3583 0c0c 1AFFFFF7 		bne	.L477
 3584 0c10 E59FC470 		ldr	ip, .L609+164
 3585              	.LVL436:
 3586              	.LBE991:
 3587              	.LBE990:
 3588              	.LBB996:
 3589              	.LBB997:
 3590              	.LBB998:
 3591              	.LBB999:
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 3592              		.loc 1 183 0
 3593 0c14 E1A00003 		mov	r0, r3
 3594              	.LBE999:
 3595              	.LBE998:
  10:../lib/uart.c **** 	while ((ch = *string)){
 3596              		.loc 2 10 0
 3597 0c18 E3A02068 		mov	r2, #104
 3598              	.LVL437:
 3599              	.L481:
 3600              	.LBB1001:
 3601              	.LBB1000:
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 3602              		.loc 1 183 0
 3603 0c1c E5101FE3 		ldr	r1, [r0, #-4067]
 3604 0c20 E3110001 		tst	r1, #1
 3605 0c24 E3E03A0F 		mvn	r3, #61440
 3606 0c28 0AFFFFFB 		beq	.L481
 184:../lib/io_driver.c **** 	UART0_DATA = (ch & 0x000000FF);
 3607              		.loc 1 184 0
 3608 0c2c E5032FE7 		str	r2, [r3, #-4071]
 3609              	.LVL438:
 3610              	.LBE1000:
 3611              	.LBE1001:
  10:../lib/uart.c **** 	while ((ch = *string)){
 3612              		.loc 2 10 0
 3613 0c30 E5FC2001 		ldrb	r2, [ip, #1]!	@ zero_extendqisi2
 3614              	.LVL439:
 3615 0c34 E3520000 		cmp	r2, #0
 3616 0c38 1AFFFFF7 		bne	.L481
 3617 0c3c E59FC448 		ldr	ip, .L609+168
 3618              	.LVL440:
 3619              	.LBE997:
 3620              	.LBE996:
 3621              	.LBB1002:
 3622              	.LBB1003:
 3623              	.LBB1004:
 3624              	.LBB1005:
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 3625              		.loc 1 183 0
 3626 0c40 E1A00003 		mov	r0, r3
 3627              	.LBE1005:
 3628              	.LBE1004:
  10:../lib/uart.c **** 	while ((ch = *string)){
 3629              		.loc 2 10 0
 3630 0c44 E3A02068 		mov	r2, #104
 3631              	.LVL441:
 3632              	.L485:
 3633              	.LBB1007:
 3634              	.LBB1006:
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 3635              		.loc 1 183 0
 3636 0c48 E5101FE3 		ldr	r1, [r0, #-4067]
 3637 0c4c E3110001 		tst	r1, #1
 3638 0c50 E3E03A0F 		mvn	r3, #61440
 3639 0c54 0AFFFFFB 		beq	.L485
 184:../lib/io_driver.c **** 	UART0_DATA = (ch & 0x000000FF);
 3640              		.loc 1 184 0
 3641 0c58 E5032FE7 		str	r2, [r3, #-4071]
 3642              	.LVL442:
 3643              	.LBE1006:
 3644              	.LBE1007:
  10:../lib/uart.c **** 	while ((ch = *string)){
 3645              		.loc 2 10 0
 3646 0c5c E5FC2001 		ldrb	r2, [ip, #1]!	@ zero_extendqisi2
 3647              	.LVL443:
 3648 0c60 E3520000 		cmp	r2, #0
 3649 0c64 1AFFFFF7 		bne	.L485
 3650 0c68 E59FC420 		ldr	ip, .L609+172
 3651              	.LVL444:
 3652              	.LBE1003:
 3653              	.LBE1002:
 3654              	.LBB1008:
 3655              	.LBB1009:
 3656              	.LBB1010:
 3657              	.LBB1011:
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 3658              		.loc 1 183 0
 3659 0c6c E1A00003 		mov	r0, r3
 3660              	.LBE1011:
 3661              	.LBE1010:
  10:../lib/uart.c **** 	while ((ch = *string)){
 3662              		.loc 2 10 0
 3663 0c70 E3A02043 		mov	r2, #67
 3664              	.LVL445:
 3665              	.L489:
 3666              	.LBB1013:
 3667              	.LBB1012:
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 3668              		.loc 1 183 0
 3669 0c74 E5101FE3 		ldr	r1, [r0, #-4067]
 3670 0c78 E3110001 		tst	r1, #1
 3671 0c7c E3E03A0F 		mvn	r3, #61440
 3672 0c80 0AFFFFFB 		beq	.L489
 184:../lib/io_driver.c **** 	UART0_DATA = (ch & 0x000000FF);
 3673              		.loc 1 184 0
 3674 0c84 E5032FE7 		str	r2, [r3, #-4071]
 3675              	.LVL446:
 3676              	.LBE1012:
 3677              	.LBE1013:
  10:../lib/uart.c **** 	while ((ch = *string)){
 3678              		.loc 2 10 0
 3679 0c88 E5FC2001 		ldrb	r2, [ip, #1]!	@ zero_extendqisi2
 3680              	.LVL447:
 3681 0c8c E3520000 		cmp	r2, #0
 3682 0c90 1AFFFFF7 		bne	.L489
 3683 0c94 E59F03F8 		ldr	r0, .L609+176
 3684              	.LBE1009:
 3685              	.LBE1008:
 3686              	.LBB1014:
 3687              	.LBB1015:
 3688              	.LBB1016:
 3689              	.LBB1017:
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 3690              		.loc 1 183 0
 3691 0c98 E1A01003 		mov	r1, r3
 3692              	.LBE1017:
 3693              	.LBE1016:
  10:../lib/uart.c **** 	while ((ch = *string)){
 3694              		.loc 2 10 0
 3695 0c9c E3A03028 		mov	r3, #40
 3696              	.LVL448:
 3697              	.L493:
 3698              	.LBB1019:
 3699              	.LBB1018:
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 3700              		.loc 1 183 0
 3701 0ca0 E5112FE3 		ldr	r2, [r1, #-4067]
 3702 0ca4 E3120001 		tst	r2, #1
 3703 0ca8 E3E02A0F 		mvn	r2, #61440
 3704 0cac 0AFFFFFB 		beq	.L493
 184:../lib/io_driver.c **** 	UART0_DATA = (ch & 0x000000FF);
 3705              		.loc 1 184 0
 3706 0cb0 E5023FE7 		str	r3, [r2, #-4071]
 3707              	.LVL449:
 3708              	.LBE1018:
 3709              	.LBE1019:
  10:../lib/uart.c **** 	while ((ch = *string)){
 3710              		.loc 2 10 0
 3711 0cb4 E5F03001 		ldrb	r3, [r0, #1]!	@ zero_extendqisi2
 3712              	.LVL450:
 3713 0cb8 E3530000 		cmp	r3, #0
 3714 0cbc 1AFFFFF7 		bne	.L493
 3715 0cc0 EAFFFD20 		b	.L225
 3716              	.LVL451:
 3717              	.L309:
 3718              	.LBE1015:
 3719              	.LBE1014:
 3720              	.LBB1020:
 3721              	.LBB1021:
 3722              	.LBB1022:
 3723              	.LBB1023:
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 3724              		.loc 1 183 0
 3725 0cc4 E3E02A0F 		mvn	r2, #61440
 3726              	.LVL452:
 3727 0cc8 E59F33C8 		ldr	r3, .L609+180
 3728 0ccc E1A00002 		mov	r0, r2
 3729              	.L307:
 3730              	.LVL453:
 3731              	.LBE1023:
 3732              	.LBE1022:
  10:../lib/uart.c **** 	while ((ch = *string)){
 3733              		.loc 2 10 0
 3734 0cd0 E5F31001 		ldrb	r1, [r3, #1]!	@ zero_extendqisi2
 3735              	.LVL454:
 3736 0cd4 E3510000 		cmp	r1, #0
 3737 0cd8 0AFFFD5D 		beq	.L512
 3738              	.L311:
 3739              	.LBB1025:
 3740              	.LBB1024:
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 3741              		.loc 1 183 0
 3742 0cdc E512CFE3 		ldr	ip, [r2, #-4067]
 3743 0ce0 E31C0001 		tst	ip, #1
 3744 0ce4 0AFFFFFC 		beq	.L311
 184:../lib/io_driver.c **** 	UART0_DATA = (ch & 0x000000FF);
 3745              		.loc 1 184 0
 3746 0ce8 E5001FE7 		str	r1, [r0, #-4071]
 3747              	.LVL455:
 3748 0cec EAFFFFF7 		b	.L307
 3749              	.LVL456:
 3750              	.L607:
 3751              	.LBE1024:
 3752              	.LBE1025:
 3753              	.LBE1021:
 3754              	.LBE1020:
  96:main.c        **** 		switch(function_sel){
 3755              		.loc 4 96 0
 3756 0cf0 E3530033 		cmp	r3, #51
 3757 0cf4 0A00016D 		beq	.L605
 3758              	.LVL457:
 3759              	.L228:
 340:main.c        **** 				io_uart0_send_byte((char)function_sel);
 3760              		.loc 4 340 0
 3761 0cf8 E20330FF 		and	r3, r3, #255
 3762              	.LVL458:
 3763              	.LBB1026:
 3764              	.LBB1027:
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 3765              		.loc 1 183 0
 3766 0cfc E3E02A0F 		mvn	r2, #61440
 3767              	.L508:
 3768 0d00 E5121FE3 		ldr	r1, [r2, #-4067]
 3769 0d04 E3110001 		tst	r1, #1
 3770 0d08 E3E01A0F 		mvn	r1, #61440
 3771 0d0c 0AFFFFFB 		beq	.L508
 3772 0d10 E59F0384 		ldr	r0, .L609+184
 184:../lib/io_driver.c **** 	UART0_DATA = (ch & 0x000000FF);
 3773              		.loc 1 184 0
 3774 0d14 E5013FE7 		str	r3, [r1, #-4071]
 3775              	.LVL459:
 3776              	.LBE1027:
 3777              	.LBE1026:
 3778              	.LBB1028:
 3779              	.LBB1029:
  10:../lib/uart.c **** 	while ((ch = *string)){
 3780              		.loc 2 10 0
 3781 0d18 E3A03020 		mov	r3, #32
 3782              	.LVL460:
 3783              	.L510:
 3784              	.LBB1030:
 3785              	.LBB1031:
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 3786              		.loc 1 183 0
 3787 0d1c E5112FE3 		ldr	r2, [r1, #-4067]
 3788 0d20 E3120001 		tst	r2, #1
 3789 0d24 E3E02A0F 		mvn	r2, #61440
 3790 0d28 0AFFFFFB 		beq	.L510
 184:../lib/io_driver.c **** 	UART0_DATA = (ch & 0x000000FF);
 3791              		.loc 1 184 0
 3792 0d2c E5023FE7 		str	r3, [r2, #-4071]
 3793              	.LVL461:
 3794              	.LBE1031:
 3795              	.LBE1030:
  10:../lib/uart.c **** 	while ((ch = *string)){
 3796              		.loc 2 10 0
 3797 0d30 E5F03001 		ldrb	r3, [r0, #1]!	@ zero_extendqisi2
 3798              	.LVL462:
 3799 0d34 E3530000 		cmp	r3, #0
 3800 0d38 1AFFFFF7 		bne	.L510
 3801 0d3c EAFFFD01 		b	.L225
 3802              	.LVL463:
 3803              	.L237:
 3804              	.LBE1029:
 3805              	.LBE1028:
 3806              	.LBB1032:
 3807              	.LBB1033:
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 3808              		.loc 1 183 0
 3809 0d40 E3E03A0F 		mvn	r3, #61440
 3810              	.LVL464:
 3811              	.L496:
 3812 0d44 E5132FE3 		ldr	r2, [r3, #-4067]
 3813 0d48 E3120001 		tst	r2, #1
 3814 0d4c E3E01A0F 		mvn	r1, #61440
 3815 0d50 0AFFFFFB 		beq	.L496
 184:../lib/io_driver.c **** 	UART0_DATA = (ch & 0x000000FF);
 3816              		.loc 1 184 0
 3817 0d54 E3A03066 		mov	r3, #102
 3818 0d58 E5013FE7 		str	r3, [r1, #-4071]
 3819              	.LVL465:
 3820 0d5c E59F033C 		ldr	r0, .L609+188
 3821              	.LBE1033:
 3822              	.LBE1032:
 3823              	.LBB1034:
 3824              	.LBB1035:
  10:../lib/uart.c **** 	while ((ch = *string)){
 3825              		.loc 2 10 0
 3826 0d60 E3A0200D 		mov	r2, #13
 3827              	.LVL466:
 3828              	.L498:
 3829              	.LBB1036:
 3830              	.LBB1037:
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 3831              		.loc 1 183 0
 3832 0d64 E5113FE3 		ldr	r3, [r1, #-4067]
 3833 0d68 E3130001 		tst	r3, #1
 3834 0d6c E3E03A0F 		mvn	r3, #61440
 3835 0d70 0AFFFFFB 		beq	.L498
 184:../lib/io_driver.c **** 	UART0_DATA = (ch & 0x000000FF);
 3836              		.loc 1 184 0
 3837 0d74 E5032FE7 		str	r2, [r3, #-4071]
 3838              	.LVL467:
 3839              	.LBE1037:
 3840              	.LBE1036:
  10:../lib/uart.c **** 	while ((ch = *string)){
 3841              		.loc 2 10 0
 3842 0d78 E5F02001 		ldrb	r2, [r0, #1]!	@ zero_extendqisi2
 3843              	.LVL468:
 3844 0d7c E3520000 		cmp	r2, #0
 3845 0d80 1AFFFFF7 		bne	.L498
 3846 0d84 E59F0318 		ldr	r0, .L609+192
 3847              	.LVL469:
 3848              	.LBE1035:
 3849              	.LBE1034:
 3850              	.LBB1038:
 3851              	.LBB1039:
 3852              	.LBB1040:
 3853              	.LBB1041:
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 3854              		.loc 1 183 0
 3855 0d88 E1A01003 		mov	r1, r3
 3856              	.LBE1041:
 3857              	.LBE1040:
  10:../lib/uart.c **** 	while ((ch = *string)){
 3858              		.loc 2 10 0
 3859 0d8c E3A03020 		mov	r3, #32
 3860              	.LVL470:
 3861              	.L502:
 3862              	.LBB1043:
 3863              	.LBB1042:
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 3864              		.loc 1 183 0
 3865 0d90 E5112FE3 		ldr	r2, [r1, #-4067]
 3866 0d94 E3120001 		tst	r2, #1
 3867 0d98 E3E02A0F 		mvn	r2, #61440
 3868 0d9c 0AFFFFFB 		beq	.L502
 184:../lib/io_driver.c **** 	UART0_DATA = (ch & 0x000000FF);
 3869              		.loc 1 184 0
 3870 0da0 E5023FE7 		str	r3, [r2, #-4071]
 3871              	.LVL471:
 3872              	.LBE1042:
 3873              	.LBE1043:
  10:../lib/uart.c **** 	while ((ch = *string)){
 3874              		.loc 2 10 0
 3875 0da4 E5F03001 		ldrb	r3, [r0, #1]!	@ zero_extendqisi2
 3876              	.LVL472:
 3877 0da8 E3530000 		cmp	r3, #0
 3878 0dac 1AFFFFF7 		bne	.L502
 3879 0db0 EAFFFCE4 		b	.L225
 3880              	.LVL473:
 3881              	.L239:
 3882              	.LBE1039:
 3883              	.LBE1038:
 3884              	.LBB1044:
 3885              	.LBB1045:
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 3886              		.loc 1 183 0
 3887 0db4 E3E03A0F 		mvn	r3, #61440
 3888              	.LVL474:
 3889              	.L365:
 3890 0db8 E5132FE3 		ldr	r2, [r3, #-4067]
 3891 0dbc E3120001 		tst	r2, #1
 3892 0dc0 E3E01A0F 		mvn	r1, #61440
 3893 0dc4 0AFFFFFB 		beq	.L365
 184:../lib/io_driver.c **** 	UART0_DATA = (ch & 0x000000FF);
 3894              		.loc 1 184 0
 3895 0dc8 E3A03035 		mov	r3, #53
 3896 0dcc E59F02D4 		ldr	r0, .L609+196
 3897 0dd0 E5013FE7 		str	r3, [r1, #-4071]
 3898              	.LVL475:
 3899              	.LBE1045:
 3900              	.LBE1044:
 3901              	.LBB1046:
 3902              	.LBB1047:
  10:../lib/uart.c **** 	while ((ch = *string)){
 3903              		.loc 2 10 0
 3904 0dd4 E3A0300D 		mov	r3, #13
 3905              	.LVL476:
 3906              	.L367:
 3907              	.LBB1048:
 3908              	.LBB1049:
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 3909              		.loc 1 183 0
 3910 0dd8 E5112FE3 		ldr	r2, [r1, #-4067]
 3911 0ddc E3120001 		tst	r2, #1
 3912 0de0 E3E06A0F 		mvn	r6, #61440
 3913 0de4 0AFFFFFB 		beq	.L367
 184:../lib/io_driver.c **** 	UART0_DATA = (ch & 0x000000FF);
 3914              		.loc 1 184 0
 3915 0de8 E5063FE7 		str	r3, [r6, #-4071]
 3916              	.LVL477:
 3917              	.LBE1049:
 3918              	.LBE1048:
  10:../lib/uart.c **** 	while ((ch = *string)){
 3919              		.loc 2 10 0
 3920 0dec E5F03001 		ldrb	r3, [r0, #1]!	@ zero_extendqisi2
 3921              	.LVL478:
 3922 0df0 E3530000 		cmp	r3, #0
 3923 0df4 1AFFFFF7 		bne	.L367
 3924              	.LBE1047:
 3925              	.LBE1046:
 252:main.c        **** 				uart0_scanf(buffer,2,1);
 3926              		.loc 4 252 0
 3927 0df8 E1A00005 		mov	r0, r5
 3928              	.LVL479:
 3929 0dfc E3A01002 		mov	r1, #2
 3930 0e00 E3A02001 		mov	r2, #1
 3931 0e04 EBFFFFFE 		bl	uart0_scanf
 3932              	.LVL480:
 253:main.c        **** 				device_id = (unsigned char)hex_string_to_long(buffer, 2);
 3933              		.loc 4 253 0
 3934 0e08 E1A00005 		mov	r0, r5
 3935 0e0c E3A01002 		mov	r1, #2
 3936 0e10 EBFFFFFE 		bl	hex_string_to_long
 3937              	.LVL481:
 254:main.c        **** 				if(device_id == 0){
 3938              		.loc 4 254 0
 3939 0e14 E21040FF 		ands	r4, r0, #255
 3940              	.LVL482:
 3941 0e18 1A000019 		bne	.L370
 3942 0e1c E59F2288 		ldr	r2, .L609+200
 3943              	.LBB1050:
 3944              	.LBB1051:
  10:../lib/uart.c **** 	while ((ch = *string)){
 3945              		.loc 2 10 0
 3946 0e20 E3A03020 		mov	r3, #32
 3947              	.L372:
 3948              	.LBB1052:
 3949              	.LBB1053:
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 3950              		.loc 1 183 0
 3951 0e24 E5161FE3 		ldr	r1, [r6, #-4067]
 3952 0e28 E3110001 		tst	r1, #1
 3953 0e2c E3E01A0F 		mvn	r1, #61440
 3954 0e30 0AFFFFFB 		beq	.L372
 184:../lib/io_driver.c **** 	UART0_DATA = (ch & 0x000000FF);
 3955              		.loc 1 184 0
 3956 0e34 E5013FE7 		str	r3, [r1, #-4071]
 3957              	.LVL483:
 3958              	.LBE1053:
 3959              	.LBE1052:
  10:../lib/uart.c **** 	while ((ch = *string)){
 3960              		.loc 2 10 0
 3961 0e38 E5F23001 		ldrb	r3, [r2, #1]!	@ zero_extendqisi2
 3962              	.LVL484:
 3963 0e3c E3530000 		cmp	r3, #0
 3964 0e40 1AFFFFF7 		bne	.L372
 3965 0e44 EAFFFCBF 		b	.L225
 3966              	.LVL485:
 3967              	.L597:
 3968              	.LBE1051:
 3969              	.LBE1050:
  96:main.c        **** 		switch(function_sel){
 3970              		.loc 4 96 0
 3971 0e48 E3530031 		cmp	r3, #49
 3972 0e4c 0A0000F3 		beq	.L231
 3973 0e50 CA0000A3 		bgt	.L232
 3974 0e54 E3730001 		cmn	r3, #1
 3975 0e58 0AFFFCBA 		beq	.L225
 3976 0e5c E3530030 		cmp	r3, #48
 3977              	.LBB1054:
 3978              	.LBB1055:
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 3979              		.loc 1 183 0
 3980 0e60 03E02A0F 		mvneq	r2, #61440
 3981              	.LVL486:
 3982              	.LBE1055:
 3983              	.LBE1054:
  96:main.c        **** 		switch(function_sel){
 3984              		.loc 4 96 0
 3985 0e64 1AFFFFA3 		bne	.L228
 3986              	.LVL487:
 3987              	.L244:
 3988              	.LBB1057:
 3989              	.LBB1056:
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 3990              		.loc 1 183 0
 3991 0e68 E5123FE3 		ldr	r3, [r2, #-4067]
 3992 0e6c E3130001 		tst	r3, #1
 3993 0e70 E3E03A0F 		mvn	r3, #61440
 3994 0e74 0AFFFFFB 		beq	.L244
 184:../lib/io_driver.c **** 	UART0_DATA = (ch & 0x000000FF);
 3995              		.loc 1 184 0
 3996 0e78 E3A02030 		mov	r2, #48
 3997 0e7c E5032FE7 		str	r2, [r3, #-4071]
 3998              	.LVL488:
 3999              	.LBE1056:
 4000              	.LBE1057:
 103:main.c        **** 				break;
 4001              		.loc 4 103 0
 4002 0e80 EAFFFCF3 		b	.L512
 4003              	.LVL489:
 4004              	.L370:
 4005 0e84 E59F1224 		ldr	r1, .L609+204
 4006              	.LBB1058:
 4007              	.LBB1059:
  10:../lib/uart.c **** 	while ((ch = *string)){
 4008              		.loc 2 10 0
 4009 0e88 E3A0300D 		mov	r3, #13
 4010              	.L375:
 4011              	.LBB1060:
 4012              	.LBB1061:
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 4013              		.loc 1 183 0
 4014 0e8c E5162FE3 		ldr	r2, [r6, #-4067]
 4015 0e90 E3120001 		tst	r2, #1
 4016 0e94 E3E02A0F 		mvn	r2, #61440
 4017 0e98 0AFFFFFB 		beq	.L375
 184:../lib/io_driver.c **** 	UART0_DATA = (ch & 0x000000FF);
 4018              		.loc 1 184 0
 4019 0e9c E5023FE7 		str	r3, [r2, #-4071]
 4020              	.LVL490:
 4021              	.LBE1061:
 4022              	.LBE1060:
  10:../lib/uart.c **** 	while ((ch = *string)){
 4023              		.loc 2 10 0
 4024 0ea0 E5F13001 		ldrb	r3, [r1, #1]!	@ zero_extendqisi2
 4025              	.LVL491:
 4026 0ea4 E3530000 		cmp	r3, #0
 4027 0ea8 1AFFFFF7 		bne	.L375
 4028 0eac E59F1200 		ldr	r1, .L609+208
 4029              	.LVL492:
 4030              	.LBE1059:
 4031              	.LBE1058:
 4032              	.LBB1062:
 4033              	.LBB1063:
 4034              	.LBB1064:
 4035              	.LBB1065:
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 4036              		.loc 1 183 0
 4037 0eb0 E1A00002 		mov	r0, r2
 4038              	.LBE1065:
 4039              	.LBE1064:
  10:../lib/uart.c **** 	while ((ch = *string)){
 4040              		.loc 2 10 0
 4041 0eb4 E3A03074 		mov	r3, #116
 4042              	.LVL493:
 4043              	.L379:
 4044              	.LBB1067:
 4045              	.LBB1066:
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 4046              		.loc 1 183 0
 4047 0eb8 E5102FE3 		ldr	r2, [r0, #-4067]
 4048 0ebc E3120001 		tst	r2, #1
 4049 0ec0 E3E02A0F 		mvn	r2, #61440
 4050 0ec4 0AFFFFFB 		beq	.L379
 184:../lib/io_driver.c **** 	UART0_DATA = (ch & 0x000000FF);
 4051              		.loc 1 184 0
 4052 0ec8 E5023FE7 		str	r3, [r2, #-4071]
 4053              	.LVL494:
 4054              	.LBE1066:
 4055              	.LBE1067:
  10:../lib/uart.c **** 	while ((ch = *string)){
 4056              		.loc 2 10 0
 4057 0ecc E5F13001 		ldrb	r3, [r1, #1]!	@ zero_extendqisi2
 4058              	.LVL495:
 4059 0ed0 E3530000 		cmp	r3, #0
 4060 0ed4 1AFFFFF7 		bne	.L379
 4061              	.LBE1063:
 4062              	.LBE1062:
 4063              	.LBB1069:
 4064              	.LBB1070:
 166:../lib/io_driver.c **** 	if ((UART0_SREG & (1<<CUART_RXD)) != 0) // byte available?
 4065              		.loc 1 166 0
 4066 0ed8 E1A03002 		mov	r3, r2
 4067              	.L382:
 166:../lib/io_driver.c **** 	if ((UART0_SREG & (1<<CUART_RXD)) != 0) // byte available?
 4068              		.loc 1 166 0 is_stmt 0 discriminator 1
 4069 0edc E5132FE3 		ldr	r2, [r3, #-4067]
 4070 0ee0 E3120002 		tst	r2, #2
 4071 0ee4 0AFFFFFC 		beq	.L382
 167:../lib/io_driver.c **** 		temp = UART0_DATA;
 4072              		.loc 1 167 0 is_stmt 1
 4073 0ee8 E5132FE7 		ldr	r2, [r3, #-4071]
 4074              	.LVL496:
 4075              	.LBE1070:
 4076              	.LBE1069:
 260:main.c        **** 				while(io_uart0_read_byte() == -1);
 4077              		.loc 4 260 0
 4078 0eec E3720001 		cmn	r2, #1
 4079 0ef0 0AFFFFF9 		beq	.L382
 4080              	.LBB1071:
 4081              	.LBB1072:
 166:../lib/io_driver.c **** 	if ((UART0_SREG & (1<<CUART_RXD)) != 0) // byte available?
 4082              		.loc 1 166 0
 4083 0ef4 E3E03A0F 		mvn	r3, #61440
 4084              	.LVL497:
 4085              	.L385:
 166:../lib/io_driver.c **** 	if ((UART0_SREG & (1<<CUART_RXD)) != 0) // byte available?
 4086              		.loc 1 166 0 is_stmt 0 discriminator 1
 4087 0ef8 E5132FE3 		ldr	r2, [r3, #-4067]
 4088 0efc E3120002 		tst	r2, #2
 4089 0f00 1A000033 		bne	.L606
 4090              	.L384:
 4091              	.LBE1072:
 4092              	.LBE1071:
 4093              	.LBB1074:
 4094              	.LBB1068:
  10:../lib/uart.c **** 	while ((ch = *string)){
 4095              		.loc 2 10 0 is_stmt 1 discriminator 1
 4096 0f04 E3A06000 		mov	r6, #0
 4097              	.LBE1068:
 4098              	.LBE1074:
 265:main.c        **** 							data = io_i2c0_byte_transfer('r', device_id, i, 2, 0x00);
 4099              		.loc 4 265 0 discriminator 1
 4100 0f08 E1A0A006 		mov	r10, r6
 4101              	.LBB1075:
 4102              	.LBB1076:
 166:../lib/io_driver.c **** 	if ((UART0_SREG & (1<<CUART_RXD)) != 0) // byte available?
 4103              		.loc 1 166 0 discriminator 1
 4104 0f0c E3E08A0F 		mvn	r8, #61440
 4105              	.LBE1076:
 4106              	.LBE1075:
 262:main.c        **** 				for(i=0; i<0xFFFF; i++){
 4107              		.loc 4 262 0 discriminator 1
 4108 0f10 E59F91A0 		ldr	r9, .L609+212
 4109 0f14 EA000001 		b	.L388
 4110              	.LVL498:
 4111              	.L386:
 264:main.c        **** 						while(data < 0){
 4112              		.loc 4 264 0 discriminator 1
 4113 0f18 E3500000 		cmp	r0, #0
 4114 0f1c AA000022 		bge	.L396
 4115              	.LVL499:
 4116              	.L388:
 265:main.c        **** 							data = io_i2c0_byte_transfer('r', device_id, i, 2, 0x00);
 4117              		.loc 4 265 0
 4118 0f20 E3A03002 		mov	r3, #2
 4119 0f24 E58DA000 		str	r10, [sp]
 4120 0f28 E3A00072 		mov	r0, #114
 4121 0f2c E1A01004 		mov	r1, r4
 4122 0f30 E1A02006 		mov	r2, r6
 4123 0f34 EBFFFFFE 		bl	io_i2c0_byte_transfer
 4124              	.LVL500:
 4125              	.LBB1078:
 4126              	.LBB1077:
 166:../lib/io_driver.c **** 	if ((UART0_SREG & (1<<CUART_RXD)) != 0) // byte available?
 4127              		.loc 1 166 0
 4128 0f38 E5183FE3 		ldr	r3, [r8, #-4067]
 4129 0f3c E3130002 		tst	r3, #2
 4130 0f40 0AFFFFF4 		beq	.L386
 167:../lib/io_driver.c **** 		temp = UART0_DATA;
 4131              		.loc 1 167 0
 4132 0f44 E5183FE7 		ldr	r3, [r8, #-4071]
 4133              	.LVL501:
 4134              	.LBE1077:
 4135              	.LBE1078:
 266:main.c        **** 							if(io_uart0_read_byte() != -1){
 4136              		.loc 4 266 0
 4137 0f48 E3730001 		cmn	r3, #1
 4138 0f4c 0AFFFFF1 		beq	.L386
 4139 0f50 E59F2164 		ldr	r2, .L609+216
 4140              	.LBB1079:
 4141              	.LBB1080:
  10:../lib/uart.c **** 	while ((ch = *string)){
 4142              		.loc 2 10 0
 4143 0f54 E3A0300D 		mov	r3, #13
 4144              	.LVL502:
 4145              	.LBB1081:
 4146              	.LBB1082:
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 4147              		.loc 1 183 0
 4148 0f58 E3E01A0F 		mvn	r1, #61440
 4149              	.LVL503:
 4150              	.L392:
 4151 0f5c E5110FE3 		ldr	r0, [r1, #-4067]
 4152 0f60 E3100001 		tst	r0, #1
 4153 0f64 E3E00A0F 		mvn	r0, #61440
 4154 0f68 0AFFFFFB 		beq	.L392
 184:../lib/io_driver.c **** 	UART0_DATA = (ch & 0x000000FF);
 4155              		.loc 1 184 0
 4156 0f6c E5003FE7 		str	r3, [r0, #-4071]
 4157              	.LVL504:
 4158              	.LBE1082:
 4159              	.LBE1081:
  10:../lib/uart.c **** 	while ((ch = *string)){
 4160              		.loc 2 10 0
 4161 0f70 E5F23001 		ldrb	r3, [r2, #1]!	@ zero_extendqisi2
 4162              	.LVL505:
 4163 0f74 E3530000 		cmp	r3, #0
 4164 0f78 1AFFFFF7 		bne	.L392
 4165              	.LVL506:
 4166              	.L393:
 4167 0f7c E59F2144 		ldr	r2, .L609+228
 4168              	.LBE1080:
 4169              	.LBE1079:
 4170              	.LBB1083:
 4171              	.LBB1084:
 4172 0f80 E3A0300D 		mov	r3, #13
 4173              	.LBB1085:
 4174              	.LBB1086:
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 4175              		.loc 1 183 0
 4176 0f84 E3E01A0F 		mvn	r1, #61440
 4177              	.LVL507:
 4178              	.L399:
 4179 0f88 E5110FE3 		ldr	r0, [r1, #-4067]
 4180 0f8c E3100001 		tst	r0, #1
 4181 0f90 E3E00A0F 		mvn	r0, #61440
 4182 0f94 0AFFFFFB 		beq	.L399
 184:../lib/io_driver.c **** 	UART0_DATA = (ch & 0x000000FF);
 4183              		.loc 1 184 0
 4184 0f98 E5003FE7 		str	r3, [r0, #-4071]
 4185              	.LVL508:
 4186              	.LBE1086:
 4187              	.LBE1085:
  10:../lib/uart.c **** 	while ((ch = *string)){
 4188              		.loc 2 10 0
 4189 0f9c E5F23001 		ldrb	r3, [r2, #1]!	@ zero_extendqisi2
 4190              	.LVL509:
 4191 0fa0 E3530000 		cmp	r3, #0
 4192 0fa4 1AFFFFF7 		bne	.L399
 4193 0fa8 EAFFFC66 		b	.L225
 4194              	.LVL510:
 4195              	.L396:
 4196              	.LBE1084:
 4197              	.LBE1083:
 4198              	.LBB1087:
 4199              	.LBB1088:
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 4200              		.loc 1 183 0
 4201 0fac E5183FE3 		ldr	r3, [r8, #-4067]
 4202 0fb0 E3130001 		tst	r3, #1
 4203 0fb4 E3E03A0F 		mvn	r3, #61440
 4204 0fb8 0AFFFFFB 		beq	.L396
 4205              	.LBE1088:
 4206              	.LBE1087:
 262:main.c        **** 				for(i=0; i<0xFFFF; i++){
 4207              		.loc 4 262 0
 4208 0fbc E2866001 		add	r6, r6, #1
 4209              	.LVL511:
 4210              	.LBB1091:
 4211              	.LBB1089:
 184:../lib/io_driver.c **** 	UART0_DATA = (ch & 0x000000FF);
 4212              		.loc 1 184 0
 4213 0fc0 E20000FF 		and	r0, r0, #255
 4214              	.LVL512:
 4215              	.LBE1089:
 4216              	.LBE1091:
 262:main.c        **** 				for(i=0; i<0xFFFF; i++){
 4217              		.loc 4 262 0
 4218 0fc4 E1560009 		cmp	r6, r9
 4219              	.LBB1092:
 4220              	.LBB1090:
 184:../lib/io_driver.c **** 	UART0_DATA = (ch & 0x000000FF);
 4221              		.loc 1 184 0
 4222 0fc8 E5030FE7 		str	r0, [r3, #-4071]
 4223              	.LBE1090:
 4224              	.LBE1092:
 262:main.c        **** 				for(i=0; i<0xFFFF; i++){
 4225              		.loc 4 262 0
 4226 0fcc 1AFFFFD3 		bne	.L388
 4227 0fd0 EAFFFFE9 		b	.L393
 4228              	.LVL513:
 4229              	.L606:
 4230              	.LBB1093:
 4231              	.LBB1073:
 167:../lib/io_driver.c **** 		temp = UART0_DATA;
 4232              		.loc 1 167 0
 4233 0fd4 E5132FE7 		ldr	r2, [r3, #-4071]
 4234              	.LVL514:
 4235              	.LBE1073:
 4236              	.LBE1093:
 261:main.c        **** 				while(io_uart0_read_byte() != -1);
 4237              		.loc 4 261 0
 4238 0fd8 E3720001 		cmn	r2, #1
 4239 0fdc 1AFFFFC5 		bne	.L385
 4240 0fe0 EAFFFFC7 		b	.L384
 4241              	.L610:
 4242              		.align	2
 4243              	.L609:
 4244 0fe4 000006F8 		.word	.LC30
 4245 0fe8 0000072C 		.word	.LC31
 4246 0fec 00000798 		.word	.LC32
 4247 0ff0 00000C20 		.word	.LC56
 4248 0ff4 000004F8 		.word	.LC18
 4249 0ff8 00000C7C 		.word	.LC58
 4250 0ffc 00000000 		.word	.LC0
 4251 1000 0000004C 		.word	.LC1
 4252 1004 00000094 		.word	.LC2
 4253 1008 000000DC 		.word	.LC3
 4254 100c 00000124 		.word	.LC4
 4255 1010 0000016C 		.word	.LC5
 4256 1014 000001B4 		.word	.LC6
 4257 1018 00000220 		.word	.LC7
 4258 101c 00000258 		.word	.LC8
 4259 1020 000002BC 		.word	.LC9
 4260 1024 00000320 		.word	.LC10
 4261 1028 00000538 		.word	.LC20
 4262 102c 00000558 		.word	.LC21
 4263 1030 000005B8 		.word	.LC22
 4264 1034 00000C70 		.word	.LC57
 4265 1038 0000FFFC 		.word	65532
 4266 103c FFFFFFFF 		.word	.LC23-1
 4267 1040 FFFFFFFF 		.word	.LC24-1
 4268 1044 FFFFFFFF 		.word	.LC25-1
 4269 1048 000007DC 		.word	.LC33
 4270 104c 000007F8 		.word	.LC34
 4271 1050 00000818 		.word	.LC35
 4272 1054 00000858 		.word	.LC36
 4273 1058 0000088C 		.word	.LC37
 4274 105c 000008C8 		.word	.LC38
 4275 1060 00000904 		.word	.LC39
 4276 1064 00000928 		.word	.LC40
 4277 1068 00000964 		.word	.LC41
 4278 106c 00000980 		.word	.LC42
 4279 1070 00000998 		.word	.LC43
 4280 1074 000009E0 		.word	.LC44
 4281 1078 00000A20 		.word	.LC45
 4282 107c 00000A58 		.word	.LC46
 4283 1080 00000A7C 		.word	.LC47
 4284 1084 00000AC0 		.word	.LC48
 4285 1088 00000B00 		.word	.LC49
 4286 108c 00000B2C 		.word	.LC50
 4287 1090 00000B58 		.word	.LC51
 4288 1094 00000B7C 		.word	.LC52
 4289 1098 FFFFFFFF 		.word	.LC19-1
 4290 109c 00000BFC 		.word	.LC55
 4291 10a0 00000BA4 		.word	.LC53
 4292 10a4 00000BD4 		.word	.LC54
 4293 10a8 00000624 		.word	.LC26
 4294 10ac 000004D8 		.word	.LC17
 4295 10b0 00000660 		.word	.LC27
 4296 10b4 000006A0 		.word	.LC28
 4297 10b8 0000FFFF 		.word	65535
 4298 10bc 000006E8 		.word	.LC29
 4299 10c0 00000430 		.word	.LC14
 4300 10c4 00007FFC 		.word	32764
 4301 10c8 00000478 		.word	.LC15
 4302 10cc 00000370 		.word	.LC11
 4303 10d0 000003E4 		.word	.LC12
 4304 10d4 0000049C 		.word	.LC16
 4305 10d8 00000001 		.word	.LC17+1
 4306 10dc 00007FF8 		.word	32760
 4307 10e0 FFFFFFFF 		.word	.LC13-1
 4308              	.LVL515:
 4309              	.L232:
  96:main.c        **** 		switch(function_sel){
 4310              		.loc 4 96 0
 4311 10e4 E3530032 		cmp	r3, #50
 4312              	.LBB1094:
 4313              	.LBB1095:
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 4314              		.loc 1 183 0
 4315 10e8 03E03A0F 		mvneq	r3, #61440
 4316              	.LVL516:
 4317              	.LBE1095:
 4318              	.LBE1094:
  96:main.c        **** 		switch(function_sel){
 4319              		.loc 4 96 0
 4320 10ec 1AFFFEFF 		bne	.L607
 4321              	.LVL517:
 4322              	.L266:
 4323              	.LBB1097:
 4324              	.LBB1096:
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 4325              		.loc 1 183 0
 4326 10f0 E5132FE3 		ldr	r2, [r3, #-4067]
 4327 10f4 E3120001 		tst	r2, #1
 4328 10f8 E3E01A0F 		mvn	r1, #61440
 4329 10fc 0AFFFFFB 		beq	.L266
 184:../lib/io_driver.c **** 	UART0_DATA = (ch & 0x000000FF);
 4330              		.loc 1 184 0
 4331 1100 E3A03032 		mov	r3, #50
 4332 1104 E5013FE7 		str	r3, [r1, #-4071]
 4333              	.LVL518:
 4334 1108 E51F0050 		ldr	r0, .L609+220
 4335              	.LBE1096:
 4336              	.LBE1097:
 4337              	.LBB1098:
 4338              	.LBB1099:
  10:../lib/uart.c **** 	while ((ch = *string)){
 4339              		.loc 2 10 0
 4340 110c E3A0200D 		mov	r2, #13
 4341              	.LVL519:
 4342              	.L268:
 4343              	.LBB1100:
 4344              	.LBB1101:
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 4345              		.loc 1 183 0
 4346 1110 E5113FE3 		ldr	r3, [r1, #-4067]
 4347 1114 E3130001 		tst	r3, #1
 4348 1118 E3E03A0F 		mvn	r3, #61440
 4349 111c 0AFFFFFB 		beq	.L268
 184:../lib/io_driver.c **** 	UART0_DATA = (ch & 0x000000FF);
 4350              		.loc 1 184 0
 4351 1120 E5032FE7 		str	r2, [r3, #-4071]
 4352              	.LVL520:
 4353              	.LBE1101:
 4354              	.LBE1100:
  10:../lib/uart.c **** 	while ((ch = *string)){
 4355              		.loc 2 10 0
 4356 1124 E5F02001 		ldrb	r2, [r0, #1]!	@ zero_extendqisi2
 4357              	.LVL521:
 4358 1128 E3520000 		cmp	r2, #0
 4359 112c 1AFFFFF7 		bne	.L268
 4360              	.L271:
 4361              	.LBE1099:
 4362              	.LBE1098:
 4363              	.LBB1104:
 4364              	.LBB1105:
 166:../lib/io_driver.c **** 	if ((UART0_SREG & (1<<CUART_RXD)) != 0) // byte available?
 4365              		.loc 1 166 0 discriminator 1
 4366 1130 E5132FE3 		ldr	r2, [r3, #-4067]
 4367 1134 E3120002 		tst	r2, #2
 4368 1138 0AFFFFFC 		beq	.L271
 167:../lib/io_driver.c **** 		temp = UART0_DATA;
 4369              		.loc 1 167 0
 4370 113c E5132FE7 		ldr	r2, [r3, #-4071]
 4371              	.LVL522:
 4372              	.LBE1105:
 4373              	.LBE1104:
 135:main.c        **** 				while(io_uart0_read_byte() == -1);
 4374              		.loc 4 135 0
 4375 1140 E3720001 		cmn	r2, #1
 4376 1144 0AFFFFF9 		beq	.L271
 4377              	.LBB1106:
 4378              	.LBB1107:
 166:../lib/io_driver.c **** 	if ((UART0_SREG & (1<<CUART_RXD)) != 0) // byte available?
 4379              		.loc 1 166 0
 4380 1148 E3E03A0F 		mvn	r3, #61440
 4381              	.LVL523:
 4382              	.L276:
 166:../lib/io_driver.c **** 	if ((UART0_SREG & (1<<CUART_RXD)) != 0) // byte available?
 4383              		.loc 1 166 0 is_stmt 0 discriminator 1
 4384 114c E5132FE3 		ldr	r2, [r3, #-4067]
 4385 1150 E3120002 		tst	r2, #2
 4386 1154 1A00009E 		bne	.L273
 4387              	.L275:
 4388              	.LBE1107:
 4389              	.LBE1106:
 138:main.c        **** 				while(data_pointer != RAM_SIZE){
 4390              		.loc 4 138 0 is_stmt 1
 4391 1158 E51FC09C 		ldr	ip, .L609+224
 4392              	.LBB1109:
 4393              	.LBB1102:
  10:../lib/uart.c **** 	while ((ch = *string)){
 4394              		.loc 2 10 0
 4395 115c E3E00003 		mvn	r0, #3
 4396              	.LVL524:
 4397              	.LBE1102:
 4398              	.LBE1109:
 4399              	.LBB1110:
 4400              	.LBB1111:
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 4401              		.loc 1 183 0
 4402 1160 E3E03A0F 		mvn	r3, #61440
 4403              	.L274:
 4404              	.LVL525:
 4405              	.LBE1111:
 4406              	.LBE1110:
 139:main.c        **** 					word_buffer = *data_pointer;
 4407              		.loc 4 139 0
 4408 1164 E5B01004 		ldr	r1, [r0, #4]!
 4409              	.LVL526:
 140:main.c        **** 					io_uart0_send_byte(word_buffer >> 24);
 4410              		.loc 4 140 0
 4411 1168 E1A0EC21 		mov	lr, r1, lsr #24
 4412              	.LVL527:
 4413              	.L278:
 4414              	.LBB1113:
 4415              	.LBB1112:
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 4416              		.loc 1 183 0
 4417 116c E5132FE3 		ldr	r2, [r3, #-4067]
 4418 1170 E3120001 		tst	r2, #1
 4419 1174 E3E02A0F 		mvn	r2, #61440
 4420 1178 0AFFFFFB 		beq	.L278
 184:../lib/io_driver.c **** 	UART0_DATA = (ch & 0x000000FF);
 4421              		.loc 1 184 0
 4422 117c E502EFE7 		str	lr, [r2, #-4071]
 4423              	.LBE1112:
 4424              	.LBE1113:
 141:main.c        **** 					io_uart0_send_byte(word_buffer >> 16);
 4425              		.loc 4 141 0
 4426 1180 E1A0E821 		mov	lr, r1, lsr #16
 4427              	.LVL528:
 4428              	.L280:
 4429              	.LBB1114:
 4430              	.LBB1115:
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 4431              		.loc 1 183 0
 4432 1184 E5132FE3 		ldr	r2, [r3, #-4067]
 4433 1188 E3120001 		tst	r2, #1
 4434 118c E3E02A0F 		mvn	r2, #61440
 4435 1190 0AFFFFFB 		beq	.L280
 184:../lib/io_driver.c **** 	UART0_DATA = (ch & 0x000000FF);
 4436              		.loc 1 184 0
 4437 1194 E20EE0FF 		and	lr, lr, #255
 4438              	.LVL529:
 4439 1198 E502EFE7 		str	lr, [r2, #-4071]
 4440              	.LVL530:
 4441              	.LBE1115:
 4442              	.LBE1114:
 142:main.c        **** 					io_uart0_send_byte(word_buffer >>  8);
 4443              		.loc 4 142 0
 4444 119c E1A0E421 		mov	lr, r1, lsr #8
 4445              	.LVL531:
 4446              	.L282:
 4447              	.LBB1116:
 4448              	.LBB1117:
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 4449              		.loc 1 183 0
 4450 11a0 E5132FE3 		ldr	r2, [r3, #-4067]
 4451 11a4 E3120001 		tst	r2, #1
 4452 11a8 E3E02A0F 		mvn	r2, #61440
 4453 11ac 0AFFFFFB 		beq	.L282
 184:../lib/io_driver.c **** 	UART0_DATA = (ch & 0x000000FF);
 4454              		.loc 1 184 0
 4455 11b0 E20EE0FF 		and	lr, lr, #255
 4456              	.LVL532:
 4457 11b4 E502EFE7 		str	lr, [r2, #-4071]
 4458              	.LVL533:
 4459              	.L284:
 4460              	.LBE1117:
 4461              	.LBE1116:
 4462              	.LBB1118:
 4463              	.LBB1119:
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 4464              		.loc 1 183 0
 4465 11b8 E5132FE3 		ldr	r2, [r3, #-4067]
 4466 11bc E3120001 		tst	r2, #1
 4467 11c0 E3E02A0F 		mvn	r2, #61440
 4468 11c4 0AFFFFFB 		beq	.L284
 184:../lib/io_driver.c **** 	UART0_DATA = (ch & 0x000000FF);
 4469              		.loc 1 184 0
 4470 11c8 E20110FF 		and	r1, r1, #255
 4471              	.LVL534:
 4472 11cc E5021FE7 		str	r1, [r2, #-4071]
 4473              	.LVL535:
 4474              	.LBE1119:
 4475              	.LBE1118:
 4476              	.LBB1120:
 4477              	.LBB1121:
 166:../lib/io_driver.c **** 	if ((UART0_SREG & (1<<CUART_RXD)) != 0) // byte available?
 4478              		.loc 1 166 0
 4479 11d0 E5121FE3 		ldr	r1, [r2, #-4067]
 4480 11d4 E3110002 		tst	r1, #2
 4481 11d8 0A000002 		beq	.L285
 167:../lib/io_driver.c **** 		temp = UART0_DATA;
 4482              		.loc 1 167 0
 4483 11dc E5122FE7 		ldr	r2, [r2, #-4071]
 4484              	.LVL536:
 4485              	.LBE1121:
 4486              	.LBE1120:
 145:main.c        **** 					if(io_uart0_read_byte() != -1){
 4487              		.loc 4 145 0
 4488 11e0 E3720001 		cmn	r2, #1
 4489 11e4 1A000001 		bne	.L286
 4490              	.LVL537:
 4491              	.L285:
 138:main.c        **** 				while(data_pointer != RAM_SIZE){
 4492              		.loc 4 138 0 discriminator 1
 4493 11e8 E150000C 		cmp	r0, ip
 4494 11ec 1AFFFFDC 		bne	.L274
 4495              	.L286:
 4496 11f0 E51F0130 		ldr	r0, .L609+228
 4497              	.LVL538:
 4498              	.LBB1122:
 4499              	.LBB1103:
  10:../lib/uart.c **** 	while ((ch = *string)){
 4500              		.loc 2 10 0
 4501 11f4 E3A0300D 		mov	r3, #13
 4502              	.LBE1103:
 4503              	.LBE1122:
 4504              	.LBB1123:
 4505              	.LBB1124:
 4506              	.LBB1125:
 4507              	.LBB1126:
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 4508              		.loc 1 183 0
 4509 11f8 E3E01A0F 		mvn	r1, #61440
 4510              	.L288:
 4511 11fc E5112FE3 		ldr	r2, [r1, #-4067]
 4512 1200 E3120001 		tst	r2, #1
 4513 1204 E3E02A0F 		mvn	r2, #61440
 4514 1208 0AFFFFFB 		beq	.L288
 184:../lib/io_driver.c **** 	UART0_DATA = (ch & 0x000000FF);
 4515              		.loc 1 184 0
 4516 120c E5023FE7 		str	r3, [r2, #-4071]
 4517              	.LVL539:
 4518              	.LBE1126:
 4519              	.LBE1125:
  10:../lib/uart.c **** 	while ((ch = *string)){
 4520              		.loc 2 10 0
 4521 1210 E5F03001 		ldrb	r3, [r0, #1]!	@ zero_extendqisi2
 4522              	.LVL540:
 4523 1214 E3530000 		cmp	r3, #0
 4524 1218 1AFFFFF7 		bne	.L288
 4525 121c EAFFFBC9 		b	.L225
 4526              	.LVL541:
 4527              	.L231:
 4528              	.LBE1124:
 4529              	.LBE1123:
 4530              	.LBB1127:
 4531              	.LBB1128:
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 4532              		.loc 1 183 0
 4533 1220 E3E03A0F 		mvn	r3, #61440
 4534              	.LVL542:
 4535              	.L247:
 4536 1224 E5132FE3 		ldr	r2, [r3, #-4067]
 4537 1228 E3120001 		tst	r2, #1
 4538 122c E3E02A0F 		mvn	r2, #61440
 4539 1230 0AFFFFFB 		beq	.L247
 184:../lib/io_driver.c **** 	UART0_DATA = (ch & 0x000000FF);
 4540              		.loc 1 184 0
 4541 1234 E3A03031 		mov	r3, #49
 4542 1238 E5023FE7 		str	r3, [r2, #-4071]
 4543              	.LVL543:
 4544 123c E51F1178 		ldr	r1, .L609+232
 4545              	.LBE1128:
 4546              	.LBE1127:
 4547              	.LBB1129:
 4548              	.LBB1130:
  10:../lib/uart.c **** 	while ((ch = *string)){
 4549              		.loc 2 10 0
 4550 1240 E3A0400D 		mov	r4, #13
 4551              	.LVL544:
 4552              	.L249:
 4553              	.LBB1131:
 4554              	.LBB1132:
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 4555              		.loc 1 183 0
 4556 1244 E5123FE3 		ldr	r3, [r2, #-4067]
 4557 1248 E3130001 		tst	r3, #1
 4558 124c E3E06A0F 		mvn	r6, #61440
 4559 1250 0AFFFFFB 		beq	.L249
 184:../lib/io_driver.c **** 	UART0_DATA = (ch & 0x000000FF);
 4560              		.loc 1 184 0
 4561 1254 E5064FE7 		str	r4, [r6, #-4071]
 4562              	.LVL545:
 4563              	.LBE1132:
 4564              	.LBE1131:
  10:../lib/uart.c **** 	while ((ch = *string)){
 4565              		.loc 2 10 0
 4566 1258 E5F14001 		ldrb	r4, [r1, #1]!	@ zero_extendqisi2
 4567              	.LVL546:
 4568 125c E3540000 		cmp	r4, #0
 4569 1260 1AFFFFF7 		bne	.L249
 4570              	.LBE1130:
 4571              	.LBE1129:
 110:main.c        **** 				uart0_scanf(buffer,4,0); // get storm master boot record code
 4572              		.loc 4 110 0
 4573 1264 E1A00005 		mov	r0, r5
 4574 1268 E3A01004 		mov	r1, #4
 4575              	.LVL547:
 4576 126c E1A02004 		mov	r2, r4
 4577 1270 EBFFFFFE 		bl	uart0_scanf
 4578              	.LVL548:
 111:main.c        **** 				if((buffer[0] == 'S') && (buffer[1] == 'M') && (buffer[2] == 'B') && (buffer[3] == 'R')){
 4579              		.loc 4 111 0
 4580 1274 E5DD3008 		ldrb	r3, [sp, #8]	@ zero_extendqisi2
 4581 1278 E3530053 		cmp	r3, #83
 4582 127c 0A000031 		beq	.L608
 4583              	.L252:
 4584 1280 E51F01B8 		ldr	r0, .L609+236
 114:main.c        **** 					if (adr_buffer > RAM_SIZE-8){
 4585              		.loc 4 114 0
 4586 1284 E3A03020 		mov	r3, #32
 4587              	.LBB1133:
 4588              	.LBB1134:
 4589              	.LBB1135:
 4590              	.LBB1136:
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 4591              		.loc 1 183 0
 4592 1288 E3E01A0F 		mvn	r1, #61440
 4593              	.L264:
 4594 128c E5112FE3 		ldr	r2, [r1, #-4067]
 4595 1290 E3120001 		tst	r2, #1
 4596 1294 E3E02A0F 		mvn	r2, #61440
 4597 1298 0AFFFFFB 		beq	.L264
 184:../lib/io_driver.c **** 	UART0_DATA = (ch & 0x000000FF);
 4598              		.loc 1 184 0
 4599 129c E5023FE7 		str	r3, [r2, #-4071]
 4600              	.LVL549:
 4601              	.LBE1136:
 4602              	.LBE1135:
  10:../lib/uart.c **** 	while ((ch = *string)){
 4603              		.loc 2 10 0
 4604 12a0 E5F03001 		ldrb	r3, [r0, #1]!	@ zero_extendqisi2
 4605              	.LVL550:
 4606 12a4 E3530000 		cmp	r3, #0
 4607 12a8 1AFFFFF7 		bne	.L264
 4608 12ac EAFFFBA5 		b	.L225
 4609              	.LVL551:
 4610              	.L605:
 4611              	.LBE1134:
 4612              	.LBE1133:
 4613              	.LBB1137:
 4614              	.LBB1138:
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 4615              		.loc 1 183 0
 4616 12b0 E3E02A0F 		mvn	r2, #61440
 4617              	.LVL552:
 4618              	.L291:
 4619 12b4 E5123FE3 		ldr	r3, [r2, #-4067]
 4620 12b8 E3130001 		tst	r3, #1
 4621 12bc E3E03A0F 		mvn	r3, #61440
 4622 12c0 0AFFFFFB 		beq	.L291
 184:../lib/io_driver.c **** 	UART0_DATA = (ch & 0x000000FF);
 4623              		.loc 1 184 0
 4624 12c4 E3A02033 		mov	r2, #51
 4625 12c8 E5032FE7 		str	r2, [r3, #-4071]
 4626              	.LVL553:
 4627 12cc E51F2200 		ldr	r2, .L609+240
 4628              	.LBE1138:
 4629              	.LBE1137:
 4630              	.LBB1139:
 4631              	.LBB1140:
 4632              	.LBB1141:
 4633              	.LBB1142:
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 4634              		.loc 1 183 0
 4635 12d0 E1A01003 		mov	r1, r3
 4636              	.LBE1142:
 4637              	.LBE1141:
  10:../lib/uart.c **** 	while ((ch = *string)){
 4638              		.loc 2 10 0
 4639 12d4 E3A0300D 		mov	r3, #13
 4640              	.LVL554:
 4641              	.L293:
 4642              	.LBB1144:
 4643              	.LBB1143:
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 4644              		.loc 1 183 0
 4645 12d8 E5110FE3 		ldr	r0, [r1, #-4067]
 4646 12dc E3100001 		tst	r0, #1
 4647 12e0 E3E06A0F 		mvn	r6, #61440
 4648 12e4 0AFFFFFB 		beq	.L293
 184:../lib/io_driver.c **** 	UART0_DATA = (ch & 0x000000FF);
 4649              		.loc 1 184 0
 4650 12e8 E5063FE7 		str	r3, [r6, #-4071]
 4651              	.LVL555:
 4652              	.LBE1143:
 4653              	.LBE1144:
  10:../lib/uart.c **** 	while ((ch = *string)){
 4654              		.loc 2 10 0
 4655 12ec E5F23001 		ldrb	r3, [r2, #1]!	@ zero_extendqisi2
 4656              	.LVL556:
 4657 12f0 E3530000 		cmp	r3, #0
 4658 12f4 1AFFFFF7 		bne	.L293
 4659              	.LBE1140:
 4660              	.LBE1139:
 159:main.c        **** 					uart0_scanf(buffer,2,1);
 4661              		.loc 4 159 0
 4662 12f8 E1A00005 		mov	r0, r5
 4663 12fc E3A01002 		mov	r1, #2
 4664 1300 E3A02001 		mov	r2, #1
 4665              	.LVL557:
 4666 1304 EBFFFFFE 		bl	uart0_scanf
 4667              	.LVL558:
 160:main.c        **** 					device_id = (unsigned char)hex_string_to_long(buffer, 2);
 4668              		.loc 4 160 0
 4669 1308 E1A00005 		mov	r0, r5
 4670 130c E3A01002 		mov	r1, #2
 4671 1310 EBFFFFFE 		bl	hex_string_to_long
 4672              	.LVL559:
 161:main.c        **** 					if(device_id == 0){
 4673              		.loc 4 161 0
 4674 1314 E21040FF 		ands	r4, r0, #255
 4675              	.LVL560:
 4676 1318 1AFFFB95 		bne	.L227
 4677 131c E51F224C 		ldr	r2, .L609+244
 4678              	.LBB1145:
 4679              	.LBB1146:
  10:../lib/uart.c **** 	while ((ch = *string)){
 4680              		.loc 2 10 0
 4681 1320 E3A03020 		mov	r3, #32
 4682              	.L297:
 4683              	.LBB1147:
 4684              	.LBB1148:
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 4685              		.loc 1 183 0
 4686 1324 E5161FE3 		ldr	r1, [r6, #-4067]
 4687 1328 E3110001 		tst	r1, #1
 4688 132c E3E01A0F 		mvn	r1, #61440
 4689 1330 0AFFFFFB 		beq	.L297
 184:../lib/io_driver.c **** 	UART0_DATA = (ch & 0x000000FF);
 4690              		.loc 1 184 0
 4691 1334 E5013FE7 		str	r3, [r1, #-4071]
 4692              	.LVL561:
 4693              	.LBE1148:
 4694              	.LBE1147:
  10:../lib/uart.c **** 	while ((ch = *string)){
 4695              		.loc 2 10 0
 4696 1338 E4D23001 		ldrb	r3, [r2], #1	@ zero_extendqisi2
 4697              	.LVL562:
 4698 133c E3530000 		cmp	r3, #0
 4699 1340 1AFFFFF7 		bne	.L297
 4700 1344 EAFFFB7F 		b	.L225
 4701              	.LVL563:
 4702              	.L608:
 4703              	.LBE1146:
 4704              	.LBE1145:
 111:main.c        **** 				if((buffer[0] == 'S') && (buffer[1] == 'M') && (buffer[2] == 'B') && (buffer[3] == 'R')){
 4705              		.loc 4 111 0 discriminator 1
 4706 1348 E5DD3009 		ldrb	r3, [sp, #9]	@ zero_extendqisi2
 4707 134c E353004D 		cmp	r3, #77
 4708 1350 1AFFFFCA 		bne	.L252
 4709 1354 E5DD300A 		ldrb	r3, [sp, #10]	@ zero_extendqisi2
 4710 1358 E3530042 		cmp	r3, #66
 4711 135c 1AFFFFC7 		bne	.L252
 4712 1360 E5DD300B 		ldrb	r3, [sp, #11]	@ zero_extendqisi2
 4713 1364 E3530052 		cmp	r3, #82
 4714 1368 1AFFFFC4 		bne	.L252
 112:main.c        **** 					uart0_scanf(buffer,4,0); // get image size
 4715              		.loc 4 112 0
 4716 136c E3A01004 		mov	r1, #4
 4717 1370 E1A02004 		mov	r2, r4
 4718 1374 E1A00005 		mov	r0, r5
 4719 1378 EBFFFFFE 		bl	uart0_scanf
 4720              	.LVL564:
 4721              	.LBB1149:
 4722              	.LBB1150:
  34:main.c        **** 	n = a|(b<<8)|(c<<16)|(d<<24);
 4723              		.loc 4 34 0
 4724 137c E5DD2009 		ldrb	r2, [sp, #9]	@ zero_extendqisi2
 4725 1380 E5DD100A 		ldrb	r1, [sp, #10]	@ zero_extendqisi2
 4726 1384 E1A02802 		mov	r2, r2, asl #16
 4727 1388 E5DD300B 		ldrb	r3, [sp, #11]	@ zero_extendqisi2
 4728 138c E1822401 		orr	r2, r2, r1, asl #8
 4729 1390 E5DD1008 		ldrb	r1, [sp, #8]	@ zero_extendqisi2
 4730 1394 E1823003 		orr	r3, r2, r3
 4731              	.LBE1150:
 4732              	.LBE1149:
 114:main.c        **** 					if (adr_buffer > RAM_SIZE-8){
 4733              		.loc 4 114 0
 4734 1398 E51F22C4 		ldr	r2, .L609+248
 4735              	.LBB1152:
 4736              	.LBB1151:
  34:main.c        **** 	n = a|(b<<8)|(c<<16)|(d<<24);
 4737              		.loc 4 34 0
 4738 139c E1833C01 		orr	r3, r3, r1, asl #24
 4739              	.LVL565:
 4740              	.LBE1151:
 4741              	.LBE1152:
 114:main.c        **** 					if (adr_buffer > RAM_SIZE-8){
 4742              		.loc 4 114 0
 4743 13a0 E1530002 		cmp	r3, r2
 4744 13a4 92836004 		addls	r6, r3, #4
 4745 13a8 9A00000D 		bls	.L256
 4746 13ac E51F32D4 		ldr	r3, .L609+252
 4747              	.LVL566:
 4748              	.LBB1153:
 4749              	.LBB1154:
 4750              	.LBB1155:
 4751              	.LBB1156:
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 4752              		.loc 1 183 0
 4753 13b0 E1A01006 		mov	r1, r6
 4754              	.LVL567:
 4755              	.L257:
 4756              	.LBE1156:
 4757              	.LBE1155:
  10:../lib/uart.c **** 	while ((ch = *string)){
 4758              		.loc 2 10 0
 4759 13b4 E5F32001 		ldrb	r2, [r3, #1]!	@ zero_extendqisi2
 4760              	.LVL568:
 4761 13b8 E3520000 		cmp	r2, #0
 4762 13bc 0AFFFB61 		beq	.L225
 4763              	.L259:
 4764              	.LBB1158:
 4765              	.LBB1157:
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 4766              		.loc 1 183 0
 4767 13c0 E5160FE3 		ldr	r0, [r6, #-4067]
 4768 13c4 E3100001 		tst	r0, #1
 4769 13c8 0AFFFFFC 		beq	.L259
 184:../lib/io_driver.c **** 	UART0_DATA = (ch & 0x000000FF);
 4770              		.loc 1 184 0
 4771 13cc E5012FE7 		str	r2, [r1, #-4071]
 4772              	.LVL569:
 4773 13d0 EAFFFFF7 		b	.L257
 4774              	.LVL570:
 4775              	.L273:
 4776              	.LBE1157:
 4777              	.LBE1158:
 4778              	.LBE1154:
 4779              	.LBE1153:
 4780              	.LBB1159:
 4781              	.LBB1108:
 167:../lib/io_driver.c **** 		temp = UART0_DATA;
 4782              		.loc 1 167 0
 4783 13d4 E5132FE7 		ldr	r2, [r3, #-4071]
 4784              	.LVL571:
 4785              	.LBE1108:
 4786              	.LBE1159:
 136:main.c        **** 				while(io_uart0_read_byte() != -1);
 4787              		.loc 4 136 0
 4788 13d8 E3720001 		cmn	r2, #1
 4789 13dc 1AFFFF5A 		bne	.L276
 4790 13e0 EAFFFF5C 		b	.L275
 4791              	.LVL572:
 4792              	.L256:
 119:main.c        **** 					while(data_pointer != adr_buffer+4){
 4793              		.loc 4 119 0 discriminator 1
 4794 13e4 E1540006 		cmp	r4, r6
 4795 13e8 0AFFFB99 		beq	.L512
 120:main.c        **** 						uart0_scanf(buffer,4,0); // get word
 4796              		.loc 4 120 0
 4797 13ec E3A01004 		mov	r1, #4
 4798 13f0 E3A02000 		mov	r2, #0
 4799 13f4 E1A00005 		mov	r0, r5
 4800 13f8 EBFFFFFE 		bl	uart0_scanf
 4801              	.LVL573:
 4802              	.LBB1160:
 4803              	.LBB1161:
  34:main.c        **** 	n = a|(b<<8)|(c<<16)|(d<<24);
 4804              		.loc 4 34 0
 4805 13fc E5DD2009 		ldrb	r2, [sp, #9]	@ zero_extendqisi2
 4806              	.LVL574:
 4807 1400 E5DD100A 		ldrb	r1, [sp, #10]	@ zero_extendqisi2
 4808              	.LVL575:
 4809 1404 E1A02802 		mov	r2, r2, asl #16
 4810              	.LVL576:
 4811 1408 E5DD300B 		ldrb	r3, [sp, #11]	@ zero_extendqisi2
 4812 140c E1821401 		orr	r1, r2, r1, asl #8
 4813              	.LVL577:
 4814 1410 E5DD2008 		ldrb	r2, [sp, #8]	@ zero_extendqisi2
 4815 1414 E1813003 		orr	r3, r1, r3
 4816 1418 E1833C02 		orr	r3, r3, r2, asl #24
 4817              	.LBE1161:
 4818              	.LBE1160:
 121:main.c        **** 						*data_pointer = qbytes_to_long(buffer); // store memory entry
 4819              		.loc 4 121 0
 4820 141c E4843004 		str	r3, [r4], #4
 4821              	.LVL578:
 4822 1420 EAFFFFEF 		b	.L256
 4823              		.cfi_endproc
 4824              	.LFE32:
 4826              		.section	.rodata.str1.4,"aMS",%progbits,1
 4827              		.align	2
 4828              	.LC0:
 4829 0000 0D0A0D0A 		.ascii	"\015\012\015\012\015\012+--------------------------"
 4829      0D0A2B2D 
 4829      2D2D2D2D 
 4829      2D2D2D2D 
 4829      2D2D2D2D 
 4830 0021 2D2D2D2D 		.ascii	"--------------------------------------+\015\012\000"
 4830      2D2D2D2D 
 4830      2D2D2D2D 
 4830      2D2D2D2D 
 4830      2D2D2D2D 
 4831 004b 00       		.space	1
 4832              	.LC1:
 4833 004c 7C202020 		.ascii	"|    <<< STORM Core Processor System - By Stephan N"
 4833      203C3C3C 
 4833      2053544F 
 4833      524D2043 
 4833      6F726520 
 4834 007f 6F6C7469 		.ascii	"olting >>>    |\015\012\000"
 4834      6E67203E 
 4834      3E3E2020 
 4834      20207C0D 
 4834      0A00
 4835 0091 000000   		.space	3
 4836              	.LC2:
 4837 0094 2B2D2D2D 		.ascii	"+--------------------------------------------------"
 4837      2D2D2D2D 
 4837      2D2D2D2D 
 4837      2D2D2D2D 
 4837      2D2D2D2D 
 4838 00c7 2D2D2D2D 		.ascii	"--------------+\015\012\000"
 4838      2D2D2D2D 
 4838      2D2D2D2D 
 4838      2D2D2B0D 
 4838      0A00
 4839 00d9 000000   		.space	3
 4840              	.LC3:
 4841 00dc 7C202020 		.ascii	"|         Bootloader for STORM SoC   Version: 20120"
 4841      20202020 
 4841      2020426F 
 4841      6F746C6F 
 4841      61646572 
 4842 010f 3532342D 		.ascii	"524-D         |\015\012\000"
 4842      44202020 
 4842      20202020 
 4842      20207C0D 
 4842      0A00
 4843 0121 000000   		.space	3
 4844              	.LC4:
 4845 0124 7C202020 		.ascii	"|               Contact: stnolting@googlemail.com  "
 4845      20202020 
 4845      20202020 
 4845      20202020 
 4845      436F6E74 
 4846 0157 20202020 		.ascii	"              |\015\012\000"
 4846      20202020 
 4846      20202020 
 4846      20207C0D 
 4846      0A00
 4847 0169 000000   		.space	3
 4848              	.LC5:
 4849 016c 2B2D2D2D 		.ascii	"+--------------------------------------------------"
 4849      2D2D2D2D 
 4849      2D2D2D2D 
 4849      2D2D2D2D 
 4849      2D2D2D2D 
 4850 019f 2D2D2D2D 		.ascii	"--------------+\015\012\015\012\000"
 4850      2D2D2D2D 
 4850      2D2D2D2D 
 4850      2D2D2B0D 
 4850      0A0D0A00 
 4851 01b3 00       		.space	1
 4852              	.LC6:
 4853 01b4 203C2057 		.ascii	" < Welcome to the STORM SoC bootloader console! >\015"
 4853      656C636F 
 4853      6D652074 
 4853      6F207468 
 4853      65205354 
 4854 01e6 0A203C20 		.ascii	"\012 < Select an operation from the menu below or p"
 4854      53656C65 
 4854      63742061 
 4854      6E206F70 
 4854      65726174 
 4855 0216 72657373 		.ascii	"ress >\015\012\000"
 4855      203E0D0A 
 4855      00
 4856 021f 00       		.space	1
 4857              	.LC7:
 4858 0220 203C2074 		.ascii	" < the boot key for immediate application start. >\015"
 4858      68652062 
 4858      6F6F7420 
 4858      6B657920 
 4858      666F7220 
 4859 0253 0A0D0A00 		.ascii	"\012\015\012\000"
 4860 0257 00       		.space	1
 4861              	.LC8:
 4862 0258 2030202D 		.ascii	" 0 - boot from core RAM (start application)\015\012"
 4862      20626F6F 
 4862      74206672 
 4862      6F6D2063 
 4862      6F726520 
 4863 0285 2031202D 		.ascii	" 1 - program core RAM via UART_0\015\012 2 - core R"
 4863      2070726F 
 4863      6772616D 
 4863      20636F72 
 4863      65205241 
 4864 02b2 414D2064 		.ascii	"AM dump\015\012\000"
 4864      756D700D 
 4864      0A00
 4865              	.LC9:
 4866 02bc 2033202D 		.ascii	" 3 - boot from I2C EEPROM\015\012 4 - program I2C E"
 4866      20626F6F 
 4866      74206672 
 4866      6F6D2049 
 4866      32432045 
 4867 02e9 4550524F 		.ascii	"EPROM via UART_0\015\012 5 - show content of I2C EE"
 4867      4D207669 
 4867      61205541 
 4867      52545F30 
 4867      0D0A2035 
 4868 0316 50524F4D 		.ascii	"PROM\015\012\000"
 4868      0D0A00
 4869 031d 000000   		.space	3
 4870              	.LC10:
 4871 0320 2061202D 		.ascii	" a - automatic boot configuration\015\012 h - help\015"
 4871      20617574 
 4871      6F6D6174 
 4871      69632062 
 4871      6F6F7420 
 4872 034d 0A207220 		.ascii	"\012 r - restart system\015\012\015\012Select: \000"
 4872      2D207265 
 4872      73746172 
 4872      74207379 
 4872      7374656D 
 4873 036e 0000     		.space	2
 4874              	.LC11:
 4875 0370 0D0A0D0A 		.ascii	"\015\012\015\012Application will start automaticall"
 4875      4170706C 
 4875      69636174 
 4875      696F6E20 
 4875      77696C6C 
 4876 0397 79206166 		.ascii	"y after download.\015\012-> Waiting for 'storm_prog"
 4876      74657220 
 4876      646F776E 
 4876      6C6F6164 
 4876      2E0D0A2D 
 4877 03c4 72616D2E 		.ascii	"ram.bin' in byte-stream mode...\000"
 4877      62696E27 
 4877      20696E20 
 4877      62797465 
 4877      2D737472 
 4878              	.LC12:
 4879 03e4 20496E76 		.ascii	" Invalid programming file!\015\012\015\012Select: \000"
 4879      616C6964 
 4879      2070726F 
 4879      6772616D 
 4879      6D696E67 
 4880 040b 00       		.space	1
 4881              	.LC13:
 4882 040c 20455252 		.ascii	" ERROR! Program file too big!\015\012\015\012\000"
 4882      4F522120 
 4882      50726F67 
 4882      72616D20 
 4882      66696C65 
 4883 042e 0000     		.space	2
 4884              	.LC14:
 4885 0430 0D0A0D0A 		.ascii	"\015\012\015\012Abort dumping by pressing any key.\015"
 4885      41626F72 
 4885      74206475 
 4885      6D70696E 
 4885      67206279 
 4886 0457 0A507265 		.ascii	"\012Press any key to continue.\015\012\015\012\000"
 4886      73732061 
 4886      6E79206B 
 4886      65792074 
 4886      6F20636F 
 4887 0477 00       		.space	1
 4888              	.LC15:
 4889 0478 0D0A0D0A 		.ascii	"\015\012\015\012Dumping completed.\015\012\015\012S"
 4889      44756D70 
 4889      696E6720 
 4889      636F6D70 
 4889      6C657465 
 4890 0493 656C6563 		.ascii	"elect: \000"
 4890      743A2000 
 4891 049b 00       		.space	1
 4892              	.LC16:
 4893 049c 0D0A0D0A 		.ascii	"\015\012\015\012Enter device address (2x hex_chars,"
 4893      456E7465 
 4893      72206465 
 4893      76696365 
 4893      20616464 
 4894 04c3 20736574 		.ascii	" set LSB to '0'): \000"
 4894      204C5342 
 4894      20746F20 
 4894      27302729 
 4894      3A2000
 4895 04d6 0000     		.space	2
 4896              	.LC17:
 4897 04d8 20496E76 		.ascii	" Invalid address!\015\012\015\012Select: \000"
 4897      616C6964 
 4897      20616464 
 4897      72657373 
 4897      210D0A0D 
 4898 04f6 0000     		.space	2
 4899              	.LC18:
 4900 04f8 20496E76 		.ascii	" Invalid boot device or file!\015\012\015\012Select"
 4900      616C6964 
 4900      20626F6F 
 4900      74206465 
 4900      76696365 
 4901 051f 3A2000   		.ascii	": \000"
 4902 0522 0000     		.space	2
 4903              	.LC19:
 4904 0524 2055706C 		.ascii	" Upload complete\015\012\000"
 4904      6F616420 
 4904      636F6D70 
 4904      6C657465 
 4904      0D0A00
 4905 0537 00       		.space	1
 4906              	.LC20:
 4907 0538 0D0A496E 		.ascii	"\015\012Invalid address!\015\012\015\012Select: \000"
 4907      76616C69 
 4907      64206164 
 4907      64726573 
 4907      73210D0A 
 4908 0557 00       		.space	1
 4909              	.LC21:
 4910 0558 0D0A4461 		.ascii	"\015\012Data will overwrite RAM content!\015\012-> "
 4910      74612077 
 4910      696C6C20 
 4910      6F766572 
 4910      77726974 
 4911 057f 57616974 		.ascii	"Waiting for 'storm_program.bin' in byte-stream mode"
 4911      696E6720 
 4911      666F7220 
 4911      2773746F 
 4911      726D5F70 
 4912 05b2 2E2E2E00 		.ascii	"...\000"
 4913 05b6 0000     		.space	2
 4914              	.LC22:
 4915 05b8 20496E76 		.ascii	" Invalid boot device or file!\015\012\015\012\000"
 4915      616C6964 
 4915      20626F6F 
 4915      74206465 
 4915      76696365 
 4916 05da 0000     		.space	2
 4917              	.LC23:
 4918 05dc 20446F77 		.ascii	" Download completed\015\012\000"
 4918      6E6C6F61 
 4918      6420636F 
 4918      6D706C65 
 4918      7465640D 
 4919 05f2 0000     		.space	2
 4920              	.LC24:
 4921 05f4 57726974 		.ascii	"Writing buffer to i2c EEPROM...\000"
 4921      696E6720 
 4921      62756666 
 4921      65722074 
 4921      6F206932 
 4922              	.LC25:
 4923 0614 20436F6D 		.ascii	" Completed\015\012\015\012\000"
 4923      706C6574 
 4923      65640D0A 
 4923      0D0A00
 4924 0623 00       		.space	1
 4925              	.LC26:
 4926 0624 0D0A0D0A 		.ascii	"\015\012\015\012Enter device address (2 hex-chars, "
 4926      456E7465 
 4926      72206465 
 4926      76696365 
 4926      20616464 
 4927 064b 73657420 		.ascii	"set LSB to '0'): \000"
 4927      4C534220 
 4927      746F2027 
 4927      3027293A 
 4927      2000
 4928 065d 000000   		.space	3
 4929              	.LC27:
 4930 0660 0D0A0D0A 		.ascii	"\015\012\015\012Abort dumping by pressing any key. "
 4930      41626F72 
 4930      74206475 
 4930      6D70696E 
 4930      67206279 
 4931 0687 4966206E 		.ascii	"If no data is shown,\015\012\000"
 4931      6F206461 
 4931      74612069 
 4931      73207368 
 4931      6F776E2C 
 4932 069e 0000     		.space	2
 4933              	.LC28:
 4934 06a0 74686520 		.ascii	"the selected device is not responding. Press any ke"
 4934      73656C65 
 4934      63746564 
 4934      20646576 
 4934      69636520 
 4935 06d3 7920746F 		.ascii	"y to continue.\015\012\015\012\000"
 4935      20636F6E 
 4935      74696E75 
 4935      652E0D0A 
 4935      0D0A00
 4936 06e6 0000     		.space	2
 4937              	.LC29:
 4938 06e8 0D0A0D0A 		.ascii	"\015\012\015\012Aborted!\000"
 4938      41626F72 
 4938      74656421 
 4938      00
 4939 06f5 000000   		.space	3
 4940              	.LC30:
 4941 06f8 0D0A0D0A 		.ascii	"\015\012\015\012Automatic boot configuration for po"
 4941      4175746F 
 4941      6D617469 
 4941      6320626F 
 4941      6F742063 
 4942 071f 7765722D 		.ascii	"wer-up:\015\012\000"
 4942      75703A0D 
 4942      0A00
 4943 0729 000000   		.space	3
 4944              	.LC31:
 4945 072c 5B333231 		.ascii	"[3210] configuration DIP switch\015\012 0000 - Star"
 4945      305D2063 
 4945      6F6E6669 
 4945      67757261 
 4945      74696F6E 
 4946 0759 7420626F 		.ascii	"t bootloader console\015\012 0001 - Automatic boot "
 4946      6F746C6F 
 4946      61646572 
 4946      20636F6E 
 4946      736F6C65 
 4947 0786 66726F6D 		.ascii	"from core RAM\015\012\000"
 4947      20636F72 
 4947      65205241 
 4947      4D0D0A00 
 4948 0796 0000     		.space	2
 4949              	.LC32:
 4950 0798 20303031 		.ascii	" 0010 - Automatic boot from I2C EEPROM (Address 0xA"
 4950      30202D20 
 4950      4175746F 
 4950      6D617469 
 4950      6320626F 
 4951 07cb 30290D0A 		.ascii	"0)\015\012\015\012Select: \000"
 4951      0D0A5365 
 4951      6C656374 
 4951      3A2000
 4952 07da 0000     		.space	2
 4953              	.LC33:
 4954 07dc 0D0A0D0A 		.ascii	"\015\012\015\012STORM SoC bootloader\015\012\000"
 4954      53544F52 
 4954      4D20536F 
 4954      4320626F 
 4954      6F746C6F 
 4955 07f7 00       		.space	1
 4956              	.LC34:
 4957 07f8 2730273A 		.ascii	"'0': Execute program in RAM.\015\012\000"
 4957      20457865 
 4957      63757465 
 4957      2070726F 
 4957      6772616D 
 4958 0817 00       		.space	1
 4959              	.LC35:
 4960 0818 2731273A 		.ascii	"'1': Write 'storm_program.bin' to the core's RAM vi"
 4960      20577269 
 4960      74652027 
 4960      73746F72 
 4960      6D5F7072 
 4961 084b 61205541 		.ascii	"a UART.\015\012\000"
 4961      52542E0D 
 4961      0A00
 4962 0855 000000   		.space	3
 4963              	.LC36:
 4964 0858 2732273A 		.ascii	"'2': Print current content of complete core RAM.\015"
 4964      20507269 
 4964      6E742063 
 4964      75727265 
 4964      6E742063 
 4965 0889 0A00     		.ascii	"\012\000"
 4966 088b 00       		.space	1
 4967              	.LC37:
 4968 088c 2733273A 		.ascii	"'3': Load boot image from EEPROM and start applicat"
 4968      204C6F61 
 4968      6420626F 
 4968      6F742069 
 4968      6D616765 
 4969 08bf 696F6E2E 		.ascii	"ion.\015\012\000"
 4969      0D0A00
 4970 08c6 0000     		.space	2
 4971              	.LC38:
 4972 08c8 2734273A 		.ascii	"'4': Write 'storm_program.bin' to I2C EEPROM via UA"
 4972      20577269 
 4972      74652027 
 4972      73746F72 
 4972      6D5F7072 
 4973 08fb 52542E0D 		.ascii	"RT.\015\012\000"
 4973      0A00
 4974 0901 000000   		.space	3
 4975              	.LC39:
 4976 0904 2735273A 		.ascii	"'5': Print content of I2C EEPROM.\015\012\000"
 4976      20507269 
 4976      6E742063 
 4976      6F6E7465 
 4976      6E74206F 
 4977              	.LC40:
 4978 0928 2761273A 		.ascii	"'a': Show DIP switch configurations for automatic b"
 4978      2053686F 
 4978      77204449 
 4978      50207377 
 4978      69746368 
 4979 095b 6F6F742E 		.ascii	"oot.\015\012\000"
 4979      0D0A00
 4980 0962 0000     		.space	2
 4981              	.LC41:
 4982 0964 2768273A 		.ascii	"'h': Show this screen.\015\012\000"
 4982      2053686F 
 4982      77207468 
 4982      69732073 
 4982      63726565 
 4983 097d 000000   		.space	3
 4984              	.LC42:
 4985 0980 2772273A 		.ascii	"'r': Reset system.\015\012\015\012\000"
 4985      20526573 
 4985      65742073 
 4985      79737465 
 4985      6D2E0D0A 
 4986 0997 00       		.space	1
 4987              	.LC43:
 4988 0998 426F6F74 		.ascii	"Boot EEPROM: 24xxnnn (like 24AA64), 7 bit address +"
 4988      20454550 
 4988      524F4D3A 
 4988      20323478 
 4988      786E6E6E 
 4989 09cb 20646F6E 		.ascii	" dont-care bit,\015\012\000"
 4989      742D6361 
 4989      72652062 
 4989      69742C0D 
 4989      0A00
 4990 09dd 000000   		.space	3
 4991              	.LC44:
 4992 09e0 636F6E6E 		.ascii	"connected to I2C_CONTROLLER_0, operating frequency "
 4992      65637465 
 4992      6420746F 
 4992      20493243 
 4992      5F434F4E 
 4993 0a13 69732031 		.ascii	"is 100kHz,\015\012\000"
 4993      30306B48 
 4993      7A2C0D0A 
 4993      00
 4994              	.LC45:
 4995 0a20 6D617869 		.ascii	"maximum EEPROM size = 65536 byte => 16 bit addresse"
 4995      6D756D20 
 4995      45455052 
 4995      4F4D2073 
 4995      697A6520 
 4996 0a53 732C0D0A 		.ascii	"s,\015\012\000"
 4996      00
 4997              	.LC46:
 4998 0a58 66697865 		.ascii	"fixed boot device address: 0xA0\015\012\015\012\000"
 4998      6420626F 
 4998      6F742064 
 4998      65766963 
 4998      65206164 
 4999              	.LC47:
 5000 0a7c 5465726D 		.ascii	"Terminal setup: 9600 baud, 8 data bits, no parity, "
 5000      696E616C 
 5000      20736574 
 5000      75703A20 
 5000      39363030 
 5001 0aaf 31207374 		.ascii	"1 stop bit\015\012\015\012\000"
 5001      6F702062 
 5001      69740D0A 
 5001      0D0A00
 5002 0abe 0000     		.space	2
 5003              	.LC48:
 5004 0ac0 466F7220 		.ascii	"For more information see the STORM Core / STORM SoC"
 5004      6D6F7265 
 5004      20696E66 
 5004      6F726D61 
 5004      74696F6E 
 5005 0af3 20646174 		.ascii	" datasheet\015\012\000"
 5005      61736865 
 5005      65740D0A 
 5005      00
 5006              	.LC49:
 5007 0b00 68747470 		.ascii	"http://opencores.org/project,storm_core\015\012\000"
 5007      3A2F2F6F 
 5007      70656E63 
 5007      6F726573 
 5007      2E6F7267 
 5008 0b2a 0000     		.space	2
 5009              	.LC50:
 5010 0b2c 68747470 		.ascii	"http://opencores.org/project,storm_soc\015\012\000"
 5010      3A2F2F6F 
 5010      70656E63 
 5010      6F726573 
 5010      2E6F7267 
 5011 0b55 000000   		.space	3
 5012              	.LC51:
 5013 0b58 436F6E74 		.ascii	"Contact: stnolting@googlemail.com\015\012\000"
 5013      6163743A 
 5013      2073746E 
 5013      6F6C7469 
 5013      6E674067 
 5014              	.LC52:
 5015 0b7c 28632920 		.ascii	"(c) 2012 by Stephan Nolting\015\012\015\012Select: "
 5015      32303132 
 5015      20627920 
 5015      53746570 
 5015      68616E20 
 5016 0ba3 00       		.ascii	"\000"
 5017              	.LC53:
 5018 0ba4 0D0A0D0A 		.ascii	"\015\012\015\012We'll send you back - to the future"
 5018      5765276C 
 5018      6C207365 
 5018      6E642079 
 5018      6F752062 
 5019 0bcb 212E0D0A 		.ascii	"!.\015\012\015\012\000"
 5019      0D0A00
 5020 0bd2 0000     		.space	2
 5021              	.LC54:
 5022 0bd4 202D2044 		.ascii	" - Doctor Emmet L. Brown\015\012\015\012Select: \000"
 5022      6F63746F 
 5022      7220456D 
 5022      6D657420 
 5022      4C2E2042 
 5023 0bf9 000000   		.space	3
 5024              	.LC55:
 5025 0bfc 20496E76 		.ascii	" Invalid operation!\015\012Try again: \000"
 5025      616C6964 
 5025      206F7065 
 5025      72617469 
 5025      6F6E210D 
 5026 0c1d 000000   		.space	3
 5027              	.LC56:
 5028 0c20 0D0A4170 		.ascii	"\015\012Application will start automatically after "
 5028      706C6963 
 5028      6174696F 
 5028      6E207769 
 5028      6C6C2073 
 5029 0c4d 75706C6F 		.ascii	"upload.\015\012-> Loading boot image...\000"
 5029      61642E0D 
 5029      0A2D3E20 
 5029      4C6F6164 
 5029      696E6720 
 5030 0c6f 00       		.space	1
 5031              	.LC57:
 5032 0c70 53656C65 		.ascii	"Select: \000"
 5032      63743A20 
 5032      00
 5033 0c79 000000   		.space	3
 5034              	.LC58:
 5035 0c7c 0D0A0D0A 		.ascii	"\015\012\015\012-> Starting application...\015\012\015"
 5035      2D3E2053 
 5035      74617274 
 5035      696E6720 
 5035      6170706C 
 5036 0c9d 0A00     		.ascii	"\012\000"
 5037 0c9f 00       		.text
 5038              	.Letext0:
DEFINED SYMBOLS
                            *ABS*:00000000 main.c
     /tmp/ccT258to.s:16     .text:00000000 $a
     /tmp/ccT258to.s:19     .text:00000000 io_read_gpio0_pin
     /tmp/ccT258to.s:44     .text:00000014 io_read_gpio0_port
     /tmp/ccT258to.s:64     .text:00000020 io_set_gpio0_pin
     /tmp/ccT258to.s:87     .text:00000038 io_clr_gpio0_pin
     /tmp/ccT258to.s:110    .text:00000050 io_toggle_gpio0_pin
     /tmp/ccT258to.s:133    .text:00000068 io_set_gpio0_port
     /tmp/ccT258to.s:152    .text:00000074 io_set_pwm
     /tmp/ccT258to.s:222    .text:000000dc io_get_pwm
     /tmp/ccT258to.s:276    .text:00000120 io_uart0_read_byte
     /tmp/ccT258to.s:302    .text:00000138 io_uart0_send_byte
     /tmp/ccT258to.s:330    .text:00000158 io_spi0_config
     /tmp/ccT258to.s:355    .text:00000170 io_spi0_speed
     /tmp/ccT258to.s:374    .text:0000017c io_spi0_trans
     /tmp/ccT258to.s:416    .text:000001bc io_spi0_enable
     /tmp/ccT258to.s:439    .text:000001d4 io_spi0_disable
     /tmp/ccT258to.s:462    .text:000001ec io_i2c0_speed
     /tmp/ccT258to.s:494    .text:00000218 io_i2c0_byte_transfer
     /tmp/ccT258to.s:680    .text:00000358 get_syscpreg
     /tmp/ccT258to.s:694    .text:00000364 $d
     /tmp/ccT258to.s:713    .text:000003a4 $a
     /tmp/ccT258to.s:850    .text:0000042c set_syscpreg
     /tmp/ccT258to.s:866    .text:0000043c $d
     /tmp/ccT258to.s:877    .text:0000045c $a
     /tmp/ccT258to.s:905    .text:0000047c io_enable_xint
     /tmp/ccT258to.s:940    .text:0000048c io_disable_xint
     /tmp/ccT258to.s:975    .text:0000049c uart0_printf
     /tmp/ccT258to.s:1021   .text:000004d8 uart0_scanf
     /tmp/ccT258to.s:1103   .text:00000540 uart0_print_buffer
     /tmp/ccT258to.s:1156   .text:00000574 long_to_hex_string
     /tmp/ccT258to.s:1239   .text:000005e4 get_adc
     /tmp/ccT258to.s:1336   .text:00000684 $d
     /tmp/ccT258to.s:1340   .text:00000688 $a
     /tmp/ccT258to.s:1343   .text:00000688 delay
     /tmp/ccT258to.s:1379   .text:000006b0 string_cmpc
     /tmp/ccT258to.s:1431   .text:000006f8 hex_string_to_long
     /tmp/ccT258to.s:1514   .text:00000774 qbytes_to_long
     /tmp/ccT258to.s:1543   .text.startup:00000000 $a
     /tmp/ccT258to.s:1546   .text.startup:00000000 main
     /tmp/ccT258to.s:4244   .text.startup:00000fe4 $d
     /tmp/ccT258to.s:4311   .text.startup:000010e4 $a
     /tmp/ccT258to.s:4827   .rodata.str1.4:00000000 $d
     /tmp/ccT258to.s:4881   .rodata.str1.4:0000040c .LC13
     /tmp/ccT258to.s:4896   .rodata.str1.4:000004d8 .LC17
     /tmp/ccT258to.s:4903   .rodata.str1.4:00000524 .LC19
     /tmp/ccT258to.s:4917   .rodata.str1.4:000005dc .LC23
     /tmp/ccT258to.s:4920   .rodata.str1.4:000005f4 .LC24
     /tmp/ccT258to.s:4922   .rodata.str1.4:00000614 .LC25
                     .debug_frame:00000010 $d

NO UNDEFINED SYMBOLS
